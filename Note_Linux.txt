
Linux Note.

/***************************************************************************/
// 常用名詞
/***************************************************************************/
WPS (Wi-Fi Protected Setup) 
是Wi- Fi聯盟推動的一個協定，主要目的是為了簡化用戶在無線安全性方面的設定。
連線模式：當AP進入WPS模式之後，使用者只需在Client端按下一個按鈕便可以成功連線，無須再做繁瑣的安全性設定。
加密模式：WPS功能只有在WPA或WPA2的加密模式之下才能使用。

加密設定
WEP：
可以使用64-bit或128-bit的金鑰長度，但64-bit的金鑰只能使用5個ASCII標準碼(汎稱大小寫英文字母、數字與有效字元)，容易破解；
而128-bit的金鑰雖然有13個ASCII碼，但被破解的風險還是高於WPA，所以一樣要做安全加密，倒不如直接選用WPA加密。
WPA/WPA2：
WPA意指Wi-Fi聯盟定義的第1版WPA，所以WPA2就是指第2版。
這兩版之間最大的差異是WPA 採用TKIP數據處理方式，是WEP加密的一個弱點補強版，因架構不變，所以還是存在一些原始缺陷；
而WPA2 則是採用不同於WEP與 TKIP 的CCMP數據處理方式，此處理方式更嚴謹、更安全，是不錯的加密選擇。
其中，CCMP 是以AES演算法為基礎的數據處理方式，這也是目前被802.11i 支持使用在較嚴苛環境的加密方式。
WPS(Wi-Fi Protected Setup)：
是由Wi-Fi聯盟推廣「簡化無線網路安全性設定」的認證程式。
WPS建置方式減少了網路配置步驟，更容易實現網路安全。
你只要使用具備WPS功能的無線網路卡或其無線網路設備，不論是透過WPS按鍵還是軟體WPS功能選項，即能快速實現網路安全。

Cookie
「Cookie」是含有字元字串的小檔案，會在您瀏覽網站時由該網站傳送到您的電腦中，當您再次瀏覽同一個網站時，該網站就能透過 Cookie 辨識您的瀏覽器。
Cookie 可能會儲存使用者偏好設定和其他資訊。您可以將瀏覽器重設為拒絕所有 Cookie，或是在傳送 Cookie 時顯示提醒。
不過，若不啟用 Cookie，有些網站功能或服務可能無法正常運作。

IP 位址
每一部連線至網際網路的電腦均會分配到一個獨特的編號，也就是所謂的網際網路通訊協定 (IP) 位址。
由於這些編號通常依國家/地區為範圍來指定，因此 IP 位址經常用於識別網際網路連線電腦所在的國家/地區。

Wi-Fi直連（英語：Wi-Fi Direct）
之前曾被稱為Wi-Fi 點對點（Wi-Fi Peer-to-Peer），是一套軟體協定，讓 wifi 裝置可以不必透過無線網路基地台（Access Point），以點對點的方式，直接與另
一個 wifi 裝置連線，進行高速資料傳輸。這個協定由Wi-Fi聯盟發展、支援與授與認證，通過認證的產品將可獲得Wi-Fi CERTIFIED Wi-Fi Direct標誌。
Wi-Fi Direct架構在原有的 802.11a、802.11g、802.11n 之上，不支援802.11b。比既有的ad-hoc模式更快，同時也支援 WPA2 加密機制。
最大傳輸距離是200公尺，最大傳輸速度為250Mbps，使用2.4GHz與5GHz頻段。它支援一對一，以及一對多模式。


/***************************************************************************/
根目錄 (/) 的意義與內容：
/***************************************************************************/
根目錄是整個系統最重要的一個目錄，因為不但所有的目錄都是由根目錄衍生出來的， 同時根目錄也與開機/還原/系統修復等動作有關。 
由於系統開機時需要特定的開機軟體、核心檔案、開機所需程式、 函式庫等等檔案資料，若系統出現錯誤時，根目錄也必須要包含有能夠修復檔案系統的程式才行。 
因為根目錄是這麼的重要，所以在FHS的要求方面，他希望根目錄不要放在非常大的分割槽內， 因為越大的分割槽妳會放入越多的資料，如此一來根目錄所在分割槽就可能會有較多發生錯誤的機會。

因此FHS標準建議：根目錄(/)所在分割槽應該越小越好， 且應用程式所安裝的軟體最好不要與根目錄放在同一個分割槽內，保持根目錄越小越好。 如此不但效能較佳，根目錄所在的檔案系統也較不容易發生問題。

有鑑於上述的說明，因此FHS定義出根目錄(/)底下應該要有底下這些次目錄的存在才好：
目錄    應放置檔案內容
/bin    系統有很多放置執行檔的目錄，但/bin比較特殊。因為/bin放置的是在單人維護模式下還能夠被操作的指令。 
        在/bin底下的指令可以被root與一般帳號所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。
/boot   這個目錄主要在放置開機會使用到的檔案，包括Linux核心檔案以及開機選單與開機所需設定檔等等。 
        Linux kernel常用的檔名為：vmlinuz，如果使用的是grub這個開機管理程式， 則還會存在/boot/grub/這個目錄喔！
/dev    在Linux系統上，任何裝置與周邊設備都是以檔案的型態存在於這個目錄當中的。你只要透過存取這個目錄底下的某個檔案，就等於存取某個裝置囉～ 
        比要重要的檔案有/dev/null, /dev/zero, /dev/tty, /dev/lp*, /dev/hd*, /dev/sd*等等
/etc    系統主要的設定檔幾乎都放置在這個目錄內，例如人員的帳號密碼檔、 各種服務的啟始檔等等。
        一般來說，這個目錄下的各檔案屬性是可以讓一般使用者查閱的， 但是只有root有權力修改。FHS建議不要放置可執行檔(binary)在這個目錄中喔。
        比較重要的檔案有： /etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/ 等等。另外，其下重要的目錄有：
        /etc/init.d/：所有服務的預設啟動 script 都是放在這裡的，例如要啟動或者關閉 iptables 的話：『 /etc/init.d/iptables start』、『/etc/init.d/iptables stop』
        /etc/xinetd.d/：這就是所謂的super daemon管理的各項服務的設定檔目錄。
        /etc/X11/：與 X Window 有關的各種設定檔都在這裡，尤其是 xorg.conf 這個 X Server 的設定檔。
/home   這是系統預設的使用者家目錄(home directory)。在你新增一個一般使用者帳號時， 預設的使用者家目錄都會規範到這裡來。比較重要的是，家目錄有兩種代號喔：
        ~：代表目前這個使用者的家目錄，而 
        ~dmtsai ：則代表 dmtsai 的家目錄！
/lib    系統的函式庫非常的多，而/lib放置的則是在開機時會用到的函式庫， 以及在/bin或/sbin底下的指令會呼叫的函式庫而已。 
        什麼是函式庫呢？妳可以將他想成是『外掛』，某些指令必須要有這些『外掛』才能夠順利完成程式的執行之意。 
        尤其重要的是/lib/modules/這個目錄， 因為該目錄會放置核心相關的模組(驅動程式)喔！
/media  media是『媒體』的英文，顧名思義，這個/media底下放置的就是可移除的裝置啦！ 包括軟碟、光碟、DVD等等裝置都暫時掛載於此。
        常見的檔名有：/media/floppy, /media/cdrom等等。
/mnt    如果妳想要暫時掛載某些額外的裝置，一般建議妳可以放置到這個目錄中。 在古早時候，這個目錄的用途與/media相同啦！
        只是有了/media之後，這個目錄就用來暫時掛載用了。
/opt    這個是給第三方協力軟體放置的目錄。什麼是第三方協力軟體啊？ 
        舉例來說，KDE這個桌面管理系統是一個獨立的計畫，不過他可以安裝到Linux系統中，因此KDE的軟體就建議放置到此目錄下了。 
        另外，如果妳想要自行安裝額外的軟體(非原本的distribution提供的)，那麼也能夠將你的軟體安裝到這裡來。 
        不過，以前的Linux系統中，我們還是習慣放置在/usr/local目錄下呢！
/root   系統管理員(root)的家目錄。之所以放在這裡，是因為如果進入單人維護模式而僅掛載根目錄時， 
        該目錄就能夠擁有root的家目錄，所以我們會希望root的家目錄與根目錄放置在同一個分割槽中。
/sbin   Linux有非常多指令是用來設定系統環境的，這些指令只有root才能夠利用來『設定』系統，其他使用者最多只能用來『查詢』而已。 
        放在/sbin底下的為開機過程中所需要的，裡面包括了開機、修復、還原系統所需要的指令。 至於某些伺服器軟體程式，一般則放置到/usr/sbin/當中。
        至於本機自行安裝的軟體所產生的系統執行檔(system binary)， 則放置到/usr/local/sbin/當中了。
        常見的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。
/srv    srv可以視為『service』的縮寫，是一些網路服務啟動之後，這些服務所需要取用的資料目錄。 
        常見的服務例如WWW, FTP等等。舉例來說，WWW伺服器需要的網頁資料就可以放置在/srv/www/裡面。
/tmp    這是讓一般使用者或者是正在執行的程式暫時放置檔案的地方。 這個目錄是任何人都能夠存取的，所以你需要定期的清理一下。當然，重要資料不可放置在此目錄啊！ 因為FHS甚至建議在開機時，應該要將/tmp下的資料都刪除唷！

事實上FHS針對根目錄所定義的標準就僅有上面的咚咚，不過我們的Linux底下還有許多目錄你也需要瞭解一下的。 
底下是幾個在Linux當中也是非常重要的目錄喔：
目錄    應放置檔案內容
/lost+found     這個目錄是使用標準的ext2/ext3檔案系統格式才會產生的一個目錄，目的在於當檔案系統發生錯誤時， 將一些遺失的片段放置到這個目錄下。
        這個目錄通常會在分割槽的最頂層存在， 例如你加裝一顆硬碟於/disk中，那在這個系統下就會自動產生一個這樣的目錄『/disk/lost+found』
/proc   這個目錄本身是一個『虛擬檔案系統(virtual filesystem)』喔！他放置的資料都是在記憶體當中， 例如系統核心、行程資訊(process)、周邊裝置的狀態
        及網路狀態等等。因為這個目錄下的資料都是在記憶體當中， 所以本身不佔任何硬碟空間啊！
        比較重要的檔案例如：/proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/* 等等。
/sys    這個目錄其實跟/proc非常類似，也是一個虛擬的檔案系統，主要也是記錄與核心相關的資訊。 包括目前已載入的核心模組與核心偵測到的硬體裝置資訊等等。這個目錄同樣不佔硬碟容量喔！
除了這些目錄的內容之外，另外要注意的是，因為根目錄與開機有關，開機過程中僅有根目錄會被掛載， 其他分割槽則是在開機完成之後才會持續的進行掛載的行為。就是因為如此，因此根目錄下與開機過程有關的目錄， 就不能夠與根目錄放到不同的分割槽去！那哪些目錄不可與根目錄分開呢？有底下這些：
        
/etc：設定檔
/bin：重要執行檔
/dev：所需要的裝置檔案
/lib：執行檔所需的函式庫與核心所需的模組
/sbin：重要的系統執行檔
這五個目錄千萬不可與根目錄分開在不同的分割槽！請背下來啊！


/***************************************************************************/
// How to direct output from make to a file?
/***************************************************************************/
#make | tee make.log
make 2>&1|tee build.log 


/***************************************************************************/
// 更改HW MAC address
/***************************************************************************/
ifdown eth0
ifconfig eth0 hw ether xx-xx-xx-xx-xx-xx-xx
ifup eth0


/***************************************************************************/
//  install SSH                                                            
/***************************************************************************/
At HOST PC(Windows XP), if you want use WinSCP to connect Client PC(Ubuntu),
Ubuntu should install SSH
        apt-get install openssh-server
        /etc/init.d/ssh restart
you can type ps to make sure ssh is start?
        ps -e |grep ssh


/***************************************************************************/
//  install TFTPD Server
/***************************************************************************/
首先安裝 tftpd package(會一併安裝 openbsd-inetd)：
    sudo apt-get install tftpd

接著查看並視需要修改 /etc/inetd.conf。與 tftpd 有關的預設值如下：
    tftp dgram udp wait nobody /usr/sbin/tcpd /usr/sbin/in.tftpd /srv/tftp

建議直接用預設值，所以你必須建立 /srv/tftp 來存放相關資料：
    mkdir -p /srv/tftp
    chmod 777 /srv/tftp

最後，重新啟動 inetd：
    /etc/init.d/openbsd-inetd restart

PS: if want install TFTP Client
        apt-get install tftp

* At target board to download file from TFTP Server
        tftp -g -r FILE XXX.XXX.XXX.XXX


/***************************************************************************/
重新抓一隻記錄一下重灌都在做的事，免得很難查...
/***************************************************************************/
sudo passwd root
讓root 有密可以登入

ssh
預設ubuntu 沒裝 先設定好proxy
下載最新的source-list
aptitude才有新套件可以選
安裝openssh-server
    sudo apt-get install openssh-server

Edit : /etc/ssh/sshd_config
FROM: 
PermitRootLogin without-password
TO: 
PermitRootLogin yes
Then restart SSH:
service ssh restart

vi 調整
裝新版的vim
參見http://blog.roodo.com/bejo/archives/7279917.html
上色

Search 上色
修改/etc/vim/vimrc
加上
set hlsearch

.bashrc 調整
改alias，LANG=C

StartUp-manager
修改開機顯示

安裝套件
SVN: Subversion
NFS : nfs-common nfs-kernel-server
SAMBA: samba
tftp: tftpd-hpa
g++: 往gcc 上面幾格 (工作)
zlib (工作 make)
patchutils ( code pacth 指令 )
ncurses (工作 make)
bison (工作 DLNA)
flex (工作 DLNA)
scew (工作 xml) 用原始碼裝
expat (工作 xml) 用原始碼裝
gettext (GNU gettext)


/***************************************************************************/
Ubuntu 安裝 GCC
/***************************************************************************/
在 Ubuntu 要安裝 GCC, 可以透過安裝 build-essential 套件輕鬆完成, build-essential 包含了編譯 C / C++ 所需的套件。
$ sudo apt-get update
$ sudo apt-get upgrade
$ sudo apt-get install build-essential

安裝好後可以用以下指令查看版本:
$ gcc -v
$ make -v


/***************************************************************************/
// Linux 常用指令集
/***************************************************************************/
linux根目錄下的目錄說明：
目錄名稱        說明                                    例
bin             系統的一些重要執行檔                    Kill、cp、df
boot            系統開機的一些載入檔    　
cdrom           光碟機裡的資料被掛上來的地方    　
dosc            開機時把dos檔案系統掛上來的地方 　
etc             系統設定檔      　
home            使用者的自家目錄所在、ftp server        　
lib             基本函數庫      　
Lost+found      系統檢查結果    　
mnt             可以掛上其它檔案系統    　
proc            整個系統運作資訊        　
root            系統管理者的自家目錄所在        　
sbin            一些設定的可執行程式、設定網路  　
tmp             雜七雜八的東西  　
usr             應用程式                                X-window
var             記載著各種系統上的變數的地方    　
vmlinuz         系統核心檔案    　

/proc 下的檔案介紹：
more cpuinfo：顯示有關cpu的訊息
more devices：區塊設備、字元設備
more filesystems：目前核心技援的檔案系統
more dma：直接記憶體存取
more interrupts：中斷向量值、中斷次數
more ioports：系統中每個設備的輸出／輸入埠的位址範圍
more meminfo：記憶體分配狀態
more pci：顯示PCI介面訊息

終端機資料設定檔：/etc/termcap
export TERM=vt100    (設定終端機為vt100；bash shell)

如何設定指令的別名：例：將 ls -l 設定成dir
alias dir='ls -l'        (以後下dir指令相當於下 ls -l 指令)

如何更改系統提示符號：
ps1='參數'    (一般指令列的提示符號)
ps2='參數'    (當指令太長需換行時第二行的提示符號)
ps1的參數：
\h主機名稱
\w 當時目錄所在
\s shell的名稱
\$ 如果是使用者為root時顯示#；其它使用者顯示$
\t 以時間來表示
\d 以日期來表示
\u 目前的使用者代號
\# 指令的序能
\! 指令的歷史序號
\\ 顯示\符號
字串：顯示此字串

linux之shell scripts (類似dos之批次檔)
例：製做類似dos之diskcopy外部指令
檔案名稱：diskcopy
    #!/bin/sh
    echo -n "Insert source disk in first floppy drive,then hit enter"
    read ans;
    dd if=/dev/fd0 of=/tmp/dcopy$$
    echo -n "Remove source disk and insert other disk ,then hit enter"
    read ans;
    dd of=/dev/fd0 if=/tmp/dcopy$$
    /bin/rm -f /tmp/dcopy$$
備註：不用副檔名；需更改檔案屬性為可執行；例 chmod 755 diskcopy

ls：列出檔案資訊 → 類似dos之dir
-l：列出詳細的檔案資訊
-a：列出全部檔案包括隱藏檔
-R：遞回列出檔案及子目錄其下的所有子目錄和檔案
-x：以多欄方式列出，字母順序由左而右
-i：以i -node來列出，會列出每個檔案在磁碟中的編號
-m：列出檔案時以逗號 , 來分隔
-n：把群組及檔案擁有者名稱轉成數字代碼
-t：依檔案的修改時間排序 (由新而舊)
-u：依檔案上次的存取時間排序 (需與t配合)
-s：檔案的大小以區塊為單位 (每個區塊block = 512 bytes)
-o：用顏色來顯示各種類別的檔案
-r：以相反的英文字母順序顯示
-d：只顯示目錄訊息而非目錄下的檔案

ln 製作捷徑檔：
ln -參數 已存在的檔案 要連結成的檔案
ln -參數 原來的目錄 要連結的目錄
參數說明：
不加：預設值；只限於相同檔案系統間的連結，且不能連結目錄
s：可作不同檔案系統間的連結，且能連結目錄
f：如果要連結成的檔案已存在，則砍掉這個已存在的檔案
n：如果要連結成的檔案已存在，則停止連結，不會砍掉該檔案

cat：顯示檔案內容    (類似dos之type)
cat -參數 檔名
若不加參數：即 cat 新檔案 (類似dos之copy con 新檔名)
按 ctrl + d 結束並儲存

more：顯示檔案的內容，如果超過一頁則暫停    (類似dos之more)
more -參數 檔名
指令 | more    (類似dos之指令|more；如type 檔名|more)
參數說明：
p：先清除螢幕再列出
c：每頁都清除螢幕一次再從螢幕最頂端列出
s：如果檔案中有許多連續空白列時，只顯示一列
l：忽略檔案中的跳頁符號

mv：更改、移動目錄或檔案 (類似dos之ren、move)
mv -參數 來源檔 (或目錄) 目的檔 (或目錄)
參數說明：
b：移動之前先做備份
v：做完移動之後顯示所做的移動情形
f：強迫性移動，不會詢問使用者是否確認

pwd：顯示目前工作目錄路徑

passwd：改變密碼

rm：刪除檔案或目錄        (類似dos之del、deltree)
rm -參數 檔案或目錄
r：刪除其下的檔案及目錄    (類似dos之deltree)
i：刪除時提出警告
f：刪除時不提出警告
d：刪除目錄，即使該目錄並非空目錄

cp：複製檔案        (類似dos之copy)
cp -參數 來源檔 (或目錄) 目的檔 (或目錄)
a：拷貝目錄，保留所有的資訊，包括連結的檔
d：保留連結的檔案
s：製造符號連結
f：拷貝時若相同檔名的檔案直接複蓋不提出警告
i：拷貝時若相同檔名的檔案不直接複蓋而會提出警告
l：不拷貝，但是連結檔案
p：保留檔案的修改時間及存取權限
r：拷貝時包含目錄及目錄下的檔案

mkdir：建立子目錄    (類似dos之md)
mkdir -參數 目錄名稱
p：連續建立兩個以上不存在的目錄
m：設定這個目錄的存取權限

cd 子目錄名稱 → 轉移目錄 (類似dos之cd)
cd ~ → 回自家目錄
..為上一層目錄
分隔符號號為／非dos的＼

rmdir：刪除子目錄，必須為空目錄 (類似dos之rd)
rmkdir -參數 子目錄名稱
p：若刪除此目錄之後，其上層目錄變成空目錄，則一併刪除

grep：用關鍵字找尋檔案
grep -參數 '字串' 要尋找的來源檔案
數字：列出找到字串的檔案名稱和字串前後幾行的內容
A 數字：列出找到字串的檔案名稱和字串後幾行的內容
B 數字：列出找到字串的檔案名稱和字串前幾行的內容
c：顯示找到該字串的個數，不會顯示檔案內容
h：不會顯示檔名，只會顯示內容
i：忽略大小寫
L：只顯示檔名一次
m：只找尋字串完全相同者

dd：字碼轉換程式 將軟碟上的資料寫成一個檔，或把一個檔寫入磁碟
dd if=輸入檔或設備名稱 of=輸出檔或設備名稱
skip=blocks → 跳過讀入緩衝區的區塊數
bs=bytes → 設定讀／寫緩衝區的bytes
cbs=bytes → 一次轉換的bytes
ibs=bytes → 讀入緩衝區的bytes
obs=bytes → 寫入緩衝區的bytes
count=blocks → 只寫入block數
conu=
ascii → 將EBCDIC碼轉成ASCII
ebcdic → 將ASCII碼轉成EBCDIC
ibm → 將ASCII碼轉成IBM
block → 將變動位元轉成固定字元
ublock → 將固定位元轉成變動字元
lcase → 將大寫變小寫
ucase → 將小寫變大寫
swab → 將每一組bytes的資料做交換
noerror → 忽略錯誤
notrunc → 不要打斷 truntate 的輸出檔
sync → 對ibs所指定的區塊大小填入空白

df：查詢硬碟使用量
a：顯示全部的檔案系統和各分割區的磁碟使用情形
i：顯示i -nodes的使用量
k：大小用k來表示 (預設值)
t：顯示某一個檔案系統的所有分割區磁碟使用量
x：顯示不是某一個檔案系統的所有分割區磁碟使用量
T：顯示每個分割區所屬的檔案系統名稱

du：查詢檔案或目錄的磁碟使用空間
a：顯示全部目錄和其次目錄下的每個檔案所佔的磁碟空間
b：大小用bytes來表示 (預設值為k bytes)
c：最後再加上總計 (預設值)
l：計算所有檔案大小
s：只顯示各檔案大小的總合
x：只計算同屬同一個檔案系統的檔案
L：計算所有的檔案大小

find：找尋檔案、目錄
find 【起始目錄】 -name 【欲找的檔名】 -print
從起始目錄開始尋找檔案；使用萬用字元*時須在檔名兩端加"

fsck：檢查、修復linux檔案系統
fsck -參數 分割區名稱
a：自動修復
r：執行時會詢問
V：顯示處理時的每一個步驟
t：指定一個檔案系統
n：不要真正執行，只看執行時會做那些動做

mount：掛上檔案系統
mount -參數 設備名稱 存放目錄
mount ip位址:/所提供的目錄 存放目錄
設備名稱：如/dev/hda2、/dev/fd0
存放目錄：必須是已存在的目錄
不加參數：顯示目前已經掛上來的檔案系統、目錄
a：掛上/etc/fstab下所述全部的檔案系統
t：指定所掛上來的檔案系統的名稱 (見/proc/filesystems)
n：掛上檔案系統時不會把檔案系統的資料寫入/etc/mtab中
w：檔案系統設定為可讀寫
r：掛上來的檔案系統設定為唯讀
例：mount -t iso9660 /dev/hdd /cdrom
掛上光碟機，把光碟機之資料放入/cdrom目錄之中

umount：卸下已掛上的檔案系統
umount 已經掛上的目錄或設備名稱
例：umount /cdrom → 卸下/cdrom目錄

mke2fs：製作檔案系統 (類似dos之format)
mke2fs -參數 設備名稱

adduser：新增使用者

chmod：改變檔案權限屬性
chmod □□□ 檔名    → □□□ 代表雍有者；群組；全體使用者
例：111 101 101 → □□□ = 755；
擁有者可讀、寫、執行；群組及全體使用者可讀、執行

chown：更改某個檔案或目錄的擁有者或擁有群組
chown -參數 擁有者 (或擁有群組) 檔案
R：將目錄下之檔案及其子目錄一併更改擁有者
v：執行完後顯示訊息

su：將一個普通使用者提昇為超級使用者

who：顯示目前線上使用者
-m：顯示本身的資料
-q：顯示使用者帳號和線上人數
-i：顯示使用者的閒置時間
-w：顯示線上使用者能否用write傳送訊息給他

w：顯示目前線上使用者     (可顯示正在執行的指令)

vall <檔案名稱：傳送訊息給線上所有使用者 (root專用)

write：傳送訊息給線上某一位使用者
write 使用者帳號 終端機名稱

mesg y 或 mesg n：設定是否讓別人傳送訊息給自已

talk 使用者帳號 終端機名稱：與別人聊天

sync：把記憶體中的資料寫入硬碟

date：顯示日期、時間

shutdown：關機
shutdown -參數 時間 訊息
k：並非真正關機，只是送出訊息
r：關機後重新開機
h：關機後不重新開機
f：快速關機
n：快速關機，不要經過init的程式
c：取消關時的程式
t：在警告訊息和刪除信號間做停留
時間可用now或任意數字 (代表分鐘)

reboot：快速關機 (類似按 Alt + Ctrl + Del 鍵

top：查看系統狀態；每隔幾秒更新一次，按 Ctrl + c 結束

ps：查看系統中正在執行的程式之程式資料
-l：長格式顯示
-u：顯示使用者名稱和起始時間
-i：顯示各程式的詳細執行情況
-s：顯示各程式的訊號名稱
-v：顯示虛擬記憶體使用情況
-m：顯示記憶體分配情形
-f：顯示執行的路行群
-a：其它使用者執行的程式一併顯示出來
-x：顯示所有程式
-r：顯示前景執行的程式
-c：只顯示執行程式的名字
-e：顯示執行程式的環境變數
-f：不顯示標題欄
-w：若訊息一列無法容納，則換列顯示

kill：終止程式之執行 (配合ps指令)
kill 程式號碼 (pid)    → 強迫終止程式之執行
kill -l     → 列出所有的信號

uname：查詢linux版本 (/proc/uname)

free：查詢目前記憶體的使用情形

uptime：顯示目前的使用者和平均的系統負荷

ftp：檔案傳送
ftp IPAddress
ftp 127.0.0.1 → 連進自已的電腦
!：暫時離開ftp回到自已的電腦，exit回到ftp
bin：以binary模式ftp
get：下載檔案 → get 檔名 【新檔名】
mget：下載多個檔案 → mget 檔名 → 可使用 * 或 ?
put：上傳檔案 → put 檔名 【新檔名】
mput：上傳多個檔案
prompt：對答模式開關 → 預設值為 off
bye：結束ftp

telnet：連到別台機器
telnet IPAddress
telnet 127.0.0.1 → 連進自已的電腦

rlogin：連到別台機器
rlogin -l 簽入的帳號 IP

netstat：查詢網路目前狀況
-a：全部列出
-c：每隔幾秒鐘重新列一遍
-i：界面狀態
-n：以網路IP位址代替名稱列出網路連接情形
-o：列出時間狀態
-r：列出網路的路徑表
-t：列出tcp協定的連接情形
-u：列出udp協定的連接情形
-v：列出版本
-w：列出raw程式連結的資訊
-x：列出有關unix網域socket的資訊

nslookup：查詢一台機器的IP位址及其對應的網域名稱

finger：列出某人的線上資料
finger -參數 使用者名稱
s：使用短格式顯示使用者的各項資訊
l：使用長格式顯示使用者的各項資訊
p：使用長格式顯示時不列出計畫檔和專案檔

ping：查詢網路上某台主機是否開著
ping -參數 主機位址
c 次數：送幾次封包給這台主機，然後等待回應
d：設定SO_DEBUG選項
f：大量且快速的送網路封包給一台主機，看它的回應
i 秒數：設定幾秒鐘送一次封包給一台主機，預設值1秒
q：不顯示傳送封包的資訊，只顯示最後結果
l 次數：在次數內，以最快速的方式送封包給一台主機

man：查詢某個指令的輔助說明 → man 指令名稱

help：查詢某個內建指令的說明 (bash shell) → help 內建指令名稱

whereis：尋找某個指令的檔案位置 → whereis 指令名稱

locate：找尋檔案 → locate 相關字

whatis：查詢某個指令的用途 → whatis 指令名稱

at：設定某一個時間執行某一個指令

crontab：設定每天或每月定期執行的指令

nohup：設定退出系統後，程式仍不被終止

echo：印出字串

clear：清除螢幕

指令&     → 將該程式弄到背景執行

cal 月 年：顯示月曆
-j：顯示查詢的那一天為每年的第幾天
-y：顯示整年的月曆
 如何在一塊網路卡上Bind多個IP：/sbin/ifconfig eth0:1 210.202.165.1 up

tar
tar 的選項與參數非常的多！我們只講幾個常用的選項
[root@www ~]# tar [-j|-z] [cv] [-f 建立的檔名] filename... <==打包與壓縮
[root@www ~]# tar [-j|-z] [tv] [-f 建立的檔名]             <==察看檔名
[root@www ~]# tar [-j|-z] [xv] [-f 建立的檔名] [-C 目錄]   <==解壓縮
選項與參數：
-c  ：建立打包檔案，可搭配 -v 來察看過程中被打包的檔名(filename)
-t  ：察看打包檔案的內容含有哪些檔名，重點在察看『檔名』就是了；
-x  ：解打包或解壓縮的功能，可以搭配 -C (大寫) 在特定目錄解開
      特別留意的是， -c, -t, -x 不可同時出現在一串指令列中。
-j  ：透過 bzip2 的支援進行壓縮/解壓縮：此時檔名最好為 *.tar.bz2
-z  ：透過 gzip  的支援進行壓縮/解壓縮：此時檔名最好為 *.tar.gz
-v  ：在壓縮/解壓縮的過程中，將正在處理的檔名顯示出來！
-f filename：-f 後面要立刻接要被處理的檔名！建議 -f 單獨寫一個選項囉！
-C 目錄    ：這個選項用在解壓縮，若要在特定目錄解壓縮，可以使用這個選項。
其他後續練習會使用到的選項介紹：
-p(小寫) ：保留備份資料的原本權限與屬性，常用於備份(-c)重要的設定檔
-P(大寫) ：保留絕對路徑，亦即允許備份資料中含有根目錄存在之意；
--exclude=FILE：在壓縮的過程中，不要將 FILE 打包！
其實最簡單的使用 tar 就只要記憶底下的方式即可：
    壓　縮：tar -jcv -f filename.tar.bz2 要被壓縮的檔案或目錄名稱
    查　詢：tar -jtv -f filename.tar.bz2
    解壓縮：tar -jxv -f filename.tar.bz2 -C 欲解壓縮的目錄
    壓　縮：tar -zcv -f filename.tar.gz 要被壓縮的檔案或目錄名稱
    解壓縮：tar -zxv -f filename.tar.gz -C 欲解壓縮的目錄
那個 filename.tar.bz2 是我們自己取的檔名，tar 並不會主動的產生建立的檔名喔！我們要自訂啦！ 
所以副檔名就顯的很重要了！如果不加 [-j|-z] 的話，檔名最好取為 *.tar 即可。
如果是 -j 選項，代表有 bzip2 的支援，因此檔名最好就取為 *.tar.bz2 ，因為 bzip2 會產生 .bz2 的副檔名之故！ 
至於如果是加上了 -z 的 gzip 的支援，那檔名最好取為 *.tar.gz 喔！瞭解乎？
另外，由於『 -f filename 』是緊接在一起的，過去很多文章常會寫成『-jcvf filename』，這樣是對的， 
但由於選項的順序理論上是可以變換的，所以很多讀者會誤認為『-jvfc filename』也可以～事實上這樣會導致產生的檔名變成 c ！ 
因為 -fc 嘛！所以囉，建議您在學習 tar 時，將『 -f filename 』與其他選項獨立出來，會比較不容易發生問題。

tee
雙向重導向
    Standard output ----> tee ---> Screen
                            |----> file
tee 會同時將資料流分送到檔案去與螢幕 (screen)；而輸出到螢幕的，其實就是 stdout ，可以讓下個指令繼續處理喔！

[root@www ~]# tee [-a] file
選項與參數：
-a  ：以累加 (append) 的方式，將資料加入 file 當中！
[root@www ~]# last | tee last.list | cut -d " " -f1
# 這個範例可以讓我們將 last 的輸出存一份到 last.list 檔案中；
[root@www ~]# ls -l /home | tee ~/homefile | more
# 這個範例則是將 ls 的資料存一份到 ~/homefile ，同時螢幕也有輸出訊息！
[root@www ~]# ls -l / | tee -a ~/homefile | more
# 要注意！ tee 後接的檔案會被覆蓋，若加上 -a 這個選項則能將訊息累加。


/***************************************************************************/
// 使用 SSH 連線常用主機
/***************************************************************************/
MS Windows下用putty， Linux 下要如何連線多台主機
使用 ssh 連到 別台主機
要下的指令是
    ssh username@blog.jsdan.com

如果要簡化這行指令，達到這目的就要修改設定檔
    vim /home/.../.ssh/config   (...部分是使用者帳號_

保險一點的話就輸入
    vim ~/.ssh/config
    host ServerName             <=這可以隨便打，識別用
    hostname IP                 <=輸入 IP 或者是 網址
    port 12345                  <=如果有改port就需要這行
    user UserName               <=使用者帳號
連線:
    ssh ServerName      (這邊的 ServerName 就是剛剛輸入的)
之後就會要你輸入密碼


/***************************************************************************/
//  Linux下Configure命令參數解釋說明
/***************************************************************************/
'configure'腳本 
有大量的命令行選項.對不同的套裝軟體來說,這些選項可能會有變化,但是許多基本的選項是不會改變的.
帶上'-- help'選項執行'configure'腳本可以看到可用的所有選項.
儘管許多選項是很少用到的,但是當你為了特殊的需求而configure一個包時,知道他們的存在是很有益處的.
下面對每一個選項進行簡略的介紹:

--cache-file=FILE
'configure'會在你的系統上測試存在的特性(或者bug!).
為了加速隨後進行的配置,測試的結果會存儲在一個cache file裡.
當configure一個每個子樹裡都有'configure'腳本的複雜的源碼樹時,一個很好的cache file的存在會有很大幫助.

--help
輸出幫助資訊.
即使是有經驗的用戶也偶爾需要使用使用'--help'選項,因為一個複雜的項目會包含附加的選項.
例如,GCC包裡的'configure'腳本就包含了允許你控制是否生成和在GCC中使用GNU彙編器的選項.

--no-create
'configure'中的一個主要函數會製作輸出文件.
此選項阻止'configure'生成這個文件.你可以認為這是一種演習(dry run),儘管緩存(cache)仍然被改寫了.

--quiet
--silent
當'configure'進行他的測試時,會輸出簡要的資訊來告訴用戶正在作什麼.
這樣作是因為'configure'可能會比較慢,沒有這種輸出的話用戶將會被扔在一旁疑惑正在發生什麼.
使用這兩個選項中的任何一個都會把你扔到一旁.
(譯註:這兩句話比較有意思,原文是這樣的:
  If there was no such output, the user would be left wondering what is happening. 
  By using this option, you too can be left wondering!)

--version
列印用來產生'configure'腳本的Autoconf的版本號.

--prefix=PREFIX
'--prefix'是最常用的選項.製作出的'Makefile'會查看隨此選項傳遞的參數,當一個包在安裝時可以徹底的重新安置他的結構獨立部分. 
舉一個例子,當安裝一個包,例如說Emacs,下面的命令將會使Emacs Lisp file被安裝到"/opt/gnu/share":
$ ./configure --prefix=/opt/gnu

--exec-prefix=EPREFIX
與'--prefix'選項類似,但是他是用來設置結構倚賴的文件的安裝位置.編譯好的'emacs'二進製文件就是這樣一個文件.
如果沒有設置這個選項的話,默認使用的選項值將被設為和'--prefix'選項值一樣.

--bindir=DIR
指定二進製文件的安裝位置.
這裡的二進製文件定義為可以被用戶直接執行的程式.

--sbindir=DIR
指定超級二進製文件的安裝位置.
這是一些通常只能由超級用戶執行的程式.

--libexecdir=DIR
指定可執行支援文件的安裝位置.
與二進製文件相反,這些文件從來不直接由用戶執行,但是可以被上面提到的二進製文件所執行.

--datadir=DIR
指定通用數據文件的安裝位置.

--sysconfdir=DIR
指定在單個機器上使用的只讀數據的安裝位置.

--sharedstatedir=DIR
指定可以在多個機器上共享的可寫數據的安裝位置.

--localstatedir=DIR
指定只能單機使用的可寫數據的安裝位置.

--libdir=DIR
指定庫文件的安裝位置.

--includedir=DIR
指定C頭文件的安裝位置.其他語言如C++的頭文件也可以使用此選項.

--oldincludedir=DIR
指定為除GCC外編譯器安裝的C頭文件的安裝位置.

--infodir=DIR
指定Info格式文檔的安裝位置.Info是被GNU工程所使用的文檔格式.

--mandir=DIR
指定手冊頁的安裝位置.

--srcdir=DIR
這個選項對安裝沒有作用.
他會告訴'configure'源碼的位置.一般來說不用指定此選項,因為'configure'腳本一般和源
碼文件在同一個目錄下.

--program-prefix=PREFIX
指定將被加到所安裝程式的名字上的前綴.
例如,使用'--program-prefix=g' 來configure一個名為'tar'的程式將會使安裝的程式被命
名為'gtar'.
當和其他的安裝選項一起使用時,這個選項只有當他被 `Makefile.in'文件使用時才會工作.

--program-suffix=SUFFIX
指定將被加到所安裝程式的名字上的後綴.

--program-transform-name=PROGRAM
這裡的PROGRAM是一個sed腳本.
當一個程式被安裝時,他的名字將經過`sed -e PROGRAM'來產生安裝的名字.

--build=BUILD
指定套裝軟體安裝的系統平台.
如果沒有指定,預設值將是'--host'選項的值.

--host=HOST
指定軟體運行的系統平台.
如果沒有指定,將會運行`config.guess'來檢測.

--target=GARGET
指定軟體面向(target to)的系統平台.
這主要在程式語言工具如編譯器和彙編器上下文中起作用.如果沒有指定,默認將使用
'--host'選項的值.

--disable-FEATURE
一些套裝軟體可以選擇這個選項來提供為大型選項的編譯時配置,例如使用Kerberos認證系統或者一個實驗性的編譯器最優配置.
如果默認是提供這些特性,可以使用'--disable-FEATURE '來禁用它,這裡'FEATURE'是特性的名字.例如:
$ ./configure --disable-gui
-enable-FEATURE[=ARG]
相反的,一些套裝軟體可能提供了一些默認被禁止的特性,可以使用'--enable-FEATURE'來起用它.
這裡'FEATURE'是特性的名字.一個特性可能會接受一個可選的參數.例如:
$ ./configure --enable-buffers=128
`--enable-FEATURE=no'與上面提到的'--disable-FEATURE'是同義的.
--with-PACKAGE[=ARG]
在自由軟體社區裡,有使用已有套裝軟體和庫的優秀傳統.當用'configure'來配置一個源碼樹時,可以提供其他已經安裝的套裝軟體的資訊.
例如, 倚賴於Tcl和Tk的BLT器件工具包.要配置BLT,可能需要給'configure'提供一些關於我們把Tcl和Tk裝的何處的資訊:
$ ./configure --with-tcl=/usr/local --with-tk=/usr/local
'--with-PACKAGE=no'與下面將提到的'--without-PACKAGE'是同義的.
--without-PACKAGE
有時候你可能不想讓你的套裝軟體與系統已有的套裝軟體交互.
例如,你可能不想讓你的新編譯器使用GNU ld.通過使用這個選項可以做到這一點:
$ ./configure --without-gnu-ld
--x-includes=DIR
這個選項是'--with-PACKAGE'選項的一個特例.
在Autoconf最初被開發出來時,流行使用'configure'來作為Imake的一個變通方法來製作運行於X的軟體.
'--x- includes'選項提供了向'configure'腳本指明包含X11頭文件的目錄的方法.

--x-libraries=DIR
類似的,'--x-libraries'選項提供了向'configure'腳本指明包含X11庫的目錄的方法.

在源碼樹中運行'configure'是不必要的同時也是不好的.
一個由 'configure'產生的良好的'Makefile'可以構築源碼屬於另一棵樹的套裝軟體.
在一個獨立於源碼的樹中構築派生的文件的好處是很明顯的:
派生的文件,如目標文件,會凌亂的散佈於源碼樹.這也使在另一個不同的系統或用不同的配置選項構築同樣的目標文件非常困難.
建議使用三棵樹:一棵源碼樹 (source tree),一棵構築樹(build tree),一棵安裝樹(install tree).
這裡有一個很接近的例子,是使用這種方法來構築GNU malloc包:
$ gtar zxf mmalloc-1.0.tar.gz
$ mkdir build && cd build
$ ../mmalloc-1.0/configure

creating cache ./config.cache
checking for gcc... gcc
checking whether the C compiler (gcc ) works... yes
checking whether the C compiler (gcc ) is a cross-compiler... no
checking whether we are using GNU C... yes
checking whether gcc accepts -g... yes
checking for a BSD compatible install... /usr/bin/install -c
checking host system type... i586-pc-linux-gnu
checking build system type... i586-pc-linux-gnu
checking for ar... ar
checking for ranlib... ranlib
checking how to run the C preprocessor... gcc -E
checking for unistd.h... yes
checking for getpagesize... yes
checking for working mmap... yes
checking for limits.h... yes
checking for stddef.h... yes
updating cache ../config.cache
creating ./config.status

這樣這棵構築樹就被配置了,下面可以繼續構築和安裝這個包到默認的位置'/usr/local':
$ make all && make install


/***************************************************************************/
// Linux Make source .configure --prefix 命令
/***************************************************************************/
原始碼的安裝一般由3個步驟組成：
會給出文檔，這裡主要討論配置（configure）。 

Configure是一個可執行腳本，它有很多選項，使用命令./configure –help輸出詳細的選項
列表，如下：
# ./configure --help
Usage: configure [options] [host]
Options: [defaults in brackets after descriptions]
Configuration:
--cache-file=FILE     cache test results in FILE
--help             print this message
--no-create         do not create output files
--quiet, --silent     do not print `checking...' messages
--version           print the version of autoconf that created configure
Directory and file names:
--prefix=PREFIX       install architecture-independent files in PREFIX
                [/usr/local]
--exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
                [same as prefix]
--bindir=DIR         user executables in DIR [EPREFIX/bin]
……….(省略若干)

很多的選項，個人認為，你可以忽略其他的一切，但請把—prefix加上。這裡以安裝supersparrow-0.0.0為例，
我們打算把它安裝到目錄 /usr/local/supersparrow ,於是在supersparrow-0.0.0目錄執行帶選項的腳本
./configure --prefix=/usr/local /supersparrow,執行成功後再編譯、安裝（make，make install）；
安裝完成將自動生成目錄supersparrow,而且該軟體所有的文件都被複製到這個目錄。為什麼要指定這個安裝目錄？
是為了以後的維護方便，如果沒有用這個選項，安裝過程結束後，該軟體所需的軟體被複製到不同的系統目錄下，
很難弄清楚到底複製了那些文件、都複製到哪裡去了—基本上是一塌糊塗。

用了—prefix選項的另一個好處是卸載軟體或移植軟體。當某個安裝的軟體不再需要時，只須簡單的刪除該安裝目錄，
就可以把軟體卸載得乾乾淨淨；移植軟體只需拷貝整個目錄到另外一個機器即可（相同的作業系統）。

一個小選項有這麼方便的作用，建議在實際工作中多多使用
---不指定prefix，可執行文件默認放在/usr /local/bin，庫文件默認放
在/usr/local/lib，配置文件默認放在/usr/local/etc。其它的資源文件
放在/usr /local/share。要卸載這個程式，要麼在原來的make目錄下用一
次make uninstall（前提是make文件指定過uninstall）,要麼去上述目錄
裡面把相關的文件一個個手工刪掉。
指定prefix，直接刪掉一個文件夾就夠了。


/***************************************************************************/
// configure
/***************************************************************************/
configure幾個相關的環境變數：PATH、LDFLAGS、CFLAGS
PATH：安裝一個包後可能會在安裝目錄建立一個bin目錄，裡面都是些可執行程式，為了讓系統能找到這些程式，就需要我們把該路徑加入到PATH環境變數中。
LDFLAGS：gcc等編譯器會用到的一些優化參數，也可以在裡面指定庫文件的位置。
        用法：LDFLAGS="-L/usr/lib -L/path/to/your/lib"。每安裝一個包都幾乎一定的會在安裝目錄裡建立一個lib目錄。
        如果你明明安裝了某個包，而安裝另一個包時，它愣是說找不到，那就把那個包的lib路徑加入的LDFALGS中試一下吧。
CFLAGS：和LDFLAGS類似，只不過要向裡加如的是頭文件（.h文件）的路徑，如：CFLAGS="-I/usr/include -I/path/to/your/include"。
        同樣地，安裝一個包時會在安裝路徑下建立一個include目錄，當安裝過程中出現問題時，試著把以前安裝的包的include目錄加入到該變數中來。
        CFLAGS 表示用於 C 編譯器的選項，CXXFLAGS 表示用於 C++ 編譯器的選項。這兩個變數實際上涵蓋了編譯和彙編兩個步驟。

那如何在那些變數中加入這些路徑呢？以PATH變數為例。
一種方法是：直接在命令行下：
&export PATH=/wantaddpath/path/to//bin:$PATH
這種方法的好處是方便，立即生效，缺點是把當前會話或shell關了之後就失效了，下次還得運行一遍。

另一種方法是：把下面的兩行內容加入到~/.bashrc文件中，如果想讓其影響到整個系統而不僅僅是當前用戶，
就把下面的內容加入到/etc/bash.bashrc（記得有的系統是/etc/bashrc這個文件）
PATH="$PATH:/path/to/your/bin:/another/path/to/bin"
export PATH
然後，重新啟動shell即可。
需要注意的是，PATH變數的分隔符號是：號，其他的是空格，所以LDFLAGS應該是這樣：
LDFLAGS="$LDFLAGS -L/path/to/lib -L/path/to/lib"
大多數程式和庫在編譯時默認的優化級別是"2"(使用"-O2"選項)並且帶有調試符號來編譯，也就是 CFLAGS="-O2 -g", CXXFLAGS=$CFLAGS 。
事實上，"-O2"已經啟用絕大多數安全的優化選項了。


/***************************************************************************/
// 安裝 minicom in Ubuntu
/***************************************************************************/
Ubuntu 安裝超級終端機軟體
1. install minicom (hyper terminal)
#sudo apt-get install minicom
2. start & setting 
minicom
#minicom -s
 

/***************************************************************************/
// Linux : 網路設定-ifconfig
/***************************************************************************/
ifconfig 指令是Linux網路組態設定的主要系統管理命令。以下我們說明如何手動設定這些網路組態： 
    IP 
    gateway 
    netmask 
    DNS 
    broadcast 

設定 IP 
例如，要將系統的 IP 設定為 59.120.22.215，則執行以下命令： 
linux# ifconfig eth0 59.120.22.215 
同時請將 loopback device 也加上去： 
linux# ifconfig lo 127.0.0.1 

直接執行 'ifconfig' 不加任何參數的話，可以看到目前的網路組態設定： 
linux# ifconfig
eth0 Link encap:Ethernet HWaddr 00:13:D4:C4:0D:ED
inet addr:59.120.22.215 Bcast:59.120.22.255 Mask:255.255.255.0
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
RX packets:1768542 errors:0 dropped:0 overruns:0 frame:0
TX packets:2411565 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:100
RX bytes:216276166 (206.2 Mb) TX bytes:2221236364 (2118.3 Mb)

lo Link encap:Local Loopback
inet addr:127.0.0.1 Mask:255.0.0.0
UP LOOPBACK RUNNING MTU:16436 Metric:1
RX packets:453762 errors:0 dropped:0 overruns:0 frame:0
TX packets:453762 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:959840798 (915.3 Mb) TX bytes:959840798 (915.3 Mb)

lo 是所謂的 loopback 界面，
eth0 就是我們剛剛設定好的乙太網路界面，有了這層界面後，才能連上 Internet。這個動作必須在成功載入網路卡的驅動程式後才能執行。 
別忘了，我們還沒替 eth0 界面設定好 gateway 與broadcast。gateway 是閘訊通，正確設定閘訊通才能連接外面的網路，否則只能連接區域網路內的主機。
broadcast 是廣播位址，有了這個位址才能廣播封包到區域網路內的所有主機，例如要設定 gateway 與 broadcast 分別為 59.120.22.254 與 59.120.22.255。 

設定 broadcast 
執行： 
linux# ifconfig eth0 broadcast 59.120.22.255 
再執行 ifconfig 就可以發現 eth0 的 broadcast 位址已經被改變了。 

設定 Netmask 
例如，要將 eth0 的 netmask 設定成 255.255.255.0，則執行： 
linxu# ifconfig eth0 netmask 255.255.255.0 

設定 Gateway 
修改 Gateway 設定： 
linux# route del default 
linux# route add default gw 59.120.22.254 
我們先刪除 default 再加入新的 gateway 位址，不過這個刪除的動作也可以省略不做。 
此時我們已經加入了一個預設的 gateway，直接執行 'route' 不加任何參數，便能看到目前的 gateway 設定： 
linux# route
Kernel IP routing table   Destination Gateway Genmask Flags Metric Ref Use Iface
59.120.22.0 * 255.255.255.0 U 0 0 0 eth0
169.254.0.0 * 255.255.0.0 U 0 0 0 eth0
127.0.0.0 * 255.0.0.0 U 0 0 0 lo
default 59-120-22-254.H 0.0.0.0 UG 0 0 0 eth0

設定 DNS 
DNS 負責 Domain Name與 IP 位址之間的轉換，例如我們打 embedded.jollen.org，經由查詢 DNS，
得知其 IP 位址為 59.120.22.215，有了 IP 位址才得以和遠端的主機連線，因此正確設定一台可用的 DNS是很重要的。 
設定 DNS 的方法很簡單，只要編輯 /etc/resolv.conf 即可，以下是一個範例： 
search jollen.org 
nameserver 163.14.192.1 #第一個 nameserver 意同 primary DNS
nameserver 168.14.1.1 #第二個 nameserver 意同 secondary DNS

第一行是設定網域名稱搜尋，第二、三行則是設定 DNS server。
search 通常用在區域網路，例如我們的主機位於 jollen.org 的網域，則設定 search jollen.org 的話，只要打主機名稱： 
linux# telnet www 
效果跟 
linux# telnet www.jollen.org 
是相同的。如果設定多個 domain 的話，則依序搜尋到一個合法的位址為止，例如： 
search jollen.org xxx.com 
若 telnet www 的話，會先找 www.jollen.org，如果失敗會接著找 www.xxx.com。 
nameserver 是設定 DNS，這裡的 DNS 必須是 IP 位址，系統會依序向這些名稱伺服器做查詢，向第一個 DNS 做查詢若失敗，則往下向第二個 DNS做查詢，依此類推。 
/etc/hosts 
我們可以把常用的 domain name 編輯到 /etc/hosts 裡，然後設定好 host.conf，
如此一來當我們使用這些常用的 domain name 時就可以不必再經由 DNS 的查詢程式，進而提升速度，
例如以 www.jollen.org 為例，只要在 /etc/hosts 加上： 
59.120.22.215 www.jollen.org jollen 
這樣一來執行 "telnet jollen" 就等於是 "telnet 59.120.22.215"。 
/etc/hosts.conf 
設定好 /etc/hosts 後還要檢查一下 /etc/hosts.conf 的設定，確定名稱查詢時會先查詢 /etc/hosts，
請檢查 /etc/hosts.conf 是否有一行： 
order hosts,bind 
表示先查詢 /etc/hosts，失敗的話再向 DNS 主機查詢。


/***************************************************************************/
// 怎樣進入 /proc-filesystem
/***************************************************************************/
怎樣進入 /proc-filesystem
使用 "cat"和 "echo"
使用 "cat"和 "echo" 是進入 /proc-filesystem的最簡單方法. 但必需具備下面幾個條件:
    在核心中打開 /proc-filesystem 支援, 在編譯的時候可以通過 CONFIG_PROC_FS=y 做到.
    /proc-filesystem 已經掛進系統,可以用以下的方法測試:
        # mount | grep "type proc"
        none on /proc type proc (rw)
    您必需知道對/proc-filesystem 的各種操作.

通常/proc/sys/* 都是可寫的, 其它的都是只讀或只提供相關資訊.
得到一個值
    可以使用 "cat" 得到一個值.
    # cat /proc/sys/net/ipv6/conf/all/forwarding
    0
設定一個值
    可以使用 "echo" 設定一個值.
    # echo "1" >/proc/sys/net/ipv6/conf/all/forwarding

使用 "sysctl"
使用 "sysctl" 設定核心是當前流行的方法, 您也能用. 
如果/proc-filesystem 沒有掛進來, 那麼您只可以訪問/proc/sys/*

"sysctl"程式在"procps"安裝包中.(Red Hat Linux systems)
sysctl-interface 需要在核心中進行激活, 在編譯的時候可以通過以下選項完成:
    CONFIG_SYSCTL=y
設定一個值
    A new value can be set (if entry is writable):
    # sysctl -w net.ipv6.conf.all.forwarding=1
    net.ipv6.conf.all.forwarding = 1
    在 "=" 兩邊不能出現spaces符號,也不能像下面那樣一次設定多個值:
    # sysctl -w net.ipv4.ip_local_port_range="32768 61000"
    net.ipv4.ip_local_port_range = 32768 61000

    另外
    sysctl使用 "/" 代替 "." 詳細資訊請看sysctl的manpage
    提示:快速查找設定的資訊,可以聯合使用帶"-a"的grep.

/proc-filesystems 裡的數值類型.
    BOOLEAN: simple a "0" (false) or a "1" (true)
    INTEGER: an integer value, can be unsigned, too
    more sophisticated lines with several values: sometimes a header line is 
    displayed also, if not, have a look into the kernel source to retrieve 
    information about the meaning of each value...


/***************************************************************************/
// WPA Supplicant       ref: http://www.gentoo.org/doc/zh_tw/handbook/handbook-x86.xml?part=4&chap=4
/***************************************************************************/
WPA Supplicant 是讓你連接到使用 WPA 的 AP 的套件。因為還在測試中，他的設定過程常常改變 - 但是大部份情況都可以正常工作。
原始碼 2.1: 安裝 wpa_supplicant
# emerge net-wireless/wpa_supplicant
重要: 核心中要啟動 CONFIG_PACKET 才能讓 wpa_supplicant 工作。
source: http://hostap.epitest.fi/wpa_supplicant/

現在要設定 /etc/conf.d/net 優先使用 wpa_supplicant 而不是 wireless-tools (兩個都安裝的話，預設會用 wireless-tools)。
原始碼 2.2: /etc/conf.d/net 設定 wpa_supplicant

# 使用 wpa_supplicant 而不是 wireless-tools
modules=( "wpa_supplicant" )

# 因為他的偵測不是很好，所以要告訴 wpa_supplicant
# 要使用哪個驅動程式
wpa_supplicant_eth0="-Dmadwifi"

注意: 如果你用 host-ap 驅動程式，你需要讓網路卡進入管理模式，讓 wpa_supplicant 可以正確使用。
在 /etc/conf.d/net 中加上 iwconfig_eth0="mode managed" 來啟動。
很簡單不是嗎？然而，根據你要連線 AP 的安全程度，還有一些 wpa_supplicant 的設定要調整。
底下的例子是從 wpa_supplicant 提供的 /etc/wpa_supplicant.conf.example 簡化而來的。

原始碼 2.3: /etc/wpa_supplicant.conf 設定
# 不有改變這行，否則他不能工作
ctrl_interface=/var/run/wpa_supplicant

# 確保只有 root 可以讀取 WPA 設定
ctrl_interface_group=0

# 讓 wpa_supplicant 搜尋及選擇 AP
ap_scan=1

# 簡單的例子：WPA-PSK, PSK 使用 ASCII 密碼，只要密碼正確就允許
network={
  ssid="simple"
  psk="very secret passphrase"
  # 越高的優先權越快被使用
  priority=5
}

# 和前一個一樣，但是指定 SSID (適用不廣播 SSID 的 AP)
network={
  ssid="second ssid"
  scan_ssid=1
  psk="very secret passphrase"
  priority=2
}

# 只用 WPA-PSK。任何有效的密碼組合都允許
network={
  ssid="example"
  proto=WPA
  key_mgmt=WPA-PSK
  pairwise=CCMP TKIP
  group=CCMP TKIP WEP104 WEP40
  psk=06b4be19da289f475aa46a33cb793029d4ab3db7a23ee92382eb0106c72ac7bb
  priority=2
}

# 明文連線 (不用 WPA，IEEE 802.1X)
network={
  ssid="plaintext-test"
  key_mgmt=NONE
}

# Shared WEP key 連接 (不用 WPA，IEEE 802.1X)
network={
  ssid="static-wep-test"
  key_mgmt=NONE
  wep_key0="abcde"
  wep_key1=0102030405
  wep_key2="1234567890123"
  wep_tx_keyidx=0
  priority=5
}

# Shared WEP key 連接 (不用 WPA，IEEE 802.1X) 使用
# IEEE 802.11 Shared key 認證
network={
  ssid="static-wep-test2"
  key_mgmt=NONE
  wep_key0="abcde"
  wep_key1=0102030405
  wep_key2="1234567890123"
  wep_tx_keyidx=0
  priority=5
  auth_alg=SHARED
}

# IBSS/ad-hoc 網路加上 WPA-None/TKIP
network={
  ssid="test adhoc"
  mode=1
  proto=WPA
  key_mgmt=WPA-NONE
  pairwise=NONE
  group=TKIP
  psk="secret passphrase"
}


/***************************************************************************/
kernel的開機執行順序
/***************************************************************************/
Linux是一個目前非常普遍的作業系統，因為它為免費且公開原始碼的作業系統，所以在嵌入系統中大家都很喜歡使用它，而且它的執行可以很小，且又有效率。
我們現在就來大概地瞭解一下它的開機順序。
首先我們要瞭解的是，Linux kernel可以被編譯成兩種形式，一種是有壓縮的，另一種是沒有壓縮的，兩種形式其第一個執行指令不同，
我們先來瞭解有壓縮的，它是將另一種沒有壓縮的kernel將其做壓縮，並在其前面加一段解壓縮的程式碼，而這段程式碼則是可以執行在記憶中任何位置，
並且會將kernel作解壓縮之後放在記憶上，之後將其控制權交給kernel，之後的執行順序，有壓縮和沒壓縮的順序是一樣的。
那麼我們先來看看有壓縮的第一個指令在那裹，以ARM CPU來說，它是在arch/arm/boot/compressed/head.S的程式裹，這一段是使用組合語言寫的，
其中有兩個重要的暫存器，一個是r1存放的是CPU的代碼，這個代碼是由使用自行定義，由bootloader傳過來，這個值定義在arch/arm/tools/mach-types中，
在編譯時會產生一個include/asm/mach-types.h，這時會使用CP15來讀回CPU的ID做比對，確認是否正確，並且使用相對應的cache操作副程式，
因此在正確的CPU ID比對之後會啟動cache，以加快對kernel的解壓縮動作。
在解壓縮kernel之前，解壓縮程式會先檢查現在的位置是否和解壓縮之後的位址是否有衝突，若沒有則直接開始解壓縮，若有將會解壓縮至其它地方，
之後再搬至最後kernel所要擺放的位置，並且跳至kernel的第一個指令，開始執行，而kernel的第一個指令放在arch/arm/kernel/head.S，
開始執行時kernel會比對CPU ID是否正確，再初始化系統的cache HAL call back function，以及各種初始化動作，這些定在MACHINE_START的巨集宣告中，
而這是使用者所宣告的，這時也會初始化整記憶體管理，最後會呼叫kernel_start，這是在init/main.c之中，接下來會載入各個driver，
以及會mount root file system，當一切都好了之後則會呼叫第一支應用程式，default為/sbin/init，你可以在make menuconfig中將其更換你所要執行的程式，
而這支程式可以是binary file也可以是shell script，到此就結束所有的開機動作。


/***************************************************************************/
// 如何啟動USB sound  (Emmebedded System)       
/***************************************************************************/
ref: http://victoryuembeddedlinux.blogspot.com/2011/01/usb-sound.html

簡介
USB喇叭是一個標準的USB class，它是一個USB接頭直接接到一對喇叭，而在喇叭中
直接有音訊解碼器及擴大機，可以讓你播放各音樂檔檔式，如mp3 or wav格式，在
kernel中有其標準的驅動程式可供使用，在此說明如何在kernel source code做設
定，以及要如何安裝才可以使用。

Kernel驅動程式的選項
在原始中已有現成的驅動程式，我們只要設定使用它就可以了，要設定原始碼，當然
是執行' make menuconfig' 其選項如下 :
首先要進入『Device Driver'的選項如下：
Device Driver ---> 
  [*]USB support --->
      [*] Support for Host-side USB
      [*]     EHCI HCD (USB2.0) support
      [*]     OHCI HCD support

  [*] Sound card support --->
      [*] Advanced Linux Sound Architecture --->
      [*]   Sequencer support
      [*]     Sequencer dummy client
      [*]   OSS Mixer API
      [*]   OSS PCM (digital audio) API
      [*]     OSS PCM (digital audio) API - Include plugin system
      [*]   OSS Sequencer API
      .
      .
      [*]   Generic sound device
      [ ]     Dummy (/dev/null) soundcard
      [*]     Virtual MIDI soundcard
      [*]     MOTU MidiTimePiece AV multiport MIDI
      [*]     UART16550 serial MIDI driver
      [*]     Generic MPU-401 UART driver
      .
      .
      [*]   USB sound device --->
            [*] USB Audio/MIDI driver
            [*] Native Instruments USB audio device
            [*]   enable input device for controllers

以上完成kernel的選項設定，重新編繹kernel即可.

需要建立的Device Node
有幾個device node必需建立給應用程式使用如下：
> mknod dsp c 14 3
> mknod audio c 14 4
> mknod mixer c 14 0
需要載入的驅動程式
> modprobe snd_usb_audio
> modprobe snd_pcm_oss

若載入正常可以看到以下的驅動程式被載入：
> lsmod
snd_pcm_oss 33872 0 - Live 0xbf19f000
snd_mixer_oss 11280 1 snd_pcm_oss, Live 0xbf19b000
snd_usb_audio 50992 0 - Live 0xbf18d000
snd_timer 13620 1 snd_pcm, Live 0xbf17a000
snd_page_alloc 4472 1 snd_pcm, Live 0xbf177000
snd_usb_lib 10192 1 snd_usb_audio, Live 0xbf173000
snd_rawmidi 13024 1 snd_usb_lib, Live 0xbf16e000
snd_swq_device 3336 1 snd_rawmidi, Live 0xbf16c000
snd_hwdep 3892 1 snd_usb_audio, Live 0xbf16a000
snd 29556 8 snd_pcm_oos,snd_mixer_oxx,snd_usb_audio,snd_pcm,snd_timer,snd_rawmi
soundcore 3044 1 snd, Live 0xbf15f000
ipw 5460 0 - Live 0xbf15c000
usbserial 20320 1 ipw, Live 0xbf156000
......
.....
...
scsi_mod 59644 3 sg,sd_mod,usb_storage, Live 0xbf12b000
uhci_hcd 19724 0 - Live 0xbf125000
ehci_hcd 30556 0 - Live 0xbf11c000
usbcore 87488 8 snd_usb_audio,snd_usb_lib,ipw,usbserial........

若USB Speaker插入有被正常找到，你可以在目錄/proc/asound之下看到檔案
> ls /proc/asound -al
# ls /proc/asound/ -al
dr-xr-xr-x    5 root     root            0 Sep  7 10:42 .
dr-xr-xr-x   41 root     root            0 Jan  1  1970 ..
lrwxrwxrwx    1 root     root            5 Sep  7 10:42 VirMIDI -> card0
dr-xr-xr-x    2 root     root            0 Sep  7 10:42 card0
-r--r--r--    1 root     root            0 Sep  7 10:42 cards
-r--r--r--    1 root     root            0 Sep  7 10:42 devices
-r--r--r--    1 root     root            0 Sep  7 10:42 hwdep
-r--r--r--    1 root     root            0 Sep  7 10:42 modules
dr-xr-xr-x    2 root     root            0 Sep  7 10:42 oss
-r--r--r--    1 root     root            0 Sep  7 10:42 pcm
dr-xr-xr-x    2 root     root            0 Sep  7 10:42 seq
-r--r--r--    1 root     root            0 Sep  7 10:42 timers
-r--r--r--    1 root     root            0 Sep  7 10:42 version
這時你可以執行一下程式測試，若一切正常你可以聽到聲音，大功告成。


/***************************************************************************/
// Some DLNA
/***************************************************************************/
DLNA應該是"只能"在LAN裡面跑,因為他是架在UPnP上面,這是使用multi-cast的packet,大部分的getway都會濾掉。
再來,也不是怪PS3支援的codec少,DLNA裡面,大部分的codec都是option.
簡單解釋DLNA....其實真得很簡單
1.用UPnP的SSDP去做Search device
2.用http去讀XML取得Service/contain list
3.用http去讀contain....秀出來....
以後會有越來越多soho NAS 會支援 DLNA.

 
/***************************************************************************/
// What is Framebuffer ?
/***************************************************************************/
wiki : http://en.wikipedia.org/wiki/Framebuffer
Ref: http://tttt-note.blogspot.com/2008/10/framebuffer.html

A framebuffer is a video output device that drives avideo display from a memory buffer containing a complete frame of data.
Framebuffer 的架構，是利用 mmap 向 kernel 映射出 "顯示記憶體"區塊
(註一、其他memory access的方式 )，讓linux的user可以透過framebuffer device(而不需要透過底層的driver)直接對display memory進行讀寫操作。
The information in the buffer typically consists of color values for every pixel (point that can be displayed) on the screen.
Framebuffer裡主要是顯示資訊。
Color values are commonly stored in 1-bit monochrome, 4-bit palettized, 8-bit palettized, 16-bit highcolor and 24-bit truecolor formats. 
An additional alpha channel is sometimes used to retain information about pixel transparency.
以上是Color values的格式 Orz 不是很懂。

The total amount of the memory required to drive the framebuffer depends on the resolution of the output signal, and on the color depth and palette size.
而所會用到的記憶體大小就看你要顯示的多清楚了！

註一、其他memory access的方式；
Mapping the entire framebuffer to a given memory range. Port commands to set each pixel, range of pixels or palette entry.
Mapping a memory range smaller than the framebuffer memory, then bank switching as necessary.




/***************************************************************************/
// Vim 
/***************************************************************************/
編輯 /etc/vim/vimrc
讓你的vim 看得懂C 語言的特徵!!!
syntax on

每次開啟檔案都會自動跳到上一次停留的地方(這太重要了~讓你工作馬上回神)
if has("autocmd")
  au BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$")
    \| exe "normal! g'\"" | endif
endif

讓找的字便亮一點啊
set hlsearch

自訂熱鍵
(F8 high line 用，F9 開function 用)
map <F8> :set hls!<BAR>set hls?<CR>
map <f9> :Tlist<CR>

打開滑鼠支援(我還沒適應用滑鼠 囧>)
set mouse=a

a: 全部模式都可以用滑鼠
v: Visual mode
n: Normal mode
i: insert mode

其他模式就不列了。
不用a的話可以用
set mouse=vn
把各種模式串起來


/***************************************************************************/
// 標準輸入 輸出 標準錯誤輸出     command > get.log 2>&1
/***************************************************************************/
command > get.log 2>&1
這行是說 錯誤的訊息丟到 "1" 再丟到 get.log

WHY?
0：標準輸入    Keyboard Input    Read
1：標準輸出    terminal    Write
2：標準錯誤輸出    terminal(錯誤訊息是寫到此)    Write

正常訊息是丟到 "1"
錯誤訊息是丟到 "2"

所以 2>&1
&符號指的是取記憶體位置 "1"

就這樣!!!
command 2>&1 > get.log
那這個呢?
(ans: 標準輸出到 get.log ，錯誤訊息顯示到 terminal )


/***************************************************************************/
// NFS ( Network FileSystem ) ---Client
/***************************************************************************/
簡稱~網路檔案系統
NFS 用法
A電腦當server 分享出來資料夾或是磁碟
B電腦把它 mount 進來!!!

就這樣
B電腦目前是Ubuntu所以跟Debianㄧ樣，先用靠北好用的aptitude
把nfs-common 裝起來
因為我們需要
sudo apt-get install nfs-common

mount.nfs <==新版mount 不吃nfs，不過裝好之後就可以吃
showmount <==很好用
---
showmout -e IP 
把server 提供的分享路徑掃瞄出來，很好用喔

mount.nfs
其實裝好 mount 指令就有這個能力了
所以指令為
mount -t nfs ip:分享路徑 被掛載資料夾
ex: mount -t nfs 192.168.1.1:/bejo/share test/
or
mount.nfs 192.168.1.1:/bejo/share test/


/***************************************************************************/
// NFS ( Network FileSystem ) ---Server
/***************************************************************************/
這次所需套件比較多，不過如果是烏幫兔還是用aptitude 裝ㄧ裝就好了
只要裝 nfs-utils-
如果是手動來....恩就糟糕了點
以下是清單
nfs-utils-1.1.5.tar.bz2
portmap
tcp_wrappers_7.6.tar.gz(因為需要他的libwrap.a)

nfs-utils連結
那三個套件安裝就不記錄了!!!
起動順序
portmap
exportfs -avr
讀取exports
nfsd 8
我要打八個!!!阿是開八條
mountd
上面這些到套件裡面撈吧

相關路徑
/etc/exports
分享資料夾設定

/var/lib/nfs/rmtab
/var/lib/nfs/xtab
權限lock檔案

/var/lib/nfs/v4recovery
用來for V4 檔案系統的回覆資料檢查用

----
exports檔案範例
ex1:
/tmp *(rw,rw,no_subtree_check,no_root_squash)
誰都可以掛載/tmp
ex2:
/tmp
跟上面依樣
ex3:
/tmp 192.168.1.*(rw,no_subtree_check,no_root_squash)
/tmp 192.168.1.100(rw,no_subtree_check,no_root_squash)
IP限定
這樣就夠用啦XD
使用方法網路很多!!!
PS. 切記server 系統時間要正確


/***************************************************************************/
// NFS ( Network FileSystem ) ---Server
/***************************************************************************/
1.安裝NFS server:
   $sudo apt-get install nfs-kernel-server
2.設定NFS:
  $gksudo gedit /etc/exports
  add the following line for /etc/exports:
/home/<useracct>/workdir/filesys *(rw,no_root_squash,no_all_squash,sync)
3.掛卸載NFS目錄資源:
  a)重新掛載/etc/exports:#sudo /usr/sbin/exportfs -av
  b)通通卸載#sudo /exportfs -auv
4.重啟NFS server:
   sudo /etc/init.d/nfs-kernel-server restart
5.查看防火牆:
   sudo iptables -L
6.關掉防火牆:
   sudo iptables -F
7.查詢網路狀況:#netstat -tulnp
   #rpcinfo -p localhost
   #rpcinfo -t localhost nfs 
參考資料：
a)google "nfs linux"


/***************************************************************************/
// How to entry in Embedded Linux System.
/***************************************************************************/
本文引用自 "http://jslinux.pixnet.net/blog/post/13068453"
有許多人大概跟我一樣 , 剛開始玩ARM Base 的Embedded Linux , 在一開始一定面臨到 , 不知從何下手的困擾. 
看著許多坊間許多套件商開發出的開法板 , 照著書籍 , 及裏面提供的應用程式做了一遍後 , 卻仍不知道自己玩這一個領域 , 該從那裏為學習的啟始點.  
我分享一下我個人的學習規劃方向 , 當然啦 , 這不代表我已經練成了金剛護體的九陽神功. 
畢竟我沒有張無忌的資質. 但至少這不可失為是一個練功的階段進程 , 足以讓我step by step 的前進.....
1.熟悉ARM組語指令及ADS/Rearview 等IDE工具 : 
  套件板上應該會提供一些簡單的source code , 這可以讓你試著在類似ADS等IDE工具 , 一步步的Trace系統的運作過程. 
  其中在bootstarp code(類似 init.s)的部份 , 運用大量的組合語言與助譯碼 , 我想使用這不一定要熟記 , 但至少不能太陌生 , 
  至少當要modify code時 , 能夠在書籍上 , 找到相關的訊息.
2.試著修改source code & building to execution : 
  學習Embedded Linux 領域 , 別告訴我是想做學術研究. 究底應該是修改程式 , 以符合硬體介面上的驅動使用. 
  終極目標 , 當然是希望藉由產品在市場大賣 , 賺取利潤. 所以動手改code , 然後compiler & link , 最後download elf file到target board來驗證. 
  這可以試著去修改板子所附的一些硬體周邊來來實習，如點亮LED等。 
  上述的步驟, 主要還是讓你學會如何透過ARM提供的IDE介面 , 來熟悉ARM Base MCU的指令 , 以及大致一個Embedded System 的架構. 
  但還算不上是個Embedded Linux的開發計劃.   
  Linux之所以為業界稱道, 除了是個free 的 open source外 , 其內部的網路支援性 , 以及透過廣大的網路傳播 , 相當人數的使用與修改.
  所以累積了一定程度的系統穩定性. 而透過許多玩家或是Third Party , 刪除了部份核心龐大的部份 , 衍生出像是 uClinux , ArmLinux 等
  被使用在不同的MCU架構上的系統. 得以讓引用該MCU的產品 , 能夠擁有Linux的穩定系統 , 以及便捷的網路的傳輸服務. 
  這也是我們學習Embedded Liunx System , 最大魅力的所在. 
  但很抱歉的是 , 在移植到類似的MCU過程中 , 多數的先進是使用Tool chain 來進行Build 系統 , 
  所以當你從網路上獲取相關於Embedded Linux的資源時 , 大概很難將其source code 轉成為ADS/REARVIEW 所能handle 的project. 
  也因此 , 接下來必須試著去熟悉Tool chain的建立. 至少 , 必須能找到一套符合你系統的tool chain.
3.學會架Embedded Linux Enviroment : 
  包括x86系統上 , 建立一個Linux os的系統, 從網路上找詢相關的tool chain , 像是gcc , glibc , binutils等 , 並且在compiler後 , 
  能夠將bin或是execution file programming or download到target board 的flash 或是RAM 去執行.
4.試著撰寫Device driver:
  一套完整的Embedded Linux , 應該可以分為Bootload , Kernel , Device driver , Application幾個部份. 
  除了Kernal外 , 因為GPL的規範 , 在修改後 , 必須release出來 , share with everybody. 
  所以 , 大部份的業界, 大概都不大會去更動這一部份. 但其它像是bootloader及Device driver , 都將因為開發出的硬體架構不同 , 
  而必須做出程度上的修改. 而其中又以Device driver所面臨的狀況更多. 
  所以 , 試著學著去撰寫一份屬於該硬體的Device driver , 例如是讓speaker 發聲或是LED 驅動的driver , 這會讓學習過程變的有趣 . 
  另外 , 如果學的精 , 保證在業界是相當的吃香.
5.Application Design: 
  即使是很單純的單機產品 , 像是汽車電子或是IP Phone等 , 在建置了系統的bootloader , Device driver後 , 仍須透過一些application 的coding  , 
  透過device driver 來操做硬體的反應. 所以試著去玩一些Application design , 這除了能夠寫一些人機界面的應用程式外 , 再開發Linux driver時, 
  也可以拿來做debug. 相當的受用.
6.Go GUI Design : 
  這一個部份不一定是必須的. 但在許多PDA或是iPhone , 以及導航產品等產品 , 在業界引領風潮後 , 透過一個LCD來實現一個Graphic User Interface的操作模式 , 
  看來是勢在必行的. 這個部份的學習 , 該算是獨立於Embedded Linux的部份 , 畢竟即使你使用WIN CE Mobile 5.0 , 你仍必須看懂如何操作LCD 顯示的 Spec. 
  只不過 , 在市場上現有的套件板中, 多提供了LCD驅動的solution , 再加上Linux業界的嵌入需求. 
  透過這樣的界面 , 並且熟練於上述的 4 , 5兩項 , 我想在業界混口飯吃 , 應該也不是難事. 
  另外在GUI 的設計中, 又分有像是Qt/miniGui等 , 每一行都算是們學問唷.
7.Porting x86 Linux到Embedded Linux或是Study Linux Kernel : 
  能走到這一步驟 , 或許他不一定是高手 , 但至少他要面對的挑戰 , 絕對不輕鬆. 
  要porting x86 linux的一些套件或是系統到Embedded Linux , 所要面對的就是對Kernel有一定的程度的熟悉 , 
  因為在過程中 , 必須瞭解硬體的特性 , 試著去修改符合該硬體的Kernel , 這必須在整個Linux架構的編排上 , 
  像是Stack規劃 , thread 的研究 , 就像是當玩家從Linux 2.4移值到Linux 2.6時, 必須面對系統相當大幅度的修正. 
  絕非只是改幾行程式 , 就可以完成的 , 這還牽涉到系統的穩定性及效率. 
上面的七項 , 除了第1到第3 , 需要循序步驟的去實作與熟悉 , 剩下的幾項 , 可能會依不同的環境需求 , 而有著不同順序的編排. 
而就算是熟練前面六項, 也只能算是精於Embedded Linux的操作與使用 , 真正的挑戰還是在於 , 面對不同的硬體需求 , 
像是bluetooth , smartphone等產品 , 都必須先對spec.有一定程度的瞭解 , 才能下手. 
這相對於許多業界販賣許多能應用在WIN CE MOBILE的套件 , 能用在Linux上的 , 相對的就少之又少. 這也就是許多公司 , 
想聘用Embedded Linux engineer 來porting 相關的Device driver或是AP 在其產品上的意義. 
至少公司可以在產品售出前 , 不必先付出一定費用 , 購買WIN CE Mobile , 或是相關套件的費用. 
當然啦 , 也有許多大公司 , 是WIN CE及Linux兩系統並進. 畢竟 , 產品能早一點上市獲利 , 對公司來說也是另一考量.
許多大學生畢業 , 找不到工作 , 我覺得問題是在於 , 許多學校的訓練不足 , 加上學生在技能上及工作態度不佳 , 造成公司寧可聘用有經驗的員工. 
Embedded System  , 學生們可以好好的耕耘 , 至少熟練前面的1~4項 , 找份工作絕對不會是件難事的唷.
[補註]
我想補充的是 , 許多剛入門的玩家 , 很容易一開始就迷失在Linux的瀚海中 , 常以為買一塊開發板 , 然後透過套件裏提供的一些程式 , 可以燒錄Image , 
玩玩LED燈 , 就算是進入Embeded Linux的世界中. 這絕對是一個錯誤的觀念 , 也可能是書局太多這類以開發板為介紹環境的書籍 , 所誤導的結果.
進入Embedded Linux的第一個關鍵 , 一定是先瞭解Linux的初步架構 , 又因為不同的HW別 , 可以uClinux , ARMLinux  ,或是執行在i386上的Linux , 
另外又因為支援的程度與否 , 像是2.6版本能夠support MMU , 更穩定的USB2.0等, 就成為初學者要思考的第一步.
一般會比較建議使用ARM Base的開發板  , 並不表示這是Linux運作的最佳平台 , 而是因為ARM Base的Controller , 被廣泛的運用 , 
所以市面上有許多引以為設計的產品 , 再家上高手們都在上面有po上不同版本的LINUX image ,所以要取得資源會容易很多. 
但其實, 只要手邊能拿到一個硬體 , 裏頭有足夠的記憶體空間 , 合適的MCU ,能夠燒入 , 及簡易的除錯方法 , 當然 , 要能夠很容易的燒入Image , 
其實這都會是一個很隨性入門Embedded Linux的環境的.
另外 , 不管你一開始入門的是i386 ,或是直接玩在ARM BASE MCU或著是Power PC  , 你都需要一台能Working gcc tool chain的電腦 , 
有些人會單獨的拿一台電腦灌成Linux OS , 也有人使用VM-WARE來模擬 , 這都可以 , 
只要你能在PC上 , 將你修改的程式 , Modified - Build - 然後download當target board上執行  , 你就能驗證自己修改的code 對硬體表現出什麼樣的反應.....
當然啦, 開始的第一步, 多是呈現死當 , 但只要別灰心 ,多摸幾次 , 多上網找相關高手的經驗 ,多能漸入佳境的.
多數坊間的Embedded Linux開發系統 , 多是po在ARM的開發板上 , 但這不代表想玩Embedded Linux就一定得在ARM上才能跑.
ARM的確是Embedded Linux的好入門點 , 不過會建議在進場前 ,大致瞭解一下Linux的系統架構 ,以及工具的使用. 
要不 , 你可能還來不及碰到系統核心 , 就會被一些Bulid程式 ,搞的打退堂鼓囉....
boot code的部分要如何trace呢(init.s)?需要使用到realview來trace嗎?沒有硬體的版子可否用simulator來模擬呢??
我想你必須先瞭解到,init.s是每一個不同架構cpu的啟始點. 所以在沒有硬體的前提下 ,你就無法決定 , 你的init.s倒底該怎麼修正,好符合該硬體架構的設定.
至於你提到用RearView來trace code ,我假設你用的是windows版本 ,那相對的你就無法將gnu 的assembler code拿來compiler(Rearview 可以看懂gcc , 但是看不懂as)
不過 , 如果你不是要寫embedded linux的話 ,但就操做一個arm base的CPU , 倒不為是一個study指令的起始點.


/***************************************************************************/
// UHCI,OHCI,EHCI差異  from: http://stenlyho.blogspot.com/2008/08/uhciohciehci.html
/***************************************************************************/
USB(Universal Serial Bus)通用串列匯流排：
USB1.1規格支援兩種速率：低速(low speed)1.5Mbps和全速(full speed)12Mbps.
新的USB2.0規格除了支援原有的兩種速度外，還而外支援高速(high speed)480Mbps。
USB host controller(USB主控器)必定是下列3種規格：
    UHCI : Intel公司提倡，UHCI線路比OHCI線路簡單多了，但是需要比較複雜的驅動程式，對CPU負擔也微重了些，
           UHCI採用I/O-mapped I/O方式(CPU使用I/O指令來存取USB controller)，採用的廠商有Intel，VIA。
           在UHCI 中一個SOF 會出現一個Setup Token。
    OHCI：Compaq(康柏)公司主導，採用Memory-mapped I/O(CPU使用記憶體指令來存取USB controller)，採用的廠商有Compaq，iMace，OPTi，SiS，Ali。
          在OHCI 中一個SOF 會可能出現三個Setup token。
    EHCI：USB規格，相容於UHCI，OHCI，只有USB2.0(EHCI)才提供高速480Mbps傳輸效率。

資料來源：
http://ynie.myweb.hinet.net/Linux/1.101.7.html
http://chamberplus.myweb.hinet.net/mp3_4.htm

 
/***************************************************************************/
// 在嵌入式 Linux 架設 Boa Webserver (from: http://blog.linym.net/archives/180)
/***************************************************************************/
Boa 是一套小型的網頁伺服器，很適合應用在 Embedded System 上，並且內建就可以直接支援以 C 寫的 CGI 網頁，
這篇是移植 Boa 到 ARM9 S3C2410 平台的過程，Linux 版本為 2.6.17.4，使用 arm-linux toolchain 3.4.1 編譯。
1. 產生 Makefile
下載 Source code 並解壓縮進到 src 目錄。
# ./configure --host=arm-linux
2. 修改 Makefile 使用跨平台編譯
CC = arm-linux-gcc
CPP = arm-linux-gcc -E
# make (如果編譯或執行時有錯誤請看Q&A)
# arm-linux-strip boa
3. 配置 Boa
可以在源碼目錄找到這個設定檔，放到 /etc/boa 裡面，有修改的部份如下：
User 0
Group 0
#DirectoryMaker /usr/lib/boa/boa_indexer
CGIPath /bin:/usr/bin:/var/www/cgi-bin
ScriptAlias /cgi-bin/ /var/www/cgi-bin/
然後需要放一個 mime.types 檔案在 /etc，我是直接複製 ubuntu 裡的檔案。
4. 加入 boa 執行檔
將編譯好的 boa 執行檔加入檔案系統 /bin，要啟動 server 只要輸入 boa 即可，可到 /var/log/boa 查看 log。
問題 Q&A：
Q：使用 toolchain 3.4.1 編譯出現錯誤
arm-linux-gcc -g -O2 -pipe -Wall -I. -c -o util.o util.c
util.c:100:1: pasting "t" and "->" does not give a valid preprocessing token
make: *** [util.o] Error 1
A：修改 src/compat.h
找到
#define TIMEZONE_OFFSET(foo) foo##->tm_gmtoff
修改成
#define TIMEZONE_OFFSET(foo) (foo)->tm_gmtoff
Q：執行 boa 出現 "gethostbyname::No such file or directory"
A：需將 boa.conf 裡的 ServerName 開頭註解拿掉
Q：無法啟動 Boa，error log 顯示 "boa.c:266.icky Linux kernel bug!:No such file"
A：修改 src/boa.c，將底下判斷式註解掉：
/*if (setuid(0) != -1) {
DIE("icky Linux kernel bug!");
}*/
重新編譯
Q：無法啟動 Boa，error log 顯示 "boa.c:211 - getpwuid....略"
A：修改 src/boa.c，將底下兩個判斷式註解掉：
/*if (passwdbuf == NULL) {
DIE("getpwuid");
}
if (initgroups(passwdbuf->pw_name, passwdbuf->pw_gid) == -1) {
DIE("initgroups");
}*/
重新編譯


/***************************************************************************/
//[usb system] overview
/***************************************************************************/
USB是Universal Serial Bus，是一個讓電腦跟週邊設備 (包括usb storage，HID, 數位相機等)。
版本區分為1.1，2.0，以及最新的3.0。其頻寬從1.5MB/s, 60MB/s，提升到625MB/s。
新版皆向前相容。另一特色就是hotplug。
架構上是由host controller和hubs組成，其中最上層的稱為root hub，支援到127個devices，包括串接的hub。
host controller是介於os和usb device之間的一層hardware interface。
目前有三種interfaces (register level): OHCI (open, by compaq, 1.1)，UHCI (universal, by intel,1,1)，EHCI (Enhanced, by intel,2.0)。
hardware vendor也提供一層HCD (Host Controller Device) interface讓system software跟device互動
USB 2.0 support
用lspci查詢，可看出目前支援UHCI和EHCI。
usb20support
Kernel message
插入usb device後，看看kernel顯示什麼訊息:
usb 2-3: new high speed USB device using ehci_hcd and address 35  ==>usb 2.0的device，其address是35
usb 2-3: configuration #1 chosen from 1 choice
scsi15 : SCSI emulation for USB Mass Storage devices  ==> SCSI emulation
usb-storage: device found at 35
usb-storage: waiting for device to settle before scanning
scsi 16:0:0:0: Direct-Access              USB FLASH DRIVE  PMAP PQ: 0 ANSI: 0 CCS  ==>device information
sd 16:0:0:0: Attached scsi generic sg2 type 0
usb-storage: device scan complete 
sd 16:0:0:0: [sdb] 15646720 512-byte logical blocks: (8.01 GB/7.46 GiB)
sd 16:0:0:0: [sdb] Write Protect is off
sd 16:0:0:0: [sdb] Mode Sense: 23 00 00 00
sd 16:0:0:0: [sdb] Assuming drive cache: write through
sd 16:0:0:0: [sdb] Assuming drive cache: write through
 sdb: sdb1
sd 16:0:0:0: [sdb] Assuming drive cache: write through
sd 16:0:0:0: [sdb] Attached SCSI removable disk ==>hotplug完成，device node為/dev/sdb1


/***************************************************************************/
// 設定 USB 裝置
/***************************************************************************/
設定 USB 裝置
Step 0 : USB 控制器的分類
通常 USB 的控制器(USB host controller),可分成下列三種
USB 1.1 傳輸速度可分低速 low speed的 1.5Mbps 以及全速 full speed 的 12Mbit/sec(1.5MByte/sec )
I.  OCHI(Open Host Controller Interface)
OHCI 採用 Memory mapped I/O (CPU 使用記憶體指令來存取 USB 控制器),所以每個 USB Hub 都配置一塊記憶體.
USB 裝置屬於 PCI 的介面,所以要查看 USB 的相關資訊就要看 /proc/pci 這個檔案
 
II  UHCI(Universal Host Controller Interface)
UHCI 採用 I/O mapped I/O (CPU 使用 I/O 指令來存取 USB 控制器),所以每個 USB Hub 都佔用一個 I/O port.

[root@benjr ~]# cat /proc/pci
.................略...............................
 Bus  0, device  29, function  0:
    USB Controller: Intel Corp. 82801CA/CAM USB (Hub #1) (rev 2).
      IRQ 16.
      I/O at 0x6c00 [0x6c1f].
  Bus  0, device  29, function  1:
    USB Controller: Intel Corp. 82801CA/CAM USB (Hub #2) (rev 2).
      IRQ 19.
      I/O at 0x6c20 [0x6c3f].
  Bus  0, device  29, function  2:
    USB Controller: Intel Corp. 82801CA/CAM USB (Hub #3) (rev 2).
      IRQ 18.
      I/O at 0x6c40 [0x6c5f].
  Bus  0, device  30, function  0:
.................略...............................
可以看到這台機器使用 INTEL 82801CA(ICH3) 的南僑晶片,而這晶片支援 USB 1.1,並且有 3 個 USB Root Hub.
 
USB 2.0 除支援 USB 1.1 的兩種傳輸速度外,高速 high speed 還可高達 480Mbit/sec(60 MByte/sec)
III. EHCI(Enhanced Host Controller)
[root@benjr ~]# cat /proc/pci
.................略...............................
 Bus  0, device  29, function  0:
    USB Controller: Intel Corp. 82801DB USB (Hub #1) (rev 2).
      IRQ 16.
      I/O at 0x6800 [0x681f].
  Bus  0, device  29, function  1:
    USB Controller: Intel Corp. 82801DB USB (Hub #2) (rev 2).
      IRQ 19.
      I/O at 0x6820 [0x683f].
  Bus  0, device  29, function  2:
    USB Controller: Intel Corp. 82801DB USB (Hub #3) (rev 2).
      IRQ 18.
      I/O at 0x6840 [0x685f].
  Bus  0, device  29, function  7:
    USB Controller: Intel Corp. 82801DB USB EHCI Controller (rev 2).
      IRQ 23.
      Non-prefetchable 32 bit memory at 0xf0000000 [0xf00003ff].
.................略...............................

可以看到這台機器使用 INTEL 82801DB(ICH4) 的南僑晶片,而這晶片支援 USB 2.0 ,並且有 3 個 USB Root Hub.
 
Step1 : Linux 對 USB 的支援
RedHat 預設安裝的 Linux 核心對於 USB 的支援採用的是模組.
而相關模組如下
usbcore.o USB 的核心模組
usb-ohci.o 支援 USB 1.1 ohci controller 的模組
usb-uhci.o 支援 USB 1.1 uhci controller 的模組
ehci-hcd.o 支援 USB 2.0 controller 的模組
usb-storage 當使用 Disks, CD-RW, USB-FLASH,BackPack USB Drives,Archos MP3 Jukebox, etc 裝置時所需要的模組
你可以用 lsmod 來看模組裝置的狀況
通常一般的 USB 裝置, Linux 都有支援,如果有遇到使用上有問題的裝置時,可以先查看 /usr/share/hwdata/usb.ids 
查出你的 USB 裝置是否有列在其中的裝置內.如果沒有很有可能是 Linux 尚未支援的裝置.
 
Step2 : USB 裝置的對應
X-Window 下有一支程式 hwbrowser 可以看目前的硬體裝置,可查出 USB device 掛載在哪一個裝置下.
 
I.USB 的 CDROM
由 scd0,scd1...... 依序下去
 
II.USB 的 Keyboard,Mouse
基本上 USB 的 keyboard,Mouse 插上去就可以使用.
但有時 USB Mouse 會無法使用,此時就使用指令重設 USB Mouse
[root@benjr ~]# mouseconfig
or
[root@benjr ~]# setup
選擇 mouse configuration  
or
[root@benjr ~]# redhat-config-mouse

這支程式必須在 X-window 下執行(RedHat 8.0 之後的版本提供)
 
III.USB Floppy,HardDisk, 拇指碟.....
由 sda,sdb...... 依序下去,可以使用 #fdisk  -l 來看 partition 分割狀態.
 
下面是 USB 裝置和 dev 的對應表,此表來至  http://www.linux-usb.org/usb.devices.txt
USB device number mappings
--------------------------------------------------------------------------------
 13 char Input drivers
    0 = /dev/input/js0 First joystick
    1 = /dev/input/js1 Second joystick
      ...
   32 = /dev/input/mouse0 First mouse
   33 = /dev/input/mouse1 Second mouse
      ...
   63 = /dev/input/mice Mixed input from all mice
   64 = /dev/input/event0 First event stream
   65 = /dev/input/event1 Second event stream
      ...
  The current input system is used for USB devices only, however,
  it isn't limited just to those, and hopefully will be the way
  to access all input devices in the future.
166 char ACM USB modems
    0 = /dev/ttyACM0 First ACM modem
    1 = /dev/ttyACM1 Second ACM modem
      ...
180 char USB devices
    0 = /dev/usb/lp0 First USB printer
      ...
   15 = /dev/usb/lp15 16th USB printer
   32 = /dev/usb/mdc800 MDC800 USB camera
   48 = /dev/usb/scanner0 First USB scanner
      ...
   63 = /dev/usb/scanner15 16th USB scanner
   64 = /dev/usb/rio500 Diamond Rio 500
   96 = /dev/usb/hiddev0 1st USB HID device
      ...
  111 = /dev/usb/hiddev15 16th USB HID device
  112 = /dev/usb/auer0 1st auerswald ISDN device
      ...
  127 = /dev/usb/auer15 16th auerswald ISDN device
  128 = /dev/usb/brlvgr0 First Braille Voyager device
      ...
  131 = /dev/usb/brlvgr3 Fourth Braille Voyager device
  144 = /dev/usb/lcd USB LCD device
  240 = /dev/usb/dabusb0 First daubusb device
      ...
  243 = /dev/usb/dabusb3 Fourth dabusb device
188 char USB serial converters
    0 = /dev/ttyUSB0 First USB serial converter
    1 = /dev/ttyUSB1 Second USB serial converter
      ...
--------------------------------------------------------------------------------
 
Step 3:查看 USB 裝置所使用的速度
這邊我使用的是 Intel ICH5-R(82801EB) 的南僑晶片,所以我們先看看它支援的程度
[root@benjr ~]# lspci
00:1d.0 USB Controller: Intel Corp. 82801EB USB (rev 02)
00:1d.1 USB Controller: Intel Corp. 82801EB USB (rev 02)
00:1d.2 USB Controller: Intel Corp. 82801EB USB (rev 02)
00:1d.3 USB Controller: Intel Corp. 82801EB USB (rev 02)
00:1d.7 USB Controller: Intel Corp. 82801EB USB2 (rev 02)

可以看到 Intel ICH5-R(82801EB) 支援五個 USB Controller,1個 USB 2.0 controller(EHCI 速度為 480Mbps),4個 USB 1.1 controller(UHCIs 速度為 12Mbps)
 
現在來看看我們目前有哪幾個 USB 的裝置,#lsusb (lsusb 由 usbutils-xxx.rpm 提供,可以參考 Linux USB 的官方網站 http://www.linux-usb.org)
[root@benjr ~]# lsusb
Bus 005 Device 001: ID 0000:0000 
Bus 005 Device 002: ID 0d49:5000 Maxtor
Bus 004 Device 001: ID 0000:0000 
Bus 003 Device 001: ID 0000:0000 
Bus 002 Device 001: ID 0000:0000 
Bus 001 Device 001: ID 0000:0000 
Bus 001 Device 003: ID 045e:0039 Microsoft Corp. IntelliMouse Optical
Bus 001 Device 002: ID 08ec:0011 M-Systems Flash Disk Pioneers

可以看到一個 Maxtor 的 USB H.D,一個 Microsoft mouse,一個 Flash Disk(Disk on Key),至於速度要參考 /proc/bus/usb/devices .
[root@benjr ~] # cat /proc/bus/usb/devices
T:  Bus=05 Lev=00 Prnt=00 Port=00 Cnt=00 Dev#=  1 Spd=480 MxCh= 8
B:  Alloc=  0/800 us ( 0%), #Int=  0, #Iso=  0
D:  Ver= 2.00 Cls=09(hub  ) Sub=00 Prot=01 MxPS= 8 #Cfgs=  1
P:  Vendor=0000 ProdID=0000 Rev= 2.04
S:  Manufacturer=Linux 2.4.21-9.ELsmp ehci-hcd
S:  Product=Intel Corp. 82801EB USB2
S:  SerialNumber=00:1d.7
C:* #Ifs= 1 Cfg#= 1 Atr=40 MxPwr=  0mA
I:  If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub
E:  Ad=81(I) Atr=03(Int.) MxPS=   2 Ivl=256ms
--------------------------------------------------------------------------------------------------
#以上可以看到一個 USB 2.0 controller,速度為 480 Mbps
#USB 2.0 controller的裝置會佔用 Bus 05 Lvl 00 而裝置會佔用 Bus 05 Lvl 01 如下所示.
--------------------------------------------------------------------------------------------------
T:  Bus=05 Lev=01 Prnt=01 Port=02 Cnt=01 Dev#=  2 Spd=480 MxCh= 0
D:  Ver= 2.00 Cls=00(>ifc ) Sub=00 Prot=00 MxPS=64 #Cfgs=  1
P:  Vendor=0d49 ProdID=5000 Rev= 1.00
S:  Manufacturer=Maxtor
S:  Product=5000XT v01.00.00
S:  SerialNumber=A80ARQBE   
C:* #Ifs= 1 Cfg#= 1 Atr=c0 MxPwr=  0mA
I:  If#= 0 Alt= 0 #EPs= 3 Cls=08(stor.) Sub=06 Prot=50 Driver=usb-storage
E:  Ad=02(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms
E:  Ad=88(I) Atr=02(Bulk) MxPS= 512 Ivl=0ms
E:  Ad=81(I) Atr=03(Int.) MxPS=   2 Ivl=32ms
--------------------------------------------------------------------------------------------------------------
#以上可以看到一個 USB 2.0 裝置為 Maxtor 的 5000XT USB H.D,
#而且不消耗電流(USB本身使用外接電源) ,速度為 480 Mbps.
--------------------------------------------------------------------------------------------------------------------------------
T:  Bus=02 Lev=00 Prnt=00 Port=00 Cnt=00 Dev#=  1 Spd=12  MxCh= 2
B:  Alloc=  0/900 us ( 0%), #Int=  0, #Iso=  0
D:  Ver= 1.00 Cls=09(hub  ) Sub=00 Prot=00 MxPS= 8 #Cfgs=  1
P:  Vendor=0000 ProdID=0000 Rev= 0.00
S:  Product=USB UHCI Root Hub
S:  SerialNumber=e400
C:* #Ifs= 1 Cfg#= 1 Atr=40 MxPwr=  0mA
I:  If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub
E:  Ad=81(I) Atr=03(Int.) MxPS=   8 Ivl=255ms
---------------------------------------------------------------------------------------------------
#以上可以看到一個 USB 1.1 controller,速度為 12 Mbps
#USB 1.1 controller的裝置會佔用 Bus 01 02 03 04 Lvl 00 而裝置會佔用 Bus 01 02 03 04 Lvl 01 如下所示.(系統會自動分配 Bus 給每個需要的裝置)???????
----------------------------------------------------------------------------------------------------------------------
T:  Bus=01 Lev=01 Prnt=01 Port=00 Cnt=01 Dev#=  3 Spd=1.5 MxCh= 0
D:  Ver= 1.10 Cls=00(>ifc ) Sub=00 Prot=00 MxPS= 8 #Cfgs=  1
P:  Vendor=045e ProdID=0039 Rev= 3.00
S:  Manufacturer=Microsoft
S:  Product=Microsoft 5-Button Mouse with IntelliEye(TM)
C:* #Ifs= 1 Cfg#= 1 Atr=a0 MxPwr=100mA
I:  If#= 0 Alt= 0 #EPs= 1 Cls=03(HID  ) Sub=01 Prot=02 Driver=hid
E:  Ad=81(I) Atr=03(Int.) MxPS=   4 Ivl=10ms
-----------------------------------------------------------------------------------------------------------------
#以上可以看到一個 USB 1.1 裝置為 Microsoft 的 Microsoft 5-Button Mouse with IntelliEye(TM)
,速度為 1.5 Mbps(通常 keyboard,mouse 只會使用低速 low speed).最大消耗電源為 100mA
----------------------------------------------------------------------------------------------------------------------------------------
T:  Bus=01 Lev=01 Prnt=01 Port=01 Cnt=02 Dev#=  2 Spd=12  MxCh= 0
D:  Ver= 2.00 Cls=00(>ifc ) Sub=00 Prot=00 MxPS=64 #Cfgs=  1
P:  Vendor=08ec ProdID=0011 Rev= 2.00
S:  Manufacturer=I0MEGA
S:  Product=Minidrive 128
S:  SerialNumber=0217C20F1B009EDE
C:* #Ifs= 1 Cfg#= 1 Atr=80 MxPwr= 94mA
I:  If#= 0 Alt= 0 #EPs= 2 Cls=08(stor.) Sub=06 Prot=50 Driver=usb-storage
E:  Ad=82(I) Atr=02(Bulk) MxPS=  64 Ivl=0ms
E:  Ad=01(O) Atr=02(Bulk) MxPS=  64 Ivl=0ms
-----------------------------------------------------------------------------------------
#以上可以看到一個 USB 1.1 裝置為 I0MEGA 的 Minidrive 128,速度為 12 Mbps.最大消耗電源為 94mA
note:
1.當你在使用 USB Storage 時,如果直接將他從 USB port 直接移除,在 dmesg下會產生一些 I/O error 的錯誤訊息.
此時你可以用 #rmmod usb-storage 來移除 usb-storage 模組,然後再移除 USB storage 裝置就不會產生一些 I/O error.
2.有些 USB 裝置雖然是 USB 2.0 但是他們卻不能正確的運作,此時我們只好先移除 USB 2.0 的模組(#rmmod ehci-hcd ),
插入 USB 裝置,然後讓系統自己偵測安裝 USB 1.1 或 USB 2.0 的模組,這樣大多數的 USB 裝置都可以在 Linux 下正常的工作.
3.市售的 USB 裝置,大多可以使用在 Linux 下.但有少部分的裝置可能無法正常工作在 linux 下.
所以在你購買任何 USB 裝置前你可以先參考你的 Linux 下的一個檔案 /usr/share/hwdata/usb.ids 它列出你目前的 Linux 版本所有支援的 USB裝置.


/***************************************************************************/
[技術] 使用AutoMake輕鬆生成Makefile  ref: http://lazyflai.blogspot.com/search/label/Makefile
/***************************************************************************/
From: http://www.itepub.net/html/kaifawendang/caozuoxitong/Linux/bianchengkaifa/2006/0501/14712.html
摘要：
在 Unix 上寫過程式的人一般都遇到過 Makefile，尤其是用 C 來開發程式的人。
用 make 來開發和編譯程式的確很方便，可是要寫出一個MakeFile就不那麼簡單了。
偏偏介紹 Makefile 的文件不多，GNU Make 那份印出來要幾百頁的文件，光看完 Overview 自己就快要先Over了，難怪許多人聞 Unix色變。
本文將介紹如何利用 GNU Autoconf 及 Automake 這兩套軟體來幫助『自動』產生 Makefile 文件，
並且讓開發出來的的軟體可以像 Apache, MySQL 和常見的 GNU 軟體一樣，只要會 ``./configure'', ``make'', ``make install'' 就可以把程式安裝到系統中。
如果您有心開發 Open Source 的軟體，或只是想在 Unix 系統下寫寫程式。希望這份介紹文件能幫助您輕鬆的進入 Unix Programming 的殿堂。
1. 簡介
Makefile 基本上就是『目標』(target), 『關聯』(dependencies) 和『動作』三者所組成的一系列規則。
而 make 就會根據 Makefile 的規則來決定如何編譯 (compile) 和連接 (link) 程式。
實際上，make 可做的不只是編譯和連接程式，例如 FreeBSD 的 port collection 中，Makefile還可以做到自動下載遠端程式，解壓縮 (extract) ， 打補丁 (patch)，設定，然後編譯，安裝到系統中。
Makefile 基本結構雖然很簡單，但是妥善運用這些規則就可以變換出許多不同的花樣。卻也因為這樣，許多剛剛開始學習寫Makefile 時會覺得沒有規範可以遵循，每個人寫出來的Makefile都不大一樣，不知道從哪裡下手，而且常常會受到自己的開發環境的限制，只要環境參數不同或者路徑更改，可能 Makefile 就得跟著修改修改。雖然有 GNU Makefile Conventions (GNU Makefile慣例例)訂出一些使用 GNU 程式設計時撰寫 Makefile 的一些標準和規範，但是內容很長而且很複雜，並且經常作一些調整，為了減輕程式開發人員維護Makefile 的負擔，因此出現了Automake。
程式設計者只需要寫一些預先定義好的巨集 (macro)，提交給Automake處理後會產生一個可以供 Autoconf 使用的 Makefile.in文件。再配合利用 Autoconf產生的自動培植設置文件 configure 即可產生一份符合符合 GNU Makefile 慣例的 Makeifle 了。
2. 上路之前
在開始使用 Automake 之前，首先確認你的系統安裝有如下軟體：
1. GNU Automake
2. GNU Autoconf
3. GNU m4
4. perl
5. GNU Libtool (如果你需要產生 shared library)
建議最好也使用 GNU C/C++ 編譯器 、GNU Make 以及其它 GNU 的工具程式來作為開發的環境，這些工具都是屬於 Open Source Software 不但免費而且功能強大。
如果你是使用 Red Hat Linux 可以找到所有上述軟體的 rpm 文件，FreeBSD 也有現成的 package 可以直接安裝，或也可以自行下載這些軟體的源代碼回來安裝。
下面的示例是在Red Hat Linux 5.2 + CLE2 的環境下所完成的。
3. 一個簡單的例子 Automake 所產生的 Makefile 除了可以做到程式的編譯和連接，也已經把如何產生程式文件 (如 manual page, info 文件及 dvi 文件) 的動作，還有把源碼文件包裝起來以供發佈都考慮進去了，所以程式源代碼所存放的目錄結構最好符合GNU 的標準慣例，接下來就用一個hello.c 來做為例子。
在工作目錄下建立一個新的子目錄"devel"'，再在 devel 下建立一個"hello"' 的子目錄，這個目錄將作為存放 hello這個程式及其相關文件的地方：
% mkdir devel
% cd devel
% mkdir hello
% cd hello 用編輯器寫一個hello.c文件，
#include
int main(int argc, char** argv) {
  printf(``Hello, GNU!n'');
  return 0;
}

接下來就要用 Autoconf 及 Automake 來產生 Makefile 文件了，
1. 用 autoscan 產生一個 configure.in 的原型，執行autoscan 後會產生一個configure.scan 的文件，可以用它作為 configure.in文件的藍本。
% autoscan
% ls configure.scan hello.c
2 . 編輯 configure.scan文件，如下所示，並且改名為configure.in
# Process this file with autoconf to produce a configure script.
AC_INIT(hello.c)
AM_INIT_AUTOMAKE(hello, 1.0)
dnl Checks for programs.
AC_PROG_CC
# Checks for libraries.
# Checks for header files.
# Checks for typedefs, structures, and compiler characteristics.
# Checks for library functions.
AC_OUTPUT(Makefile)
3. 執行 aclocal 和 autoconf ，分別會產生 aclocal.m4 及 configure 兩個文件
% aclocal
% autoconf
% ls 
aclocal.m4 configure configure.in hello.c
4. 編輯 Makefile.am 文件，內容如下
AUTOMAKE_OPTIONS= foreign
bin_PROGRAMS= hello
hello_SOURCES= hello.c
5. 執行 automake --add-missing ，Automake 會根據Makefile.am 文件產生一些文件，包含最重要的 Makefile.in
% automake --add-missing 
automake: configure.in: installing `./install-sh' 
automake: configure.in: installing `./mkinstalldirs' 
automake: configure.in: installing `./missing'
6. 最後執行 ./configure ，
% ./configure 
creating cache ./config.cache 
checking for a BSD compatible install... 
/usr/bin/install -c checking whether build environment is sane... yes 
checking whether make sets ${MAKE}... yes 
checking for working aclocal... 
found checking for working autoconf... 
found checking for working automake... 
found checking for working autoheader... 
found checking for working makeinfo... 
found checking for gcc... gcc 
checking whether the C compiler (gcc ) works... yes 
checking whether the C compiler (gcc ) is a cross-compiler... no 
checking whether we are using GNU C... yes 
checking whether gcc accepts -g... yes 
updating cache ./config.cache creating ./config.status creating Makefile
現在你的目錄下已經產生了一個 Makefile 檔，下個 make 指令就可以開始編譯 hello.c 成執行檔，執行 ./hello 和 GNU 打聲招呼吧！
% make 
gcc -DPACKAGE="hello" -DVERSION="1.0" -I. -I. -g -O2 -c hello.c gcc -g -O2 -o hello hello.o 
% ./hello Hello! GNU!
你還可以試試 make clean，make install，make dist 看看會有什麼結果。
你也可以把產生出來的 Makefile 秀給你的老闆，讓他從此對你刮目相看 :-)
4. 追根問底
上述產生Makefile 的過程和以往自行編寫的方式非常不一樣，捨棄傳統自定義make 的規則，使用 Automake 只需用到一些已經定義好的巨集就可以了。
我們把巨集及目標 (target)寫在Makefile.am 文件內，Automake 讀入 Makefile.am 文件後會把這一串已經定義好的巨集展開並產生相對應的 Makefile.in 文件，
然後再由 configure這個 shell script 根據 Makefile.in 產生合適的Makefile。
[Figure 1:利用 autoconf 及 automake產生Makefile 的流程]
上圖表示在上一範例中要使用的文件檔案及產生出來的文件，有星號 (*) 者代表可執行文件。在此示例中可由 Autoconf 及 Automake 工具所產生的額外文件有 configure.scan、aclocal.m4、configure、Makefile.in，需要自行加入設置的有configure.in 及 Makefile.am。
4.1 編輯 configure.in 文件 Autoconf 是用來產生 'configure'文件的工具。'configure' 是一個 shell script，它可以自動設定原始程式以符合各種不同平台上Unix 系統的特性，並且根據系統參數及環境產生合適的Makefile文件或C 的頭文件(header file)，讓原始程式可以很方便地在不同的平台上進行編譯。Autoconf會讀取 configure.in 文件然後產生'configure' 這個 shell script。
configure.in 文件內容是一系列GNU m4 的巨集，這些巨集經autoconf處理後會變成檢查系統特性的shell scripts。 configure.in 內巨集的順序並沒有特別的規定，但是每一個configure.in 文件必須在所有巨集前加入 AC_INIT 巨集，然後在所有巨集的最後加上 AC_OUTPUT 巨集。可先用 autoscan 掃瞄原始文件以產生一個 configure.scan 文件，再對 configure.scan 做些修改成 configure.in 文件。在範例中所用到的巨集如下：
dnl 這個巨集後面的字不會被處理，可以視為註釋 AC_INIT(FILE) 該巨集用來檢查源代碼所在路徑，autoscan 會自動產生，一般無須修改它。 AM_INIT_AUTOMAKE(PACKAGE,VERSION) 這個是使用 Automake 所必備的巨集，PACKAGE 是所要產生軟體套件的名稱，VERSION 是版本編號。 AC_PROG_CC 檢查系統可用的C編譯器，若源代碼是用C寫的就需要這個巨集。 AC_OUTPUT(FILE) 設置 configure 所要產生的文件，若是Makefile ，configure 便會把它檢查出來的結果帶入 Makefile.in 文件後產生合適的 Makefile。 實際上，這裡使用 Automake 時，還需要一些其他的巨集，這些額外的巨集我們用 aclocal來幫助產生。執行 aclocal會產生aclocal.m4 文件，如果無特別的用途，可以不需要修改它，用 aclocal 所產生的巨集會告訴 Automake如何動作。
有了 configure.in 及 aclocal.m4兩個文件以後，便可以執行 autoconf來產生 configure 文件了。
4.2 編輯Makefile.am 文件 接下來要編輯Makefile.am 文件，Automake 會根據 configure.in 中的巨集把Makefile.am 轉成 Makefile.in 文件。 Makefile.am 文件定義所要產生的目標：
AUTOMAKE_OPTIONS 設置 automake 的選項。Automake 主要是幫助開發 GNU 軟體的人員來維護軟體，所以在執行 automake 時，會檢查目錄下是否存在標準 GNU 軟體中應具備的文件，例如 'NEWS'、'AUTHOR'、'ChangeLog' 等文件。設置 foreign 時，automake 會改用一般軟體的標準來檢查。 bin_PROGRAMS 定義要產生的執行文件名。如果要產生多個執行文件，每個文件名用空白符隔開。 hello_SOURCES 定義 'hello' 這個執行程式所需要的原始文件。如果 'hello'這個程式是由多個原始文件所產生，必須把它所用到的所有原始文件都列出來，以空白符隔開。假設 'hello' 還需要 'hello.c'、'main.c'、'hello.h' 三個文件的話，則定義 hello_SOURCES= hello.c main.c hello.h 如果定義多個執行文件，則對每個執行程式都要定義相對的filename_SOURCES。
編輯好 Makefile.am 文件，就可以用 automake --add-missing來產生 Makefile.in。加上 --add-missing 選項來告訴 automake順便假如包裝一個軟體所必須的文件。Automake產生生出來的 Makefile.in 文件是完全符合 GNU Makefile 的慣例，只要執行 configure這個shell script 便可以產生合適的 Makefile 文件了。
4.3 使用 Makefile 利用 configure 所產生的 Makefile文件有幾個預先設定的目標可供使用，這裡只用幾個簡述如下：
make all 產生設定的目標，既次範例中的執行文件。只敲入make 也可以，此時會開始編譯源代碼，然後連接並產生執行文件。 
make clean 清除之前所編譯的執行文件及目標文件(object file, *.o)。 
make distclean 除了清除執行文件和目的文件以外，也把 configure 所產生的 Makefile 清除掉。 
make install 將程式安裝到系統中，若源碼編譯成功，且執行結果正確，便可以把程式安裝到系統預先設定的執行文件存放路徑中，若用 bin_PROGRAMS 巨集的話，程式會被安裝到 /usr/local/bin下。 
make dist 將程式和相關的文檔包裝為一個壓縮文檔以供發佈 (distribution) 。執行完在目錄下會產生一個以PACKAGE-VERSION.tar.gz 為名稱的文件。
PACKAGE 和 VERSION 這兩個參數是根據 configure.in 文件中 AM_INIT_AUTOMAKE(PACKAGE, VERSION) 的定義。在此範例中會產生 'hello-1.0.tar.gz' 的文件。 
make distcheck 和 make dist 類似，但是加入檢查包裝以後的壓縮文件是否正常，這個目標除了把程式和相關文檔包裝成 tar.gz 文件外，還會自動把這個壓縮文件解開，執行 configure，並執行 make all ，
確認編譯無錯誤以後，戶顯示這個 tar.gz 文件已經準備好可以發佈了。這個檢查非常有用，檢查過關的套件，基本上可以給任何具備 GNU 開發環境的人去重新編譯成功。
就 hello-1.tar.gz 這個範例而言，除了在Red Hat Linux 上，在 FreeBSD 2.2.x 也可以正確編譯。 
要注意的是，利用 Autoconf 及 Automake 所產生出來的軟體套件是可以在沒有安裝 Autoconf 及 Automake 的環境使用的，因為 configure 是一個 shell script，它己被設計為可以在一般 Unix 的 sh 這個 shell 下執行。
但是如果要修改 configure.in 及 Makefile.am 文件再產生新的 configure 及 Makefile.in 文件時就一定要有 Autoconf 及 Automake 了。
5. 相關資料
Autoconf 和 Automake 功能十分強大，可以從它們附帶的 info 穩當4中找到詳細的使用方法說明。你也可以從許多現有的GNU 軟體或 Open Source 軟體中找到相關的 configure.in 或 Makefile.am 文件，他們是學習 Autoconf 及 Automake 更多技巧的最佳範例。
這個簡介只用到了 Autoconf 及 Automake 的皮毛罷了，如果你有心加入 Open Source 軟體開發的行列，希望這篇文章可以幫助你對產生 Makefile 有個簡單的瞭解。其它有關開發 GNU 程式或 C 程式設計及 Makefile 的詳細運用及技巧，建議從 GNU Coding Standards (GNU 編碼規定) 讀起，裡面包含了 GNU Makefile 慣例，及開發 GNU 軟體的標準程式和慣例。這些 GNU 軟體的在線說明文件可以在 http://www.gnu.org/ 上找到。
6. 結束語
利用 Autoconf 及 Automake，產生一個 Makefile 似乎不再像以前那麼困難了，而使用 Autoconf 也使得我們在不同平台上或各家 Unix 之間發佈及便宜程式變的簡單，這對於在Unix 系統上程式開發員來說減輕了許多負擔。妥善運用這些 GNU 的工具軟體，可以幫助我們更容易的去開發程式，而且更容易維護源代碼。


/***************************************************************************/
// 自動建立一個Makefile
/***************************************************************************/
1. vim hello.c
$ vim hello.c
#include <stdio.h>

int main(void){
        printf("Hello,world!\n");
        return 0;
}
$ ls
hello.c

2. autoscan
$ autoscan
$ ls
autoscan.log  configure.scan  hello.c

3. mv configure.scan configure.in
$ mv configure.scan configure.in
$ ls
autoscan.log  configure.in  hello.c

4. 修改configure.in
$ vim configure.in
#AC_CONFIG_HEADER([config.h])
AM_INIT_AUTOMAKE(hello, 1.0)
AC_OUTPUT(Makefile)

5. aclocal
$ aclocal

6. autoconf
$ autoconf

7. vim Makefile.am
$ vim Makefile.am
AUTOMAKE_OPTIONS= foreign
bin_PROGRAMS= hello
hello_SOURCES= hello.c
$ ls
aclocal.m4      autoscan.log  configure.in  Makefile.am
autom4te.cache  configure     hello.c

8. automake --add-missing
$ automake --add-missing
configure.in:8: installing `./install-sh'
configure.in:8: installing `./missing'
Makefile.am: installing `./depcomp'
$ ls
aclocal.m4      autoscan.log  configure.in  hello.c     Makefile.am  missing
autom4te.cache  configure     depcomp       install-sh  Makefile.in

9. ./configure
$ ./configure
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for a thread-safe mkdir -p... /bin/mkdir -p
checking for gawk... gawk
checking whether make sets $(MAKE)... yes
checking for gcc... gcc
checking whether the C compiler works... yes
checking for C compiler default output file name... a.out
checking for suffix of executables...
checking whether we are cross compiling... no
checking for suffix of object files... o
checking whether we are using the GNU C compiler... yes
checking whether gcc accepts -g... yes
checking for gcc option to accept ISO C89... none needed
checking for style of include used by make... GNU
checking dependency style of gcc... gcc3
configure: creating ./config.status
config.status: creating Makefile
config.status: executing depfiles commands

10. make
$ make
gcc -DPACKAGE_NAME=\"FULL-PACKAGE-NAME\" -DPACKAGE_TARNAME=\"full-package-name\" -DPACKAGE_VERSION=\"VERSION\" -DPACKAGE_STRING=\"FULL-PACKAGE-NAME\ VERSION\" -DPACKAGE_BUGREPORT=\"BUG-REPORT-ADDRESS\" -DPACKAGE_URL=\"\" -DPACKAGE=\"hello\" -DVERSION=\"1.0\" -I.     -g -O2 -MT hello.o -MD -MP -MF .deps/hello.Tpo -c -o hello.o hello.c
mv -f .deps/hello.Tpo .deps/hello.Po
gcc  -g -O2   -o hello hello.o
$ ls
aclocal.m4      config.log     configure.in  hello.c     Makefile     missing
autom4te.cache  config.status  depcomp       hello.o     Makefile.am
autoscan.log    configure      hello         install-sh  Makefile.in

11. ./hello
$ ./hello
Hello, world!


/***************************************************************************/
linux內核GPIO模擬I2C實例  ref: http://www.linux521.com/2009/system/201010/12244.html
/***************************************************************************/
linux內核GPIO模擬I2C實例 由Linux系統中文網（Linux521.com）編輯收集整理，除Linux521註明原創文章外，其版權歸原作者所有。
如果您在學習中遇到問題歡迎在下面的評論中留言，我們會盡全力解答您的問題。
使用GPIO口模擬I2C總線並掛載設備
前言：
在許多情況下,我們並沒有足夠的I2C總線,本文主在介紹如何利用Linux內核中的i2c-gpio模組,利用2條GPIO線模擬i2c總線,並掛載設備.
思路：
先通過對i2c-gpio所定義的結構體初始化(包括初始化i2c的2條線,頻率,timeout等)
並將i2c-gpio模組編譯進內核,實現用GPIO_X,GPIO_Y 2條GPIO線註冊新的i2c總線.
此時這個模組對i2c設備是透明的,及掛在這2條GPIO線的i2c設備可以直接使用Linux內核通用的i2c設備註冊,傳輸和註銷等方法.
步驟： 
確認在註冊i2c-gpio模組前,所要用到的2條GPIO口是沒有被系統其它地方所調用的.
在每個系統平台啟動時,都會打開一系列的設備,他們通常實現在arch/目錄下相應的平檯子目錄中的
例如setup.c,devices.c文件中,在這裡我們進行i2c總線的註冊以及設備的掛載.
i2c-gpio定義的結構在include/linux/i2c-gpio.h中：
/*
* struct i2c_gpio_platform_data - Platform-dependent data for i2c-gpio
* @sda_pin: GPIO pin ID to use for SDA
* @scl_pin: GPIO pin ID to use for SCL
* @udelay: signal toggle delay. SCL frequency is (500 / udelay) kHz
* @timeout: clock stretching timeout in jiffies. If the slave keeps
*       SCL low for longer than this, the transfer will time out.
* @sda_is_open_drain: SDA is configured as open drain, i.e. the pin
*       isn't actively driven high when setting the output value high.
*       gpio_get_value() must return the actual pin state even if the
*       pin is configured as an output.
* @scl_is_open_drain: SCL is set up as open drain. Same requirements 
*       as for sda_is_open_drain apply.
* @scl_is_output_only: SCL output drivers cannot be turned off.
*/
struct i2c_gpio_platform_data {
unsigned int    sda_pin;
unsigned int    scl_pin;
int      udelay;
int      timeout; 
unsigned int    sda_is_open_drain:1;
unsigned int    scl_is_open_drain:1;
unsigned int    scl_is_output_only:1;
}; 
其中sda_pin和scl_pin分別是i2c總線的數據線和時鐘線,在i2c-gpio中會通過gpio_request函數對這2個口進行申請,
udelay和timeout如果不設初值,i2c-gpio中會自動將其設為預設值.
if (pdata->udelay)
  bit_data->udelay = pdata->udelay;
else if (pdata->scl_is_output_only)
  bit_data->udelay = 50;   /* 10 kHz */
else
  bit_data->udelay = 5;    /* 100 kHz */

if (pdata->timeout)
  bit_data->timeout = pdata->timeout;
else
  bit_data->timeout = HZ / 10;     /* 100 ms */

初始化這個結構體後再將其裝入platform_device結構體,方便註冊：
static struct platform_device i2c_device = {
.name    = "device-name",
.id      = your-id,
.dev = {
.platform_data  = &i2c_data, // i2c_gpio_platform_data  
},
};
註冊i2c-gpio設備
將i2c設備掛入我們註冊的總線：
platform_device_register(&i2c_device);
static struct i2c_board_info i2c_device[] = {
  {
  I2C_BOARD_INFO("name", i2c_device_addr),
  }
};
i2c_register_board_info(your-id, i2c_device, ARRAY_SIZE(i2c_device));
此時我們就可以在i2c設備的驅動程式中通過遍歷所在i2c總線,得到其所在的地址i2c_device_addr.
在i2c驅動中,需要註冊一個i2c_driver的結構體,例如： 
static const struct i2c_device_id lis35de_id[] = {
  { "lis35de", 0 },
  { }
};
static struct i2c_driver st_lis35de_driver = {  
  .probe   = st_lis35de_probe,
  .remove  = st_lis35de_remove,
  .suspend = st_lis35de_suspend,
  resume   = st_lis35de_resume,
  .id_table = lis35de_id,
  .driver  = {
    .name   = "lis35de",
  },
};
static int __init st_lis35de_init(void)
{ 
  printk(KERN_INFO "st_lis35de_init\n");
  return i2c_add_driver(&st_lis35de_driver);
}
在init時用i2c_add_driver(&st_lis35de_driver),此時將會對所在i2c總線進行遍歷並得到該設備的適配器等資訊,
主要目的即是使驅動得到自己的i2c_client,在這個i2c_client中,已經有了該i2c設備的地址等資訊,
我們在驅動中定義一個新的i2c_client全局變數,把得到的這個i2c_client傳給這個全局變數,從而可以繼續後面的i2c操作.
此時我們就可以使用通用的i2c讀寫操作了.
總結：
直接用GPIO口模擬I2C時序和利用內核模組 
i2c-gpio虛擬i2c總線的區別：
1． 用GPIO口模擬I2C時序不需要在系統啟動時註冊I2C總線,只需要在I2C設備驅動中單獨實現.
    用i2c-gpio模組虛擬i2c總線需要在系統啟動時註冊新的I2C總線,並將i2c設備掛載到新的i2c總線,涉及的範圍較廣.
2． 用GPIO口模擬I2C時序,代碼操作較繁瑣,且不方便掛載多個 
    i2c設備.用i2c-gpio模組可以完全模擬i2c總線,可以掛載多個設備.
3． 在i2c讀寫操作時,用GPIO口模擬I2C時序需要每次根據讀/寫操作發送器件地址<<1 1/0,然後再發送寄存器地址.
    用i2c-gpio模組相當於直接在i2c總線上操作,在系統啟動掛載i2c設備時已經告訴了i2c總線它的地址,在該設備自己的驅動中,
    只需要通過i2c_add_driver操作即可以得到其地址等諸多資訊,讀寫操作只需要發送寄存器地址即可.

附：i2c一般的讀寫操作
#include <linux/i2c.h>
/*讀操作：*/  
static int i2c_RxData(char *rxData, int length)
{
  struct i2c_msg msgs[] = {
    /* 把1個位元組的i2c設備寄存器地址告訴總線 */
    {
    .addr = client->addr,
    .flags = 0, //寫操作
    .len = 1,
    .buf = rxData,
    },
    /* 從總線讀取length個位元組的數據,存入rxData */
    {
    .addr =client ->addr,
    .flags = I2C_M_RD, //I2C_M_RD在i2c.h中被定義為1,讀操作
    .len = length,
    .buf = rxData,
    },
  };
  if (i2c_transfer(client->adapter, msgs, 2) < 0) { /* 傳輸並判斷是否傳輸錯誤 */
    printk(KERN_ERR "I2C_RxData: transfer error\n");
    return -EIO;
  } else
    return 0;
}

/* 寫操作 */
static int i2c_TxData(char *txData, int length)
{
  struct i2c_msg msg[] = {
  /* 第1個位元組是器件寄存器地址,後面的位元組是寫入的數據 */
    {
      .addr = client->addr,
      .flags = 0,
      .len = length,
      .buf = txData,
    },
  };

  if (i2c_transfer(client->adapter, msg, 1) < 0) 
  {
    printk(KERN_ERR "I2C_TxData: transfer error\n");
    return -EIO;
  } else
    return 0;
}


/***************************************************************************/
// LINUX GPIO
/***************************************************************************/
Documentation 先從documentation消化一點介紹: 
A "General Purpose Input/Output" (GPIO) is a flexible software-controlled digital signal。 
既然是數位訊號數位訊號在computer science，那就是只有0(low)/1(high)，在embedded 平台上是常用且好用的東西。
SoC上會有一堆GPIO，多達一百多根，沒有被設為alternative function (註1)的都可以拿來GPIO。
從schematics上看就是一個點，從CPU拉出來，可能拉到power button設為XEINT當wakeup event，
或是拉到analog codec設gpi當jack detect，或是設成gpo用來表示目前系統狀態 (1: normal; 0 suspend)。
GPIO的用途大概有以下幾種:
1. alternative function: 這是特定的function，如camera，hdmi，keypad。
   以hdmi為例，可以接到hdmi的hpd當hot plug detect，或是cec做進階控制，不過這些gpio都會有另外的driver來控制。
   以keypad為例，就可以藉由gpio的high/low來mapping按了哪個key。
2. GPI: input/output的方向是對CPU而言，因此GPI就是從外部給CPU signal，比如說EC。
   舉個例好了，EC控制power button，按下後，EC就將某個GPI拉high，此時CPU收到high後，trigger wakeup source，系統就resume。
3. GPO: 對照GPI，GPO就是由CPU發出來的。同樣用EC當例子，EC也控了LED。當系統進入suspend，就把某根接到EC的GPO拉low。
   EC收到後，就把LED變成橘色。
GPIO怎麼用，在不同的系統，不同的應用會有不同的用法。

KERNEL
GPIO相關的API都定義在
#include <linux/gpio.h>
sample code:
1.為避免不同的driver同時設定同一根GPIO，所以先用gpio_request看看是否有人使用。之後再用s3c_gpio_cfgpin設為GPI，然後拉NONE。
        err = gpio_request(S5PV2XX_GPH3(7),"GPH3");
        if (err){
                printk("gpio request error : %d\n",err);
        }else{
                s3c_gpio_cfgpin(S5PV2XX_GPH3(7),S3C_GPIO_INPUT);
                s3c_gpio_setpull(S5PV2XX_GPH3(7), S3C_GPIO_PULL_NONE);
        }
2.設為GPO，並拉low (0), high (1)
gpio_direction_output(S5PV2XX_GPH0(7), 0);
gpio_direction_output(S5PV2XX_GPH0(7), 1);
3.  設為EINT wakeup source。先設為EINT後，再投為wakeup source，掛handler。
        err = gpio_request(S5PV2XX_GPH3(7),"GPH3");
        if (err){
                printk("gpio request error : %d\n",err);
        }else{
                s3c_gpio_cfgpin(S5PV2XX_GPH3(7),S5PV2XX_GPH3_7_EXT_INT33_7);
                s3c_gpio_setpull(S5PV2XX_GPH3(7), S3C_GPIO_PULL_NONE);
        }

        set_irq_type(IRQ_EINT(31), IRQF_TRIGGER_FALLING);
        setup_irq(IRQ_EINT(31), &s3c_button_irq);
        set_irq_wake(IRQ_EINT(31), 1);


/***************************************************************************/
// UIO-Linux user space I/O driver  ref: http://daydreamer.idv.tw/rewrite.php/read-41.html
/***************************************************************************/
UIO這個東西是雖然是今年四月份的時候merge到kernel trunk,但其實在linux界很早就有相關的應用,因為它的技術很簡單,
就是直接把kernel memory一對一映射到user space memory,藉由這樣mapping的方式,讓user program直接在user space存取hardware I/O
而UIO在kernel提供了一個簡單的架構,programmer只要設定好IO address和size,就可以使用UIO的功能,
UIO會自動幫我們處理VMA相關的轉換動作,而UIO drvier的撰寫順序如下
1.宣告struct uio_info,並填入hardware資料
  uio_info.name:drvier的名稱
  uio_info.version:driver版本
  uio_info.irq:中斷編號
  uio_info.irq_flags:request_irq時需傳入的參數
  uio_info.handler:中斷handler
  uio_info.mem[]:hardware IO映射位址,可以有很多組
2.user space的程式很簡單,就是用open和mmap去存取hardware I/O
QT2410 LED UIO的範例我簡述如下,因為我driver註冊為platform driver,所以有改到arch/arm/mach-s3c2410/mach-smdk2410.c,請參照如下修改

static struct resource s3c_led_resources[] = { 
    [0] = {
        .start = 0x56000000,
        .end = 0x56000000 + 24,
        .flags = IORESOURCE_MEM,
    },
    [1] = {
        .start = IRQ_EINT23,
        .end = IRQ_EINT23,
        .flags = IORESOURCE_IRQ,
    },
};
static struct platform_device s3c_led = { 
    .name = "JoeyLED",
    .num_resources = ARRAY_SIZE(s3c_led_resources),
    .resource = s3c_led_resources,
};
static struct platform_device *smdk2410_devices[] __initdata = { 
    &s3c_device_usb,
    &s3c_device_lcd,
    &s3c_device_wdt,
    &s3c_device_i2c,
    &s3c_device_iis,
    &s3c_cs89x0,
    &s3c_led,
};
新增led.c這個UIO driver,範例程式如下,重點在led_probe這個函式,可以看看該如何填寫uio_info這個structure的資料
#include <linux/module.h> 
#include <linux/kernel.h> 
#include <linux/init.h> 
#include <linux/proc_fs.h> 
#include <asm/uaccess.h> 
#include <linux/ioport.h> 
#include <asm/io.h> 
#include <linux/uio_driver.h> 
#include <linux/platform_device.h> 
 
#define GPIOBAdr 0x56000014
#define DRV_NAME "JoeyLED"
#define DRV_VERSION "0.0.1"
 
static irqreturn_t led_handler(int irq, struct uio_info *dev_info) 
{ 
    printk("interrupt happened\n");
    return IRQ_HANDLED;
} 
 
static int __init led_probe(struct platform_device *dev) 
{ 
    struct resource *regs;
    struct uio_info *info;

    printk("probing led\n");
    info = kzalloc(sizeof(struct uio_info), GFP_KERNEL);
    if (!info)
        return -ENOMEM;
    regs = platform_get_resource(dev, IORESOURCE_MEM, 0);
    if (!regs)
    {
        dev_err(&dev->dev, "No memory resource specified\n");
        return -ENODEV;
    }
    else
    {
        printk("GPIOB reg->start %x reg->end %x \n",regs->start,regs->end );
    }
    info->mem[0].addr = regs->start;
    info->mem[0].size=regs->end - regs->start;
    info->mem[0].internal_addr=ioremap(regs->start, info->mem[0].size);;
    if (!info->mem[0].addr)
    {
        dev_err(&dev->dev, "Invalid memory resource\n");
        return -ENODEV;
    }

    info->mem[0].memtype = UIO_MEM_PHYS;
    info->version = "0.0.1";
    info->name="JoeyLED";
    info->irq=platform_get_irq(dev, 0);
    info->irq_flags = IRQF_SHARED;
    info->handler = led_handler;
    if (uio_register_device(&dev->dev, info))
    {
        iounmap(info->mem[0].internal_addr);
        printk("uio_register failed\n");
        return -ENODEV;
    }
    platform_set_drvdata(dev, info);
    printk("probing led success\n");
    return 0;
} 
 
static int __exit led_remove(struct platform_device *dev) 
{ 
    struct uio_info *info = platform_get_drvdata(dev);

    uio_unregister_device(info);
    platform_set_drvdata(dev, NULL);
    iounmap(info->mem[0].internal_addr);
    kfree(info);
    return 0;
} 
 
static struct platform_driver led_driver = { 
    .probe = led_probe,
    .remove = __devexit_p(led_remove),
    .driver = {
        .name = DRV_NAME,
        .owner = THIS_MODULE,
    },
};
 
static int __init led_init(void) 
{ 
    printk("QT2410 LED driver demo\n");
  
    return platform_driver_register(&led_driver);
} 
 
static void __exit led_exit(void) 
{ 
    platform_driver_unregister(&led_driver);
} 
module_init(led_init);
module_exit(led_exit);
 
MODULE_DESCRIPTION("led module");
MODULE_AUTHOR("Joey Cheng<jemicheng@gmail.com>");
MODULE_LICENSE("GPL");
MODULE_ALIAS("QT2410:LED module");

Userspace程式的範例如下
#include <stdio.h> 
#include <stdlib.h> 
#include<sys/mman.h> 
#include<fcntl.h> 
#include <asm/page.h> 
int main(void) 
{ 
    int mem_fd,i=0;
    unsigned *led;

    mem_fd=open("/dev/uio0",O_RDWR|O_SYNC);
    if (mem_fd <0)
    {
        printf("open device error\n");
        return;
    }
    led=mmap(NULL,24, PROT_READ | PROT_WRITE, MAP_SHARED,mem_fd, 0);
    if (led == MAP_FAILED)
    {
        perror("mmap");
        close(mem_fd);
        exit(-1);
    }
    //led+=4;
    led+=5;
    while(i<3)
    {
        (*(volatile unsigned *)led)|=0x00000002;
        printf("led mem %p content %d\n",led,*(unsigned *)led);
        sleep(3);
        (*(volatile unsigned *)led)&=~(0x00000002);
        printf("led mem %p content %d\n",led,*(unsigned *)led);
        i++;
        sleep(3);
    }
    close(mem_fd);
}

記得要在kernel選單中選擇Userspace I/O drivers
重編kernel並試著跑跑看上面的範例來點亮板子上的led,修改過的檔案我簡列如下,
記得在執行範例前先確定/dev/uio0是否有建立,請先cat /sys/class/uio/uio0/dev/的資訊,
確定device node的major和minor(/sys這個資料夾是virtual sysfs mount出來的,請下指令mount -t sysfs sysfs /sys)

1.arch/arm/mach-s3c2410/mach-smdk2410.c
2.drivers/uio/led_kernel.c
3.drivers/uio/Makefile
4.drivers/uio/Kconfig
5.led.c(in user space)
UIO相關的參考資料請點這裡,這邊有個很棒的軟體叫lsuio,可以列出所有UIO的module和其映射的memory address,執行範例如下圖


/***************************************************************************/
[Kernel Driver] 撰寫簡易 Timer 機制     ref: http://blog.wu-boy.com/2010/07/kernel-driver-%E6%92%B0%E5%AF%AB%E7%B0%A1%E6%98%93-timer-%E6%A9%9F%E5%88%B6/
/***************************************************************************/
在底層 Linux Kernel 提供了時序(timing)機制，方便驅動程式設計者所使用，核心是依據硬體發出的『計時器中斷』來追蹤時間的流動狀況。
我們可以依據 HZ 的值來設計 Delay 機制，讓驅動程式可以每隔固定一段時間啟動或者是發出訊號，也可以利用 Timer 來讓 LED 閃爍變化，
在介紹 Timer API 之前，可以先參考 Linux Kernel: 簡介HZ, tick and jiffies 這篇文章，瞭解一些相關名詞，
舉例：如果想知道一秒後的 jiffies 時間，可以寫成底下：

#ifdef CONFIG_BMA150_TIMER
#include <linux/timer.h>
#endif
j = jiffies;
/* 一秒之後 */
stamp_1 = j + HZ;
/* 半秒之後 */
stamp_1 = j + HZ/2; 
/* 20秒之後 */
stamp_1 = j + 20*HZ;

Timer API 用法
筆記一下自己在寫 BOSCH Sensortec 三軸加速偵測器(BMA150 Sensor) Driver 的時候，
遇到底層要回報 input event X,Y,Z 到 Android HAL(Hardware abstraction layer)，
所以利用 Timer 的機制定時 report 給 Android。
首先宣告：
#ifdef CONFIG_BMA150_TIMER
#include <linux/timer.h>
#endif
/* 定義 timer_list struct */
#ifdef CONFIG_BMA150_TIMER
struct timer_list bma150_report_timer;
#endif

在 Driver 內的 bma150_probe 裡面 call function:
#ifdef CONFIG_BMA150_TIMER
  bma150_init_timer();
#endif

撰寫 bma150_init_timer 函式：
#ifdef CONFIG_BMA150_TIMER
static void bma150_init_timer(void)
{  
  D("BMA150 init_timer start\n");
  /* Timer 初始化 */
  init_timer(&bma150_report_timer);
  /* 定義 timer 所執行之函式 */
  bma150_report_timer.function = bma150_report;
  /* 定義 timer 傳入函式之 Data */
  bma150_report_timer.data = ((unsigned long) 0);
  /* 定義 timer Delay 時間 */
  bma150_report_timer.expires = jiffies + BMA150_REPORT_DELAY_1;
  /* 啟動 Timer*/
  add_timer(&bma150_report_timer); 
}
#endif
上述 add_timer 執行之後，會在一秒後執行 bma150_report 函式，執行之後就會停止，
所以如果要一直產生迴圈，就必須在 bma150_report 裡面繼續加入 add_timer，改寫如下：

static int bma150_report(void)
{
  D("appleboy: test timer. \n");
#ifdef CONFIG_BMA150_TIMER
  bma150_report_timer.expires = jiffies + BMA150_REPORT_DELAY_2;
  add_timer(&bma150_report_timer);
#endif 
  return 0;
}
我們可以重新定義 expires 時間 jiffies + BMA150_REPORT_DELAY_2，就可以一直循環了，要離開 Timer 可以在最後加入 deltimer(&bma150_report_timer)，
最後就完成簡易的 Timer 功能。


/***************************************************************************/
如何撰寫Driver支援proc檔案系統
/***************************************************************************/
前言
 在Linux的系統中，通常我們都會有一個目錄 – proc，其實它是一個虛擬的記憶體檔案系統，
 它通常是一個應用程式和kernel直接溝通的一個介面，它是由各個driver所產生，換另一句話就是要Driver有撰寫才會有這樣的功能，
 另外其檔名及內容都是driver自行解決，目前主要都是來設定driver自己本身的一些功能，這樣可以讓驅動程式更多元化，
 或者可以讀取驅動程式現在的情形為何，這可以來維護系統的運作，現在有很多驅動程式已經支援這個功能，
 所以有許多的系統管理程式，也是透過這個介面來管理系統核心。現在我們來介紹如何在driver中撰這些程式碼。
如何啟動這個目錄
 因為它是一個虛擬的記憶體檔案系統，所以將使用Linux系統中管理檔案系統一樣的方法，
 就是使用mount的指令將其掛載在作業系統的檔案系統中，以下為單獨載入的指令：
 > mount –t proc proc /porc
另外在kernel的選項中必須要啟動以下選項：
 
 CONFIG_PROC_FS=y
 CONFIG_PROC_SYSCTL=y
Kernel API
 在介紹如何撰寫前，先來瞭解有那些kernel API可供使用，其所用的include file是，而API如下：
struct proc_dir_entry *create_proc_entry(const char *name, mode_t mode, struct proc_dir_entry *parent)
這是建立一個在相對目錄之下的一個檔名或目錄，其input/output說明如下：
 Input :
  const char *name – 想要建立的檔名，相對於後面的parent的目錄之下，若後面的parent為NULL，則其相對目錄為/proc之下，另外這個檔名也可以包含目錄。
  mode_t mode – 前面所要建立之名稱為檔案或者是目錄，0為檔案，S_IFDIR為目錄。
  struct proc_dir_entry *parent – 這次要建立的檔名或者目錄，其上層的目錄為何，若這個參數為NULL則表示為/proc目錄。
 Output :
  其返回值為一個資料結構的位址point，這個資料結構會在後面介紹，這個point位址將會給予保留，因為我們需要在其中幾個call back欄位填入我們要實現的功能，也就是提供給AP如何溝通的介面。
void remove_proc_entry(const char *name, struct proc_dir_entry *parent);
這是移除已建立的檔案或目錄，其中輸入的參數皆和建立時相同。
以下為一個簡單的範例：
struct proc_dir_entry *MyProcEntry;
MyProcEntry = create_proc_entry(「driver/myproc」, 0, NULL);
MyProcEntry->read = MyProcRead;
MyProcEntry->write = MyProcWrite;
……………………………….
remove_proc_entry(「driver/myproc」, NULL);
資料結構
 如前面所提，其中最重要的資料結構宣告如下：
struct proc_dir_entry {
        unsigned int low_ino;
        unsigned short namelen;
        const char *name;
        mode_t mode;
        nlink_t nlink;
        uid_t uid;
        gid_t gid;
        loff_t size;
        const struct inode_operations *proc_iops;
        /*
         * NULL ->proc_fops means "PDE is going away RSN" or
         * "PDE is just created". In either case, e.g. ->read_proc won't be
         * called because it's too late or too early, respectively.
         *
         * If you're allocating ->proc_fops dynamically, save a pointer
         * somewhere.
         */
        const struct file_operations *proc_fops;
        struct proc_dir_entry *next, *parent, *subdir;
        void *data;
        read_proc_t *read_proc;
        write_proc_t *write_proc;
        atomic_t count;         /* use count */
        int pde_users;  /* number of callers into module in progress */
        spinlock_t pde_unload_lock; /* proc_fops checks and pde_users bumps */
        struct completion *pde_unload_completion;
        struct list_head pde_openers;   /* who did ->open, but not ->release */
};
在這個資料結構中有兩個重要的call back function，一個是read_proc，另一個是write_proc，其實就是寫入及讀出。以下為其簡單的範例：
static int      my_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
{
        char    *out = page;
        int     len;
        dbg_printk("page=0x%p,off=0x%x,count=%d\n", page, off, count);
        out += sprintf(out, "This is a read proc testing.\n");
        dbg_printk("out=0x%p\n", out);
        len = out - page - off;
        dbg_printk("len=%d,out=0x%p\n", len, out);
        if (len < count)  {
                *eof = 1;
                if (len <= 0)
                        return 0;
        }  else
                len = count;
        *start = page + off;
        dbg_printk("start=0x%p\n", start);
        return len;
}
static int      my_write_proc(struct file *file, const char __user *buffer, unsigned long count, void *data)
{
        char    *buf;
        dbg_printk("count=%d\n", count);
        buf = kmalloc(count+1, GFP_KERNEL);
        if ( copy_from_user(buf, (char*)buffer , count) ) {
                kfree(buf);
                return -EFAULT;
        }
        buf[count] = 0;
        dbg_printk("string=%s\n", buf);
        kfree(buf);
        return count;
}
在read call back function中所傳入的page為要存放輸出內容的buffer所在page address，其off為相對於page的offset位置，通常為0，不管read or write其所return的值為實際處理的大小，因為其處理方式為page的方式，所以一次可處理的資料不會大於一個page的大小，現在default值為4096bytes，以上的範例若是成功將可以產生一個虛擬檔案/proc/driver/myproc，你將可以使用簡單的echo & cat來對其做讀寫的動作。


/***************************************************************************/
[Linux] 使用 /proc 文件系統來訪問 Linux 內核的內容  ref: http://www.ibm.com/developerworks/cn/linux/l-proc.html
/***************************************************************************/
/proc 文件系統包含了一些目錄（用作組織資訊的方式）和虛擬文件。
虛擬文件可以向用戶呈現內核中的一些資訊，也可以用作一種從用戶空間向內核發送資訊的手段。
實際上我們並不會同時需要實現這兩點，但是本文將向您展示如何配置這個文件系統進行輸入和輸出。
儘管像本文這樣短小的一篇文章無法詳細介紹 /proc 的所有用法，但是它依然對這兩種用法進行了展示，
從而可以讓我們體會一下 /proc 是多麼強大。

/proc 中另外一些有趣的文件有：
  cpuinfo，它標識了處理器的類型和速度；
  pci，顯示在 PCI 總線上找到的設備；
  modules，標識了當前加載到內核中的模組。

清單 1 是對 /proc 中部分元素進行一次交互查詢的結果。
它顯示的是 /proc 文件系統的根目錄中的內容。
注意，在左邊是一系列數字編號的文件。每個實際上都是一個目錄，表示系統中的一個進程。
由於在 GNU/Linux 中創建的第一個進程是 init 進程，因此它的 process-id 為 1。
然後對這個目錄執行一個 ls 命令，這會顯示很多文件。每個文件都提供了有關這個特殊進程的詳細資訊。
例如，要查看 init 的 command-line 項的內容，只需對 cmdline 文件執行 cat 命令。

清單 1. 對 /proc 的交互過程
[root@plato]# ls /proc
1     2040  2347  2874  474          fb           mdstat      sys
104   2061  2356  2930  9            filesystems  meminfo     sysrq-trigger
113   2073  2375  2933  acpi         fs           misc        sysvipc
1375  21    2409  2934  buddyinfo    ide          modules     tty
1395  2189  2445  2935  bus          interrupts   mounts      uptime
1706  2201  2514  2938  cmdline      iomem        mtrr        version
179   2211  2515  2947  cpuinfo      ioports      net         vmstat
180   2223  2607  3     crypto       irq          partitions
181   2278  2608  3004  devices      kallsyms     pci
182   2291  2609  3008  diskstats    kcore        self
2     2301  263   3056  dma          kmsg         slabinfo
2015  2311  2805  394   driver       loadavg      stat
2019  2337  2821  4     execdomains  locks        swaps
[root@plato 1]# ls /proc/1
auxv     cwd      exe  loginuid  mem     oom_adj    root  statm   task
cmdline  environ  fd   maps      mounts  oom_score  stat  status  wchan
[root@plato]# cat /proc/1/cmdline
init [5]
[root@plato]#

清單 2 展示了對 /proc 中的一個虛擬文件進行讀寫的過程。
這個例子首先檢查內核的 TCP/IP 棧中的 IP 轉發的目前設置，然後再啟用這種功能。

清單 2. 對 /proc 進行讀寫（配置內核）
[root@plato]# cat /proc/sys/net/ipv4/ip_forward
0
[root@plato]# echo "1" > /proc/sys/net/ipv4/ip_forward
[root@plato]# cat /proc/sys/net/ipv4/ip_forward
1
[root@plato]#
另外，我們還可以使用 sysctl 來配置這些內核條目。有關這個問題的更多資訊，請參閱 參考資料 一節的內容。
順便說一下，/proc 文件系統並不是 GNU/Linux 系統中的惟一一個虛擬文件系統。
在這種系統上，sysfs 是一個與 /proc 類似的文件系統，但是它的組織更好（從 /proc 中學習了很多教訓）。
不過 /proc 已經確立了自己的地位，因此即使 sysfs 與 /proc 相比有一些優點，/proc 也依然會存在。
還有一個 debugfs 文件系統，不過（顧名思義）它提供的更多是調試介面。
debugfs 的一個優點是它將一個值導出給用戶空間非常簡單（實際上這不過是一個調用而已）。

內核模組簡介
可加載內核模組（LKM）是用來展示 /proc 文件系統的一種簡單方法，這是因為這是一種用來動態地向 Linux 內核添加或刪除代碼的新方法。
LKM 也是 Linux 內核中為設備驅動程式和文件系統使用的一種流行機制。
如果您曾經重新編譯過 Linux 內核，就可能會發現在內核的配置過程中，有很多設備驅動程式和其他內核元素都被編譯成了模組。
如果一個驅動程式被直接編譯到了內核中，那麼即使這個驅動程式沒有運行，它的代碼和靜態數據也會佔據一部分空間。
但是如果這個驅動程式被編譯成一個模組，就只有在需要記憶體並將其加載到內核時才會真正佔用記憶體空間。
有趣的是，對於 LKM 來說，我們不會注意到有什麼性能方面的差異，因此這對於創建一個適應於自己環境的內核來說是一種功能強大的手段，
這樣可以根據可用硬體和連接的設備來加載對應的模組。
下面是一個簡單的 LKM，可以幫助您理解它與在 Linux 內核中看到的標準（非動態可加載的）代碼之間的區別。
清單 3 給出了一個最簡單的 LKM。（可以從本文的 下載 一節中下載這個代碼）。
清單 3 包括了必須的模組頭（它定義了模組的 API、類型和宏）。然後使用 MODULE_LICENSE 定義了這個模組使用的許可證。
此處，我們定義的是 GPL，從而防止會污染到內核。
清單 3 然後又定義了這個模組的 init 和 cleanup 函數。my_module_init 函數是在加載這個模組時被調用的，它用來進行一些初始化方面的工作。
my_module_cleanup 函數是在卸載這個模組時被調用的，它用來釋放記憶體並清除這個模組的蹤跡。
注意此處 printk 的用法：這是內核的 printf 函數。KERN_INFO 符號是一個字串，可以用來對進入內核迴環緩衝區的資訊進行過濾（非常類似於 syslog）。
最後，清單 3 使用 module_init 和 module_exit 宏聲明了入口函數和出口函數。
這樣我們就可以按照自己的意願來對這個模組的 init 和 cleanup 函數進行命名了，不過我們最終要告訴內核維護函數就是這些函數。

清單 3. 一個簡單的但可以正常工作的 LKM（simple-lkm.c）
#include <linux/module.h>
/* Defines the license for this LKM */
MODULE_LICENSE("GPL");
/* Init function called on module entry */
int my_module_init( void )
{
  printk(KERN_INFO "my_module_init called.  Module is now loaded.\n");
  return 0;
}
/* Cleanup function called on module exit */
void my_module_cleanup( void )
{
  printk(KERN_INFO "my_module_cleanup called.  Module is now unloaded.\n");
  return;
}
/* Declare entry and exit functions */
module_init( my_module_init );
module_exit( my_module_cleanup );

清單 3 儘管非常簡單，但它卻是一個真正的 LKM。現在讓我們對其進行編譯並在一個 2.6 版本的內核上進行測試。
2.6 版本的內核為內核模組的編譯引入了一種新方法，我發現這種方法比原來的方法簡單了很多。
對於文件 simple-lkm.c，我們可以創建一個 makefile，其惟一內容如下：
obj-m += simple-lkm.o
要編譯 LKM，請使用 make 命令，如清單 4 所示。

清單 4. 編譯 LKM
[root@plato]# make -C /usr/src/linux-`uname -r` SUBDIRS=$PWD modules
make: Entering directory `/usr/src/linux-2.6.11'
  CC [M]  /root/projects/misc/module2.6/simple/simple-lkm.o
  Building modules, stage 2.
  MODPOST
  CC      /root/projects/misc/module2.6/simple/simple-lkm.mod.o
  LD [M]  /root/projects/misc/module2.6/simple/simple-lkm.ko
make: Leaving directory `/usr/src/linux-2.6.11'
[root@plato]#

結果會生成一個 simple-lkm.ko 文件。這個新的命名約定可以幫助將這些內核對像（LKM）與標準對像區分開來。
現在可以加載或卸載這個模組了，然後可以查看它的輸出。
要加載這個模組，請使用 insmod 命令；反之，要卸載這個模組，請使用 rmmod 命令。lsmod 可以顯示當前加載的 LKM（參見清單 5）。

清單 5. 插入、檢查和刪除 LKM
[root@plato]# insmod simple-lkm.ko
[root@plato]# lsmod
Module                  Size  Used by
simple_lkm              1536  0
autofs4                26244  0
video                  13956  0
button                  5264  0
battery                 7684  0
ac                      3716  0
yenta_socket           18952  3
rsrc_nonstatic          9472  1 yenta_socket
uhci_hcd               32144  0
i2c_piix4               7824  0
dm_mod                 56468  3
[root@plato]# rmmod simple-lkm
[root@plato]#
注意，內核的輸出進到了內核迴環緩衝區中，而不是列印到 stdout 上，這是因為 stdout 是進程特有的環境。
要查看內核迴環緩衝區中的消息，可以使用 dmesg 工具（或者通過 /proc 本身使用 cat /proc/kmsg 命令）。
清單 6 給出了 dmesg 顯示的最後幾條消息。

清單 6. 查看來自 LKM 的內核輸出
[root@plato]# dmesg | tail -5
cs: IO port probe 0xa00-0xaff: clean.
eth0: Link is down
eth0: Link is up, running at 100Mbit half-duplex
my_module_init called.  Module is now loaded.
my_module_cleanup called.  Module is now unloaded.
[root@plato]#
可以在內核輸出中看到這個模組的消息。現在讓我們暫時離開這個簡單的例子，來看幾個可以用來開發有用 LKM 的內核 API。

集成到 /proc 文件系統中
內核程式員可以使用的標準 API，LKM 程式員也可以使用。LKM 甚至可以導出內核使用的新變數和函數。
有關 API 的完整介紹已經超出了本文的範圍，因此我們在這裡只是簡單地介紹後面在展示一個更有用的 LKM 時所使用的幾個元素。
創建並刪除 /proc 項
要在 /proc 文件系統中創建一個虛擬文件，請使用 create_proc_entry 函數。
這個函數可以接收一個文件名、一組權限和這個文件在 /proc 文件系統中出現的位置。
create_proc_entry 的返回值是一個 proc_dir_entry 指針（或者為 NULL，說明在 create 時發生了錯誤）。
然後就可以使用這個返回的指針來配置這個虛擬文件的其他參數，例如在對該文件執行讀操作時應該調用的函數。
create_proc_entry 的原型和 proc_dir_entry 結構中的一部分如清單 7 所示。

清單 7. 用來管理 /proc 文件系統項的元素
struct proc_dir_entry *create_proc_entry( const char *name, mode_t mode,
                                             struct proc_dir_entry *parent );
struct proc_dir_entry {
        const char *name;                       // virtual file name
        mode_t mode;                            // mode permissions
        uid_t uid;                              // File's user id
        gid_t gid;                              // File's group id
        struct inode_operations *proc_iops;     // Inode operations functions
        struct file_operations *proc_fops;      // File operations functions
        struct proc_dir_entry *parent;          // Parent directory
        ...
        read_proc_t *read_proc;                 // /proc read function
        write_proc_t *write_proc;               // /proc write function
        void *data;                             // Pointer to private data
        atomic_t count;                         // use count
        ...
};
void remove_proc_entry( const char *name, struct proc_dir_entry *parent );

稍後我們就可以看到如何使用 read_proc 和 write_proc 命令來插入對這個虛擬文件進行讀寫的函數。
要從 /proc 中刪除一個文件，可以使用 remove_proc_entry 函數。
要使用這個函數，我們需要提供文件名字串，以及這個文件在 /proc 文件系統中的位置（parent）。這個函數原型如清單 7 所示。
parent 參數可以為 NULL（表示 /proc 根目錄），也可以是很多其他值，這取決於我們希望將這個文件放到什麼地方。
表 1 列出了可以使用的其他一些父 proc_dir_entry，以及它們在這個文件系統中的位置。
表 1. proc_dir_entry 快捷變數
proc_dir_entry  在文件系統中的位置
proc_root_fs    /proc
proc_net        /proc/net
proc_bus        /proc/bus
proc_root_driver        /proc/driver
回調函數
我們可以使用 write_proc 函數向 /proc 中寫入一項。這個函數的原型如下：
int mod_write( struct file *filp, const char __user *buff,
               unsigned long len, void *data );
filp 參數實際上是一個打開文件結構（我們可以忽略這個參數）。buff 參數是傳遞給您的字串數據。
緩衝區地址實際上是一個用戶空間的緩衝區，因此我們不能直接讀取它。len 參數定義了在 buff 中有多少數據要被寫入。
data 參數是一個指向私有數據的指針（參見 清單 7）。在這個模組中，我們聲明了一個這種類型的函數來處理到達的數據。
Linux 提供了一組 API 來在用戶空間和內核空間之間移動數據。對於 write_proc 的情況來說，我們使用了 copy_from_user 函數來維護用戶空間的數據。

讀回調函數
我們可以使用 read_proc 函數從一個 /proc 項中讀取數據（從內核空間到用戶空間）。這個函數的原型如下：
int mod_read( char *page, char **start, off_t off,
              int count, int *eof, void *data );
page 參數是這些數據寫入到的位置，其中 count 定義了可以寫入的最大字元數。
在返回多頁數據（通常一頁是 4KB）時，我們需要使用 start 和 off 參數。當所有數據全部寫入之後，就需要設置 eof（文件結束參數）。
與 write 類似，data 表示的也是私有數據。此處提供的 page 緩衝區在內核空間中。因此，我們可以直接寫入，而不用調用 copy_to_user。

其他有用的函數
我們還可以使用 proc_mkdir、symlinks 以及 proc_symlink 在 /proc 文件系統中創建目錄。
對於只需要一個 read 函數的簡單 /proc 項來說，可以使用 create_proc_read_entry，這會創建一個 /proc 項，
並在一個調用中對 read_proc 函數進行初始化。這些函數的原型如清單 8 所示。

清單 8. 其他有用的 /proc 函數
/* Create a directory in the proc filesystem */
struct proc_dir_entry *proc_mkdir( const char *name,
                                     struct proc_dir_entry *parent );
/* Create a symlink in the proc filesystem */
struct proc_dir_entry *proc_symlink( const char *name,
                                       struct proc_dir_entry *parent,
                                       const char *dest );
/* Create a proc_dir_entry with a read_proc_t in one call */
struct proc_dir_entry *create_proc_read_entry( const char *name,
                                                  mode_t mode,
                                                  struct proc_dir_entry *base,
                                                  read_proc_t *read_proc,
                                                  void *data );
/* Copy buffer to user-space from kernel-space */
unsigned long copy_to_user( void __user *to,
                              const void *from,
                              unsigned long n );
/* Copy buffer to kernel-space from user-space */
unsigned long copy_from_user( void *to,
                                const void __user *from,
                                unsigned long n );
/* Allocate a 'virtually' contiguous block of memory */
void *vmalloc( unsigned long size );
/* Free a vmalloc'd block of memory */
void vfree( void *addr );
/* Export a symbol to the kernel (make it visible to the kernel) */
EXPORT_SYMBOL( symbol );
/* Export all symbols in a file to the kernel (declare before module.h) */
EXPORT_SYMTAB

通過 /proc 文件系統實現財富分發
下面是一個可以支援讀寫的 LKM。這個簡單的程式提供了一個財富甜點分發。
在加載這個模組之後，用戶就可以使用 echo 命令向其中導入文本財富，然後再使用 cat 命令逐一讀出。

清單 9 給出了基本的模組函數和變數。
init 函數（init_fortune_module）負責使用 vmalloc 來為這個點心罐分配空間，然後使用 memset 將其全部清零。
使用所分配並已經清空的 cookie_pot 記憶體，我們在 /proc 中創建了一個 proc_dir_entry 項，並將其稱為 fortune。
當 proc_entry 成功創建之後，對自己的本地變數和 proc_entry 結構進行了初始化。
我們加載了 /proc read 和 write 函數（如清單 9 和清單 10 所示），並確定這個模組的所有者。
cleanup 函數簡單地從 /proc 文件系統中刪除這一項，然後釋放 cookie_pot 所佔據的記憶體。
cookie_pot 是一個固定大小（4KB）的頁，它使用兩個索引進行管理。第一個是 cookie_index，標識了要將下一個 cookie 寫到哪裡去。
變數 next_fortune 標識了下一個 cookie 應該從哪裡讀取以便進行輸出。在所有的 fortune 項都讀取之後，我們簡單地回到了 next_fortune。

清單 9. 模組的 init/cleanup 和變數
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/proc_fs.h>
#include <linux/string.h>
#include <linux/vmalloc.h>
#include <asm/uaccess.h>
MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("Fortune Cookie Kernel Module");
MODULE_AUTHOR("M. Tim Jones");
#define MAX_COOKIE_LENGTH       PAGE_SIZE
static struct proc_dir_entry *proc_entry;
static char *cookie_pot;  // Space for fortune strings
static int cookie_index;  // Index to write next fortune
static int next_fortune;  // Index to read next fortune
int init_fortune_module( void )
{
  int ret = 0;
  cookie_pot = (char *)vmalloc( MAX_COOKIE_LENGTH );
  if (!cookie_pot) {
    ret = -ENOMEM;
  } else {
    memset( cookie_pot, 0, MAX_COOKIE_LENGTH );
    proc_entry = create_proc_entry( "fortune", 0644, NULL );
    if (proc_entry == NULL) {
      ret = -ENOMEM;
      vfree(cookie_pot);
      printk(KERN_INFO "fortune: Couldn't create proc entry\n");
    } else {
      cookie_index = 0;
      next_fortune = 0;
      proc_entry->read_proc = fortune_read;
      proc_entry->write_proc = fortune_write;
      proc_entry->owner = THIS_MODULE;
      printk(KERN_INFO "fortune: Module loaded.\n");
    }
  }
  return ret;
}
void cleanup_fortune_module( void )
{
  remove_proc_entry("fortune", &proc_root);
  vfree(cookie_pot);
  printk(KERN_INFO "fortune: Module unloaded.\n");
}
module_init( init_fortune_module );
module_exit( cleanup_fortune_module );

向這個罐中新寫入一個 cookie 非常簡單（如清單 10 所示）。使用這個寫入 cookie 的長度，我們可以檢查是否有這麼多空間可用。
如果沒有，就返回 -ENOSPC，它會返回給用戶空間。
否則，就說明空間存在，我們使用 copy_from_user 將用戶緩衝區中的數據直接拷貝到 cookie_pot 中。
然後增大 cookie_index（基於用戶緩衝區的長度）並使用 NULL 來結束這個字串。
最後，返回實際寫入 cookie_pot 的字元的個數，它會返回到用戶進程。

清單 10. 對 fortune 進行寫入操作所使用的函數
ssize_t fortune_write( struct file *filp, const char __user *buff,
                        unsigned long len, void *data )
{
  int space_available = (MAX_COOKIE_LENGTH-cookie_index)+1;
  if (len > space_available) {
    printk(KERN_INFO "fortune: cookie pot is full!\n");
    return -ENOSPC;
  }
  if (copy_from_user( &cookie_pot[cookie_index], buff, len )) {
    return -EFAULT;
  }
  cookie_index += len;
  cookie_pot[cookie_index-1] = 0;
  return len;
}

對 fortune 進行讀取也非常簡單，如清單 11 所示。
由於我們剛才寫入數據的緩衝區（page）已經在內核空間中了，因此可以直接對其進行操作，並使用 sprintf 來寫入下一個 fortune。
如果 next_fortune 索引大於 cookie_index（要寫入的下一個位置），那麼我們就將 next_fortune 返回為 0，這是第一個 fortune 的索引。
在將這個 fortune 寫入用戶緩衝區之後，在 next_fortune 索引上增加剛才寫入的 fortune 的長度。
這樣就變成了下一個可用 fortune 的索引。這個 fortune 的長度會被返回並傳遞給用戶。

清單 11. 對 fortune 進行讀取操作所使用的函數
int fortune_read( char *page, char **start, off_t off,
                   int count, int *eof, void *data )
{
  int len;
  if (off > 0) {
    *eof = 1;
    return 0;
  }
  /* Wrap-around */
  if (next_fortune >= cookie_index) next_fortune = 0;
  len = sprintf(page, "%s\n", &cookie_pot[next_fortune]);
  next_fortune += len;
  return len;
}

從這個簡單的例子中，我們可以看出通過 /proc 文件系統與內核進行通信實際上是件非常簡單的事情。
現在讓我們來看一下這個 fortune 模組的用法（參見清單 12）。

清單 12. 展示 fortune cookie LKM 的用法
[root@plato]# insmod fortune.ko
[root@plato]# echo "Success is an individual proposition.  
          Thomas Watson" > /proc/fortune
[root@plato]# echo "If a man does his best, what else is there?  
                Gen. Patton" > /proc/fortune
[root@plato]# echo "Cats: All your base are belong to us.  
                      Zero Wing" > /proc/fortune
[root@plato]# cat /proc/fortune
Success is an individual proposition.  Thomas Watson
[root@plato]# cat /proc/fortune
If a man does his best, what else is there?  General Patton
[root@plato]#
/proc 虛擬文件系統可以廣泛地用來報告內核的資訊，也可以用來進行動態配置。
我們會發現它對於驅動程式和模組編程來說都是非常完整的。
在下面的 參考資料 中，我們可以學習到更多相關知識。


/***************************************************************************/
測試基於linux-2.6.27的9G9260開發板I2C驅動    ref: http://www.61ic.com/MCU/Atmel/AVR/201106/35453.html
/***************************************************************************/
1，找到drivers/i2c/busses/i2c-at91.c文件
root@yuanxh-desktop:/home/yuanxh/sam9260/linux-2.6.27-9g9260# vi drivers/i2c/busses/Makefile
在第28行看到：
obj-$(CONFIG_I2C_AT91) += i2c-at91.o

2， 找到drivers/i2c/busses/Kconfig文件
root@yuanxh-desktop:/home/yuanxh/sam9260/linux-2.6.27-9g9260# vi drivers/i2c/busses/Kconfig
在第259行看到：
config I2C_AT91
tristate "Atmel AT91 I2C Two-Wire interface (TWI)"
depends on ARCH_AT91 && EXPERIMENTAL && BROKEN
help
This supports the use of the I2C interface on Atmel AT91
processors.

This driver is BROKEN because the controller which it uses
will easily trigger RX overrun and TX underrun errors. Using
low I2C clock rates may partially work around those issues
on some systems. Another serious problem is that there is no
documented way to issue repeated START conditions, as needed
to support combined I2C messages. Use the i2c-gpio driver
unless your system can cope with those limitations.
說明AT91 I2C標準驅動不穩定，需要用GPIO模擬！！！

3，編譯配置內核
root@yuanxh-desktop:/home/yuanxh/sam9260/linux-2.6.27-9g9260# make menuconfig
進入配置功能表添加驅動到內核：
Device Drivers --->
<*> I2C support --->
<*> I2C device interface
I2C Hardware Bus support --->
<*> GPIO-based bitbanging I2C

4, 編譯內核生成驅動
root@yuanxh-desktop:/home/yuanxh/sam9260/linux-2.6.27-9g9260# make

5, 查看內核啟動資訊
i2c /dev entries driver
i2c-gpio i2c-gpio: using pins 55 (SDA) and 56 (SCL)
6，查看內核系統資訊
# cat /proc/devices
會看到
Character devices:
...
89 i2c
...

# cat /sys/devices/platform/i2c-gpio/i2c-adapter\:i2c-0/name
i2c-gpio-1
7，建立設備結點
mknod /dev/i2c-0 c 89 0
8，編譯測試代碼
root@yuanxh-desktop:/home/yuanxh/sam9260/i2ctest-1.0-9g9260# arm-linux-gcc -o i2ctest i2ctest.c
root@yuanxh-desktop:/home/yuanxh/sam9260/i2ctest-1.0-9g9260# cp i2ctest /nfsboot/rootfs/app
9，運行測試代碼
# /app/i2ctest
I2C Test version 1.0-9g9260 (yuanxihua@21cn.com) Buile on Jan 5 2009 00:54:45
buf[0x00] = 0x46
...

附件：
//i2ctest.c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <errno.h>
#include <linux/i2c.h>
#include <linux/i2c-dev.h>

#define CHIP_ADDR 0x50 //24C64
#define PAGE_SIZE 32
#define I2C_DEV "/dev/i2c-0"

static int read_eeprom(int fd,char buff[],int addr,int count)
{
    int res;

    if (write(fd,&addr,1)!=1)
    {
        printf("Can't write %s's addr %d\n",I2C_DEV,addr);
        return -1;
    }
    res = read(fd,buff,count);
    printf("read %d bytes at 0x%02x\n\r",res,addr);
    return res;
}
static int write_eeprom(int fd,char buff[],int addr,int count)
{
    int res;
    int i;
    static char sendbuffer[PAGE_SIZE+1];

    memcpy(sendbuffer+1,buff,count);
    sendbuffer[0]=addr;

    res = write(fd,&addr,count+1);
    printf("write %d bytes at 0x%02x\n\r",res,addr);
    return res;
}

int main(void)
{
    int fd,i,res;
    unsigned char buf[PAGE_SIZE];

    printf("I2C Test version 1.0-9g9260 (yuanxihua@21cn.com) Buile on %s %s\n\r",__DATE__,__TIME__);

    fd=open(I2C_DEV,O_RDWR);
    if(fd<0)
    {
        printf("Can't Open %s !!!\n\r",I2C_DEV);
        return -1;
    }

    res = ioctl(fd,I2C_TENBIT,0);
    res = ioctl(fd,I2C_SLAVE,CHIP_ADDR);

    for(i=0;i<sizeof(buf);i++)
    {
        // write_eeprom(fd,buf,i,1);
    }
    for(i=0;i<sizeof(buf);i++)
    {
        read_eeprom (fd,buf+i,i,1);
        printf("buf[0x%02x] = 0x%02x\n\r",i,buf[i]);
    }

    close(fd);
    return 0;
}


/***************************************************************************/
//  撰寫 driver   ref: http://opencsl.openfoundry.org/Lab08_device_driver.rst.html
/***************************************************************************/
reference:
The Linux Kernel Module Programming Guide
http://www.tldp.org/LDP/lkmpg/2.6/html/


/***************************************************************************/
// Libav (原ffmpeg)  from : wiki:    http://zh.wikipedia.org/wiki/FFmpeg
/***************************************************************************/
Libav（舊稱：FFmpeg）是一個自由軟體，可以執行音訊和視訊多種格式的錄影、轉檔、串流功能[1]，包含了libavcodec ─這是一個用於多個專案中音訊和視訊的解碼器函式庫，以及 libavformat ——一個音訊與視訊格式轉換函式庫。
libav的舊稱"FFmpeg"這個單詞中的 "FF" 指的是 "Fast Forward"[2]。有些新手寫信給"FFmpeg"的項目負責人，詢問FF是不是代表「Fast Free」或者「Fast Fourier」等意思，"FFmpeg"的項目負責人回信說「Just for the record, the original meaning of "FF" in FFmpeg is "Fast Forward"...」
這個項目最初是由Fabrice Bellard發起的，而現在是由Michael Niedermayer在進行維護。許多FFmpeg的開發者同時也是MPlayer項目的成員，FFmpeg在MPlayer項目中是被設計為伺服器版本進行開發。
2011年3月13日，FFmpeg 項目新的維護開發組決定 ffmpeg 項目將改名為 libav，網址 http://libav.org ，同時制定了一套關於項目繼續發展和維護的規則。[3][4]
目錄   
1 組成元件
2 參數
2.1 主要參數
2.2 影像參數
2.3 聲音參數
2.4 注意事項
3 範例
4 支援的編碼器、格式和協定
4.1 編碼器
4.2 格式
4.3 協定
5 社區內部問題
6 Libav/FFmpeg版權
7 註釋
8 外部連結

此計劃由幾個元件組成：
ffmpeg          是一個命令列工具，用來對視訊檔案轉換格式，也支援對電視卡即時編碼
ffserver        是一個 HTTP 多媒體即時廣播串流伺服器，支援時光平移
ffplay          是一個簡單的播放器，基於 SDL 與 FFmpeg 函式庫
libavcodec      包含了全部 FFmpeg 音訊／視訊 編解碼函式庫
libavformat     包含 demuxers 和 muxer 函式庫
libavutil       包含一些工具函式庫
libpostproc     對於視訊做前處理的函式庫
libswscale      對於影像作縮放的函式庫

參數
FFmpeg可使用眾多參數，參數內容會根據ffmpeg版本而有差異，使用前建議先參考參數及編解碼器的敘述。
此外，參數明細可用 ffmpeg -h 顯示；編解碼器名稱等明細可用 ffmpeg -formats 顯示。
下列為較常使用的參數。
主要參數
-i 設定輸入檔名。
-f 設定輸出格式。
-y 若輸出檔案已存在時則覆蓋檔案。
-fs 超過指定的檔案大小時則結束轉換。
-ss 從指定時間開始轉換。
-title 設定標題。
-timestamp 設定時間戳。
-vsync 增減Frame使影音同步。
影像參數
-b 設定影像流量，預設為200Kbit/秒。（ 單位請參照下方注意事項 ）
-r 設定FrameRate值，預設為25。
-s 設定畫面的寬與高。
-aspect 設定畫面的比例。
-vn 不處理影像，於僅針對聲音做處理時使用。
-vcodec 設定影像影像編解碼器，未設定時則使用與輸入檔案相同之編解碼器。
聲音參數
-ab 設定每Channel（最近的SVN版為所有Channel的總合）的流量。（ 單位請參照下方注意事項 ）
-ar 設定採樣率。
-ac 設定聲音的Channel數。
-acodec 設定聲音編解碼器，未設定時與影像相同，使用與輸入檔案相同之編解碼器。
-an 不處理聲音，於僅針對影像做處理時使用。
-vol 設定音量大小，256為標準音量。(要設定成兩倍音量時則輸入512，依此類推。)
注意事項
以-b及ab偏好設定流量時，根據使用的ffmpeg版本，須注意單位會有kbits/sec與bits/sec的不同。（可用ffmpeg -h顯示說明來確認單位。）
例如，單位為bits/sec的情況時，欲指定流量64kbps時需輸入『 -ab 64k 』；單位為kbits/sec的情況時則需輸入『 -ab 64 』。
以-acodec及-vcodec所指定的編解碼器名稱，會根據使用的ffmpeg版本而有所不同。例如使用AAC編解碼器時，會有輸入aac與libfaac的情況。
此外，編解碼器有分為僅供解碼時使用與僅供編碼時使用，因此一定要利用ffmpeg -formats確認輸入的編解碼器是否能運作。
[編輯]範例

將MPEG-1影片轉換成MPEG-4格式之範例
ffmpeg -i inputfile.mpg -f mp4 -acodec libfaac -vcodec mpeg4 -b 256k -ab 64k outputfile.mp4
將MP3聲音轉換成MPEG-4格式之範例
ffmpeg -i inputfile.mp3 -f mp4 -acodec libaac -vn -ab 64k outputfile.mp4
將DVD的VOB檔轉換成VideoCD格式的MPEG-1檔之範例
ffmpeg -i inputfile.vob -f mpeg -acodec mp2 -vcodec mpeg1video -s 352x240 -b 1152k -ab 128k outputfile.mpg
將AVI影片轉換成H.264格式的M4V檔之範例
ffmpeg -i inputfile.avi -f mp4　-acodec libfaac -vcodec libx264 -b 512k -ab 320k outputfile.m4v
將任何影片轉換成東芝REGZA可辨識的MPEG2格式之範例
ffmpeg -i inputfile -target ntsc-svcd -ab 128k -aspect 4:3 -s 720x480 outputfile.mpg
連接複數的AVI影片檔之範例（在此範例中須一度暫時將AVI檔轉換成MPEG-1檔(MPEG-1, MPEG-2 PS, DV格式亦可連接)）
ffmpeg -i input1.avi -sameq inputfile_01.mpg
ffmpeg -i input2.avi -sameq inputfile_02.mpg
cat inputfile_01.mpg inputfile_02.mpg > inputfile_all.mpg
ffmpeg -i inputfile_all.mpg -sameq outputfile.avi


/***************************************************************************/
// GCC 命令行詳解
/***************************************************************************/
1。gcc包含的c/c++編譯器
gcc,cc,c++,g++,gcc和cc是一樣的，c++和g++是一樣的，(沒有看太明白前面這半句是什麼意思:))一般c程式就用gcc編譯，c++程式就用g++編譯

2。gcc的基本用法
gcc test.c 這樣將編譯出一個名為a.out的程式
gcc test.c -o test 這樣將編譯出一個名為test的程式，-o參數用來指定生成程式的名字

3。為什麼會出現undefined reference to 'xxxxx'錯誤？
首先這是鏈接錯誤，不是編譯錯誤，也就是說如果只有這個錯誤，說明你的程式源碼本身沒有問題，是你用編譯器編譯時參數用得不對，
你沒有指定鏈接程式要用到得庫，比如你的程式裡用到了一些數學函數，那麼你就要在編譯參數里指定程式要鏈接數學庫，方法是在編譯命令行裡加入-lm。

4。-l參數和-L參數
-l參數就是用來指定程式要鏈接的庫，-l參數緊接著就是庫名，那麼庫名跟真正的庫文件名有什麼關係呢？
就拿數學庫來說，他的庫名是m，他的庫文件名是libm.so，很容易看出，把庫文件名的頭lib和尾.so去掉就是庫名了。
好了現在我們知道怎麼得到庫名了，比如我們自已要用到一個第三方提供的庫名字叫libtest.so，那麼我們只要把libtest.so拷貝到/usr/lib裡，
編譯時加上-ltest參數，我們就能用上libtest.so庫了（當然要用libtest.so庫裡的函數，我們還需要與libtest.so配套的頭文件）。
放在/lib和/usr/lib和/usr/local/lib裡的庫直接用-l參數就能鏈接了，但如果庫文件沒放在這三個目錄裡，而是放在其他目錄裡，
這時我們只用-l參數的話，鏈接還是會出錯，出錯資訊大概是：「/usr/bin/ld: cannot find-lxxx」，也就是鏈接程式ld在那3個目錄裡找不到libxxx.so，
這時另外一個參數-L就派上用場了，比如常用的X11的庫，它放在/usr/X11R6/lib目錄下，我們編譯時就要用-L/usr/X11R6/lib -lX11參數，
-L參數跟著的是庫文件所在的目錄名。再比如我們把libtest.so放在/aaa/bbb/ccc目錄下，那鏈接參數就是-L/aaa/bbb/ccc -ltest
另外，大部分libxxxx.so只是一個鏈接，以RH9為例，比如libm.so它鏈接到/lib/libm.so.x，/lib/libm.so.6又鏈接到/lib/libm-2.3.2.so，
如果沒有這樣的鏈接，還是會出錯，因為ld只會找libxxxx.so，所以如果你要用到xxxx庫，而只有libxxxx.so.x或者libxxxx-x.x.x.so，
做一個鏈接就可以了ln -s libxxxx-x.x.x.so libxxxx.so手工來寫鏈接參數總是很麻煩的，還好很多庫開發包提供了生成鏈接參數的程式，
名字一般叫xxxx-config，一般放在/usr/bin目錄下，比如: gtk1.2的鏈接參數生成程式是gtk-config，執行gtk-config --libs就能得到以下
輸出"-L/usr/lib -L/usr/X11R6/lib -lgtk -lgdk -rdynamic -lgmodule -lglib -ldl -lXi -lXext -lX11 -lm"，
這就是編譯一個gtk1.2程式所需的gtk鏈接參數，xxx-config除了--libs參數外還有一個參數是--cflags用來生成頭文件包含目錄的，
也就是-I參數，在下面我們將會講到。你可以試試執行gtk-config --libs --cflags，看看輸出結果。
現在的問題就是怎樣用這些輸出結果了，最笨的方法就是複製粘貼或者照抄，聰明的辦法是在編譯命令行裡加入這個`xxxx-config --libs --cflags`，
比如編譯一個gtk程式：gcc gtktest.c `gtk-config --libs --cflags`這樣就差不多了。 注意`不是單引號，而是1鍵左邊那個鍵。

除了xxx-config以外，現在新的開發包一般都用pkg-config來生成鏈接參數，使用方法跟xxx-config類似，但xxx-config是針對特定的開發包，
但pkg-config包含很多開發包的鏈接參數的生成，用pkg-config --list-all命令可以列出所支援的所有開發包，pkg-config的用法
就是pkg-config pagName --libs --cflags，其中pagName是包名，是pkg-config--list-all裡列出名單中的一個，比如gtk1.2的名字
就是gtk+，pkg-config gtk+ --libs --cflags的作用跟gtk-config --libs --cflags是一樣的。比如：
gcc gtktest.c `pkg-config gtk+ --libs --cflags` 。

5。-include和-I參數
-include用來包含頭文件，但一般情況下包含頭文件都在源碼裡用#include xxxxxx實現，-include參數很少用。
-I參數是用來指定頭文件目錄，/usr/include目錄一般是不用指定的，gcc知道去那裡找，但是如果頭文件不在/usr/include裡我們就要用-I參數指定了，
比如頭文件放在/myinclude目錄裡，那編譯命令行就要加上-I/myinclude參數了，如果不加你會得到一個"xxxx.h: No such file or directory"的錯誤。
-I參數可以用相對路徑，比如頭文件在當前目錄，可以用-I.來指定。上面我們提到的--cflags參數就是用來生成-I參數的。

6。-O參數
這是一個程式優化參數，一般用-O2就是，用來優化程式用的，比如gcc test.c -O2，優化得到的程式比沒優化的要小，執行速度可能也有所提高（我沒有測試過）。

7。-shared參數
編譯動態庫時要用到，比如gcc -shared test.c -o libtest.so

8。幾個相關的環境變數
PKG_CONFIG_PATH：用來指定pkg-config用到的pc文件的路徑，默認是/usr/lib/pkgconfig，pc文件是文本文件，擴展名是.pc，
裡面定義開發包的安裝路徑，Libs參數和Cflags參數等等。
CC：用來指定c編譯器。
CXX：用來指定cxx編譯器。
LIBS：跟上面的--libs作用差不多。
CFLAGS:跟上面的--cflags作用差不多。
CC，CXX，LIBS，CFLAGS手動編譯時一般用不上，在做configure時有時用到，一般情況
下不用管。
環境變數設定方法：export ENV_NAME=xxxxxxxxxxxxxxxxx

9。關於交叉編譯
交叉編譯通俗地講就是在一種平台上編譯出能運行在體系結構不同的另一種平台上，比如在我們地PC平台(X86 CPU)上編譯出能運行在sparc CPU平台上的程式，
編譯得到的程式在X86 CPU平台上是不能運行的，必須放到sparc CPU平台上才能運行。當然兩個平台用的都是linux。
這種方法在異平台移植和嵌入式開發時用得非常普遍。
相對與交叉編譯，我們平常做的編譯就叫本地編譯，也就是在當前平台編譯，編譯得到的程式也是在本地執行。
用來編譯這種程式的編譯器就叫交叉編譯器，相對來說，用來做本地編譯的就叫本地編譯器，一般用的都是gcc，
但這種gcc跟本地的gcc編譯器是不一樣的，需要在編譯gcc時用特定的configure參數才能得到支援交叉編譯的gcc。
為了不跟本地編譯器混淆，交叉編譯器的名字一般都有前綴，比如sparc-xxxx-linux-gnu-gcc，sparc-xxxx-linux-gnu-g++ 等等

10。交叉編譯器的使用方法
使用方法跟本地的gcc差不多，但有一點特殊的是：必須用-L和-I參數指定編譯器用sparc系統的庫和頭文件，不能用本地(X86)的庫（頭文件有時可以用本地的）。
例子：
sparc-xxxx-linux-gnu-gcc test.c -L/path/to/sparcLib -I/path/to/sparcInclude 


/***************************************************************************/
// 移植是在課程《【應用－模組D2】嵌入式系統專案實作:多媒體系列》   ref: http://tw.myblog.yahoo.com/yh-chiang/article?mid=740&next=584&l=f&fid=7
/***************************************************************************/
目的在 ARM-PXA270 開發板上能夠播放 mp3 音樂檔，我選用移植 madplay。
而編譯 madplay 需要如下檔案： madplay-XX.tar.gz 、 libmad-XX.tar.gz ， libid3tag-XX.tar.gz  及  zlib-XX.tar.gz 。
版本分別是： madplay- 0.15.1 b.tar.gz 、 libmad-0.15.1b.tar.gz 、 libid3tag-0.15.1b.tar.gz ，及 zlib-1.2.3.tar.gz 。
madplay的移植步驟如下：
1、確定編譯環境：
   目前ARM-PXA270教學板用的  Cross-Compiler 可以是 arm-linux-gcc 3.3.2 或 3.4.1 均可。
   同時我將 madplay- 0.15.1 b.tar.gz 、 libmad-0.15.1b.tar.gz 、 libid3tag-0.15.1b.tar.gz ，及 zlib-1.2.3.tar.gz  檔案都放在 /home/modDExam5/wav  目錄下。
2、編譯連結 zlib- 1.2.3
   首先配置其 configure  檔，指令如下：
   ./configure
   待產生 Makefile 檔後，修改此 Makefile 檔將編譯指令均修正加上  arm-linux-  ，存檔後，
   鍵入： make  ，編譯  zlib- 1.2.3  產生  libz.a 。
   到此，編譯連結 zlib- 1.2.3  就算完成了。
3、編譯 libmad
   在完成 zlib- 1.2.3  的編譯後，接著進行 libmad-0.15.1b  的編譯。
   因為希望編譯後的  madplayer  可以單檔執行，所以必須在  configure  加入  disable shared  選項， CC  選項須以  arm-linux-gcc  進行編譯，
   這時需加入  --host=arm-linux 。執行的命令至少如下：  ./configure CC=arm-linux-gcc --host=arm-linux 。
   待產生 Makefile 檔後，鍵入： make  ，編譯  libmad  產生 對應的  lib 。到此，編譯  libmad  就算完成了。
4、編譯 libid3tag
   再來就是進行  libid3tag- 0.15.1 b  的編譯。
   首先還是先以  configure  配置 Makefile ：因為  libid3tag  需要用到 zlib ，所以我們必須加入兩項編譯環境變數：
    CPPFLAGS=-I /home/modDExam5/wav/zlib- 1.2.3  及
    LDFLAGS=-L /home/modDExam5/wav/zlib- 1.2.3 ，當然  CC  還是使用  arm-linux-gcc ，同時也要關閉  shared  。執行的命令至少如下：
    ./configure CC=arm-linux-gcc --host=arm-linux 。
   待產生  Makefile  檔後，再使用： make  編譯  libid3tag  即可。
5、編譯 madplay
   首先還是先以  configure  配置 madplay  的  Makefile ：因為  madplay 需要用到zlib 、 libmad 及 libid3tag ，所以我們必須加入兩項編譯環境變數：
    CPPFLAGS  及  LDFLAGS ，讓 madplay  可以找到上述三種 LIB，當然  CC  還是使用  arm-linux-gcc ， 同時也要關閉  shared  及 啟用  static  項次。
    執行的命令至少如下：
    ./configure CC=arm-linux-gcc --host=arm-linux。
   待產生  Makefile  檔後，再使用： make  編譯  madplay 即可。而產生出來的  madplay 的可執行檔，你就可以上傳至  ARM  板上( PXA270 ) 執行了。

madplay  的執行指令如下：  madplay  mp3檔案，你就會聽到  MP3 歌曲囉。
ps:
管理madplay的主程序，包括play, pause, re-play, stop:
system("madplay north.mp3 &");          // 利用system函數調用madplay播放器播放*.mp3
system("madplay north.mp3 -r &");       // 循環播放：參數 -r
system("killall -9 north.mp3 &");       // 利用system函數調用killall命令將madplay終止
system("killall -STOP north.mp3 &");    // 利用system函數調用killall命令將madplay暫停
system("killall -CONT north.mp3 &");    // 利用system函數調用killall命令恢復madplay播放


/***************************************************************************/
// 簡介 pkg-config 的功能與用法
/***************************************************************************/
當開發C程式時經常使會用到許多系統已安裝的library所提供的function，來加速對程式的開發。在程式中會將含有這些library提供的function宣告的header file加到程式
中，但最頭痛的是在compile程式時加上額外的設定來告訴編譯器該去系統中的何處找尋所要使用的header file以及所使用的library file被安裝在何處。所以Linux系統上有
個非常好用的工具pkg-config可以查詢library的header file以及library的所在位置及資訊，以及在編譯程式時該使用的編譯參數為何。
這個程式主要讀取系統中位於 /usr/lib/pkgconfig 目錄或是環境變數 PKG_CONFIG_PATH 所設定的路徑中的副檔名為 .pc 的檔案，這些檔案包含系統安裝的library的相關資
訊，包括：安裝的目錄、程式編譯的參數等等。
使用方法:
pkg-config --cflags library-name-with-version 就可以得到編譯程式時 pre-processing 動作必須加上的參數設定。
執行 pkg-config --cflags glib-2.0，其結果為-I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include。
pkg-config --libs library-name-with-version就可以得到 linking時所必須傳給編譯器的參數。
執行 pkg-config --libs glib-2.0 得到-lglib-2.0。
另外，我們還可以利用 pkg-config 來簡化 Makefile 的撰寫。
在Makefile中，原來寫在編譯器之後的參數，改成 pkg-config --cflags --libs library-name-with-version 即可。
例如：將Makefile中的這一行
gcc -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include -lglib-2.0 program.c
替換成
gcc pkg-config --cflags --libs glib-2.0 program.c

pkg-config 簡單用法
1. pkg-config --list-all
列出所有可使用的連結庫，位置在 /usr/lib/pkgconfig 及 /usr/local/lib/pkgconfig 裏面的 xxx.pc 檔，新軟體一般都會安裝 .pc 檔，沒有可以自己建立，並且設定環境
變數 PKG_CONFIG_PATH 供 pkg-config 尋找 .pc 檔路徑。
2. pkg-config --cflags xxxx
取得該連結庫的 CFLAGS 參數。(Cflags)
3. pkg-config --libs xxxx
取得該連結庫的 LDFLAGS 參數。(Libs)
4. pkg-config --static xxxx
取得該連結庫供靜態連結的 LDFLAGS 參數。(Libs.private)
5. pkg-config --version
取得 pkg-config 版本號。
6. pkg-config --modversion xxxxx
取得連結庫的版本號。(Version)


/***************************************************************************/
// linux .o,.a,.so文件解析
/***************************************************************************/
linux下文件的類型是不依賴於其後綴名的，但一般來講：
.o,是目標文件,相當於windows中的.obj文件
.so 為共享庫,是shared object,用於動態連接的,和dll差不多
.a為靜態庫,是好多個.o合在一起,用於靜態連接
.la為libtool自動生成的一些共享庫，vi編輯查看，主要記錄了一些配置資訊。可以用如下命令查看*.la文件的格式 $file *.la
*.la: ASCII English text
所以可以用vi來查看其內容。

創建.a庫文件和.o庫文件：
$ pwd
/home/yufei/perl_c2
$ cat mylib.c
#include "stdio.h" 
#include "mylib.h"
void hello()
{
    printf("success call from perl to c library\n");
}
$ cat mylib.h
extern void hello();
$ gcc -c mylib.c
$ dir
mylib.c mylib.h mylib.o
$ ar -r mylib.a mylib.o
ar: 正在創建 mylib.a
$ dir
mylib.a mylib.c mylib.h mylib.o

動態鏈接庫*.so的編譯與使用- -
動態庫*.so在linux下用c和c 編程時經常會碰到，最近在網站找了幾篇文章介紹動態庫的編譯和鏈接，總算搞懂了這個之前一直不太瞭解得東東，這裡做個筆記，也為其它正
為動態庫鏈接庫而苦惱的兄弟們提供一點幫助。
1、動態庫的編譯
下面通過一個例子來介紹如何生成一個動態庫。
這裡有一個頭文件：so_test.h，三個.c文件：test_a.c、test_b.c、test_c.c，我們將這幾個文件編譯成一個動態庫：libtest.so。
so_test.h：
#include 
#include 
void test_a();
void test_b();
void test_c();
test_a.c：
#include "so_test.h"
void test_a()
{
    printf("this is in test_a...\n");
}
test_b.c：
#include "so_test.h"
void test_b()
{
    printf("this is in test_b...\n");
}
test_c.c：
#include "so_test.h"
void test_c()
{
    printf("this is in test_c...\n");
}
將這幾個文件編譯成一個動態庫：libtest.so
$ gcc test_a.c test_b.c test_c.c -fPIC -shared -o libtest.so
2、動態庫的鏈接
在1、中，我們已經成功生成了一個自己的動態鏈接庫libtest.so，下面我們通過一個程式來調用這個庫裡的函數。程式的源文件為：test.c。
test.c：
#include "so_test.h"
int main()
{
    test_a();
    test_b();
    test_c();
    return 0;
}
將test.c與動態庫libtest.so鏈接生成執行文件test：
$ gcc test.c -L. -ltest -o test
測試是否動態連接，如果列出libtest.so，那麼應該是連接正常了
$ ldd test
執行test，可以看到它是如何調用動態庫中的函數的。
3、編譯參數解析
最主要的是GCC命令行的一個選項:
  -shared 該選項指定生成動態連接庫（讓連接器生成T類型的導出符號表，有時候也生成弱連接W類型的導出符號），不用該標誌外部程式無法連接。相當於一個可執行文件
  -fPIC：表示編譯為位置獨立的代碼，不用此選項的話編譯後的代碼是位置相關的所以動態載入時是通過代碼拷貝的方式來滿足不同進程的需要，而不能達到真正代碼段共享的目的。
  -L.：表示要連接的庫在當前目錄中
  -ltest：編譯器查找動態連接庫時有隱含的命名規則，即在給出的名字前面加上lib，後面加上.so來確定庫的名稱
LD_LIBRARY_PATH：這個環境變數指示動態連接器可以裝載動態庫的路徑。
當然如果有root權限的話，可以修改/etc/ld.so.conf文件，然後調用 /sbin/ldconfig來達到同樣的目的，不過如果沒有root權限，那麼只能採用輸出LD_LIBRARY_PATH的方法了。
4、注意
調用動態庫的時候有幾個問題會經常碰到，有時，明明已經將庫的頭文件所在目錄 通過 「-I」 include進來了，庫所在文件通過「-L」參數引導，並指定了「-l」的庫名，
但通過ldd命令察看時，就是死活找不到你指定鏈接的so文件，這時你要作的就是通過修改LD_LIBRARY_PATH或者/etc/ld.so.conf文件來指定動態庫的目錄。通常這樣做就可以
解決庫無法鏈接的問題了。
makefile裡面怎麼正確的編譯和連接生成.so庫文件，然後又是在其他程式的makefile裡面如何編譯和連接才能調用這個庫文件的函數????
答:
你需要告訴動態鏈接器、加載器ld.so在哪裡才能找到這個共享庫,可以設置環境變數把庫的路徑添加到庫目錄/lib和/usr/lib，LD_LIBRARY_PATH=$(pwd),這種方法採用命令行
方法不太方便,一種替代方法
註釋^^^^^^^^^^^^^^^^^^^^^^^^^^^^
LD_LIBRARY_PATH可以在/etc/profile還是 ~/.profile還是 ./bash_profile裡設置，或者.bashrc裡，改完後運行source /etc/profile或 . /etc/profile
更好的辦法是添入/etc/ld.so.conf, 然後執行 /sbin/ldconfig
註釋^^^^^^^^^^^^^^^^^^^^^^^^^^^^
是把庫路徑添加到/etc/ld.so.conf，然後以root身份運行ldconfig
也可以在連接的時候指定文件路徑和名稱 -I -L.
GCC=gcc
CFLAGS=-Wall -ggdb -fPIC
#CFLAGS=
all: libfunc test
libfunc:func.o func1.o
$(GCC) -shared -Wl,-soname,libfunc.so.1 -o libfunc.so.1.1 $
編譯目標文件時使用gcc的-fPIC選項，產生與位置無關的代碼並能被加載到任何地址：
gcc –fPIC –g –c liberr.c –o liberr.o

使用gcc的-shared和-soname選項；
使用gcc的-Wl選項把參數傳遞給連接器ld；
使用gcc的-l選項顯示的連接C庫，以保證可以得到所需的啟動（startup）代碼，從而避免程式在使用不同的，可能不相容版本的C庫的系統上不能啟動執行。
gcc –g –shared –Wl,-soname,liberr.so –o liberr.so.1.0.0 liberr.o –lc

建立相應的符號連接：
ln –s liberr.so.1.0.0 liberr.so.1;
ln –s liberr.so.1.0.0 liberr.so;
在MAKEFILE中：
$@
表示規則中的目標文件集。在模式規則中，如果有多個目標，那麼，"$@"就是匹配於目標中模式定義的集合。
$%

僅當目標是函數庫文件中，表示規則中的目標成員名。例如，如果一個目標是"foo.a(bar.o)"，那麼，"$%"就是"bar.o"，"$@"就是"foo.a"。
如果目標不是函數庫文件（Unix下是[.a]，Windows下是[.lib]），那麼，其值為空。
$
*********************************************註釋***********************************************************************
test: test.o libfunc
$(GCC) -o test test.o -L. -lfunc
%.o:%.c
$(GCC) -c $(CFLAGS) -o $@ $ref:http://niefei.blog.ccidnet.com/blog/ccid/do_showone/tid_42855.html

1. 介紹
使用GNU的工具我們如何在Linux下創建自己的程式函數庫?一個「程式 函數庫」簡單的說就是一個文件包含了一些編譯好的代碼和數據，這些編譯好的代碼和數據可以在事後
供其他的程式使用。程式函數庫可以使整個程式更加模組化，更容易重新編譯，而且更方便升級。程式函數庫可分為3種類型：靜態函數庫（static libraries）、共享函數
庫（shared libraries）和動態加載函數庫（dynamically loadedlibraries）。
靜態函數庫是在程式執行前就加入到目標程式中去了；而共享函數庫則是在程式啟動的時候加載到程式中，它可以被不同的程式共享；動態加載函數庫則可以在程式運行的任
何時候動態的加載。實際上，動態函數庫並非另外一種庫函數格式，區別是動態加載函數庫是如何被程式員使用的。後面我們將舉例說明。
本文檔主要參考Program Library HOWTO，作者是luster（hwang@ustc.edu），任何非商業目的的再次發行本文檔都是允許的，但是請保留作者資訊和本版權聲明。本文檔首
先在www.linuxaid.com.cn發佈。
2. 靜態函數庫
靜態函數庫實際上就是簡單的一個普通的目標文件的集合，一般來說習慣用「.a」作為文件的後綴。可以用ar這個程式來產生靜態函數庫文件。Ar是archiver的縮寫。
靜態函數庫現在已經不在像以前用得那麼多了，主要是共享函數庫與之相比較有很多的優勢的原因。慢慢地，大家都喜歡使用共享函數庫了。不過，在一些場所靜態函數庫仍
然在使用，一來是保持一些與以前某些程式的相容，二來它描述起來也比較簡單。
靜態庫函數允許程式員把程式link起來而不用重新編譯代碼，節省了重新編譯代碼的時間。不過，在今天這麼快速的電腦面前，一般的程式的重新編譯也花費不了多少時間，
所以這個優勢已經不是像它以前那麼明顯了。靜態函數庫對開發者來說還是很有用的，例如你想把自己提供的函數給別人使用，但是又想對函數的源代碼進行保密，你就可以
給別人提供一個靜態函數庫文件。理論上說，使用ELF格式的靜態庫函數生成的代碼可以比使用共享函數庫（或者動態函數庫）的程式運行速度上快一些，大概1－5％。
創建一個靜態函數庫文件，或者往一個已經存在地靜態函數庫文件添加新的目標代碼，可以用下面的命令：
ar rcs my_library.a file1.o file2.o
這個例子中是把目標代碼file1.o和file2.o加入到my_library.a這個函數庫文件中，如果my_library.a不存在，則創建一個新的文件。在用ar命令創建靜態庫函數的時候，還
有其他一些可以選擇的參數，可以參加ar的使用幫助。這裡不再贅述。一旦你創建了一個靜態函數庫，你可以使用它了。你可以把它作為你編譯和連接過程中的一部分用來生
成你的可執行代碼。如果你用gcc來編譯產生可執行代碼的話，你可以用「-l」參數來指定這個庫函數。你也可以用ld來做，使用它的「-l」和「-L」參數選項。具體用法，可
以參考info:gcc。
3. 共享函數庫
共享函數庫中的函數是在當一個可執行程式在啟動的時候被加載。如果一個共享函數庫正常安裝，所有的程式在重新運行的時候都可以自動加載最新的函數庫中的函數。對於
Linux系統還有更多的可以實現的功能：
o 升級了函數庫但是仍然允許程式使用老版本的函數庫。 
o 當執行某個特定程式的時候可以覆蓋某個特定的庫或者庫中指定的函數。 
o 可以在庫函數被使用的過程中修改這些函數庫。
3.1. 一些約定
如果你要編寫的共享函數庫支援所有有用的特性，你在編寫的過程中必須遵循一系列約定。你必須理解庫的不同的名字間的區別，例如它的「soname」和「real name」之間的
區別和它們是如何相互作用的。你同樣還要知道你應該把這些庫函數放在你文件系統的什麼位置等等。下面我們具體看看這些問題。
3.1.1. 共享庫的命名
每個共享函數庫都有個特殊的名字，稱作「soname」。Soname名字命名必須以「lib」作為前綴，然後是函數庫的名字，然後是「.so」，最後是版本號資訊。不過有個特例，
就是非常底層的C庫函數都不是以lib開頭這樣命名的。每個共享函數庫都有一個真正的名字（「real name」），它是包含真正庫函數代碼的文件。真名有一個主版本號，和一
個發行版本號。最後一個發行版本號是可選的，可以沒有。主版本號和發行版本號使你可以知道你到底是安裝了什麼版本的庫函數。另外，還有一個名字是編譯器編譯的時候
需要的函數庫的名字，這個名字就是簡單的soname名字，而不包含任何版本號資訊。
管理共享函數庫的關鍵是區分好這些名字。當可執行程式需要在自己的程式中列出這些他們需要的共享庫函數的時候，它只要用soname就可以了；反過來，當你要創建一個新
的共享函數庫的時候，你要指定一個特定的文件名，其中包含很細節的版本資訊。當你安裝一個新版本的函數庫的時候，你只要先將這些函數庫文件拷貝到一些特定的目錄中
，運行ldconfig這個實用就可以。Ldconfig檢查已經存在的庫文件，然後創建soname的符號鏈接到真正的函數庫，同時設置/etc/ld.so.cache這個緩衝文件。這個我們稍後再
討論。
Ldconfig並不設置鏈接的名字，通常的做法是在安裝過程中完成這個鏈接名字的建立，一般來說這個符號鏈接就簡單的指向最新的soname或者最新版本的函數庫文件。最好把
這個符號鏈接指向soname，因為通常當你升級你的庫函數的後，你就可以自動使用新版本的函數庫了。
我們來舉例看看：
/usr/lib/libreadline.so.3 是一個完全的完整的soname，ldconfig可以設置一個符號鏈接到其他某個真正的函數庫文件，例如是/usr/lib/libreadline.so.3.0。同時還必須
有一個鏈接名字，例如/usr/lib/libreadline.so就是一個符號鏈接指向/usr/lib/libreadline.so.3。
3.1.2. 文件系統中函數庫文件的位置
共享函數庫文件必須放在一些特定的目錄裡，這樣通過系統的環境變數設置，應用程式才能正確的使用這些函數庫。大部分的源碼開發的程式都遵循GNU的一些標準，我們可以
看info幫助文件獲得相信的說明，info資訊的位置是：info: standards #Directory_Variables。GNU標準建議所有的函數庫文件都放在/usr/local/lib目錄下，而且建議命令
可執行程式都放在/usr/local/bin目錄下。這都是一些習慣問題，可以改變的。
文件系統層次化標準FHS（Filesystem Hierarchy Standard）（http://www.pathname.com/fhs）規定了在一個發行包中大部分的函數庫文件應該安裝到/usr/lib目錄 下，但
是如果某些庫是在系統啟動的時候要加載的，則放到/lib目錄下，而那些不是系統本身一部分的庫則放到/usr/local/lib下面。
上面兩個路徑的不同並沒有本質的衝突。GNU提出的標準主要對於開發者開發源碼的，而FHS的建議則是針對發行版本的路徑的。具體的位置資訊可以看/etc/ld.so.conf裡面的
配置資訊。
3.2. 這些函數庫如何使用
在基於GNU glibc的系統裡，包括所有的linux系統，啟動一個ELF格式的二進位可執行文件會自動啟動和運行一個program loader。對於Linux系統，這個loader的名字是
/lib/ld-linux.so.X（X是版本號）。這個loader啟動後，反過來就會load所有的其他本程式要使用的共享函數庫。
到底在哪些目錄裡查找共享函數庫呢？這些定義缺省的是放在/etc/ld.so.conf文件裡面，我們可以修改這個文件，加入我們自己的一些特殊的路徑要求。大多數RedHat系列的
發行包的/etc/ld.so.conf文件裡面不包括/usr/local/lib這個目錄，如果沒有這個目錄的話，我們可以修改/etc/ld.so.conf，自己手動加上這個條目。
如果你想覆蓋某個庫中的一些函數，用自己的函數替換它們，同時保留該庫中其他的函數的話，你可以在/etc/ld.so.preload中加入你想要替換的庫（.o結尾的文件），這些
preloading的庫函數將有優先加載的權利。
當程式啟動的時候搜索所有的目錄顯然會效率很低，於是Linux系統實際上用的是一個高速緩衝的做法。Ldconfig缺省情況下讀出/etc/ld.so.conf相關資訊，然後設置適當地
符號鏈接，然後寫一個cache到/etc/ld.so.cache這個文件中，而這個/etc/ld.so.cache則可以被其他程式有效的使用了。這樣的做法可以大大提高訪問函數庫的速度。這就要
求每次新增加一個動態加載的函數庫的時候，就要運行ldconfig來更新這個cache，如果要刪除某個函數庫，或者某個函數庫的路徑修改了，都要重新運行ldconfig來更新這個
cache。通常的一些包管理器在安裝一個新的函數庫的時候就要運行ldconfig。另外，FreeBSD使用cache的文件不一樣。FreeBSD的ELF cache是/var/run/ld-elf.so.hints，而
a.out的cache責是/var/run/ld.so.hints。它們同樣是通過ldconfig來更新。
3.3. 環境變數
各種各樣的環境變數控制著一些關鍵的過程。例如你可以臨時為你特定的程式的一次執行指定一個不同的函數庫。Linux系統中，通常變數LD_LIBRARY_PATH就是可以用來指定
函數庫查找路徑的，而且這個路徑通常是在查找標準的路徑之前查找。這個是很有用的，特別是在調試一個新的函數庫的時候，或者在特殊的場合使用一個非標準的函數庫的
時候。環境變數LD_PRELOAD列出了所有共享函數庫中需要優先加載的庫文件，功能和/etc/ld.so.preload類似。這些都是有/lib/ld-linux.so這個loader來實現的。值得一提
的是，LD_LIBRARY_PATH可以在大部分的UNIX-linke系統下正常起作用，但是並非所有的系統下都可以使用，例如HP－UX系統下，就是用SHLIB_PATH這個變數，而在AIX下則使
用LIBPATH這個變數。LD_LIBRARY_PATH在開發和調試過程中經常大量使用，但是不應該被一個普通用戶在安裝過程中被安裝程式修改，大家可以去參考 
http://www.visi.com/~barr/ldpath.html ,這裡有一個文檔專門介紹為什麼不使用LD_LIBRARY_PATH這個 變數。
事實上還有更多的環境變數影響著程式的調入過程，它們的名字通常就是以LD_或者RTLD_打頭。大部分這些環境變數的使用的文檔都是不全，通常搞得人頭昏眼花的，如果要
真正弄清楚它們的用法，最好去讀loader的源碼（也就是gcc的一部分）。
允許用戶控制動態鏈接函數庫將涉及到setuid/setgid這個函數如果特殊的功能需要的話。因此，GNUloader通常限制或者忽略用戶對這些變數使用setuid和setgid。如果
loader通過判斷程式的相關環境變數判斷程式的是否使用了setuid或者setgid，如果uid和euid不同，或者gid和egid部一樣，那麼loader就假定程式已經使用了setuid或者
setgid，然後就大大的限制器控制這個老鏈接的權限。如果閱讀GNU glibc的庫函數源碼，就可以清楚地看到這一點，特別的我們可以看elf/rtld.c和
sysdeps/generic/dl-sysdep.c這兩個文件。這就意味著如果你使得uid和gid與euid和egid分別相等，然後調用一個程式，那麼這些變數就可以完全起效。
3.4. 創建一個共享函數庫
現在我們開始學習如何創建一個共享函數庫。其實創建一個共享函數庫非常容易。首先創建object文件，這個文件將加入通過gcc –fPIC參數命令加入到共享函數庫裡面。
PIC的意思是「位置無關代碼」（Position Independent Code）。下面是一個標準的格式：
gcc -shared -Wl,-soname,your_soname -o library_name file_list library_list
下面再給一個例子，它創建兩個object文件（a.o和b.o），然後創建一個包含a.o和b.o的共享函數庫。例子中」-g」和「－Wall」參數不是必須的。
gcc -fPIC -g -c -Wall a.cgcc -fPIC -g -c -Wall b.cgcc -shared -Wl,
-soname,liblusterstuff.so.1 -o liblusterstuff.so.1.0.1 a.o b.o -lc
下面是一些需要注意的地方：
‧不用使用-fomit-frame-pointer這個編譯參數除非你不得不這樣。雖然使用了這個參數獲得的函數庫仍然可以使用，但是這使得調試程式幾乎沒有用，無法跟蹤調試。
‧ 使用-fPIC來產生代碼，而不是-fpic。 ‧ 某些情況下，使用gcc來生成object文件，需要使用「-Wl,-export-dynamic」這個選項參數。通常，動態函數庫的符號表裡面包
含了這些動態的對象的符號。這個選項在創建ELF格式的文件時候，會將所有的符號加入到動態符號表中。可以參考ld的幫助獲得更詳細的說明。
3.5. 安裝和使用共享函數庫
一旦你了一個共享函數庫，你還需要安裝它。其實簡單的方法就是拷貝你的庫文件到指定的標準的目錄（例如/usr/lib），然後運行ldconfig。
如果你沒有權限去做這件事情，例如你不能修改/usr/lib目錄，那麼你就只好通過修改你的環境變數來實現這些函數庫的使用了。首先，你需要創建這些共享函數庫；然後，
設置一些必須得符號鏈接，特別是從soname到真正的函數庫文件的符號鏈接，簡單的方法就是運行ldconfig：ldconfig -n directory_with_shared_libraries
然後你就可以設置你的LD_LIBRARY_PATH這個環境變數，它是一個以逗號分隔的路徑的集合，這個可以用來指明共享函數庫的搜索路徑。例如，使用bash，就可以這樣來啟動一
個程式my_program: LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH my_program
如果你需要的是重載部分函數，則你就需要創建一個包含需要重載的函數的object文件，然後設置LD_PRELOAD環境變數。通常你可以很方便的升級你的函數庫，如果某個API改
變了，創建庫的程式會改變soname。然而，如果一個函數升級了某個函數庫而保持了原來的soname，你可以強行將老版本的函數庫拷貝到某個位置，然後重新命名這個文件
（例如使用原來的名字，然後後面加.orig後綴），然後創建一個小的「wrapper」腳本來設置這個庫函數和相關的東西。例如下面的例子：
#!/bin/sh export LD_LIBRARY_PATH=/usr/local/my_lib:$LD_LIBRARY_PATH exec
/usr/bin/my_program.orig $*
我們可以通過運行ldd來看某個程式使用的共享函數庫。例如你可以看ls這個實用工具使用的函數庫：
ldd /bin/ls
libtermcap.so.2 => /lib/libtermcap.so.2 (0x4001c000)
libc.so.6 => /lib/libc.so.6 (0x40020000)
/lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
通常我麼可以看到一個soname的列表，包括路徑。在所有的情況下，你都至少可以看到兩個庫：
‧ /lib/ld-linux.so.N（N是1或者更大，一般至少2）。這是這個用力加載其他所有的共享庫的庫。
‧ libc.so.N(N應該大於或者等於6)。這是C語言函數庫。
值得一提的是，不要在對你不信任的程式運行ldd命令。在ldd的manual裡面寫得很清楚，ldd是通過設置某些特殊的環境變數（例如，對於ELF對像，設置
LD_TRACE_LOADED_OBJECTS），然後運行這個程式。這樣就有可能使得某地程式可能使得ldd來執行某些意想不到的代碼，而產生不安全的隱患。
3.6. 不相容的函數庫
如果一個新版的函數庫要和老版本的二進位的庫不相容，則soname需要改變。對於C語言，一共有4個基本的理由使得它們在二進位代碼上很難相容：
o. 一個函數的行文改變了，這樣它就可能與最開始的定義不相符合。
o. 輸出的數據項改變了。
o. 某些輸出的函數刪除了。
o. 某些輸出函數的介面改變了。
如果你能避免這些地方，你就可以保持你的函數庫在二進位代碼上的相容，或者說，你可以使得你的程式的應用二進位介面（ABI：Application Binary Interface）上相容。
4. 動態加載的函數庫Dynamically Loaded (DL) Libraries
動態加載的函數庫Dynamically loaded (DL)
libraries是一類函數庫，它可以在程式運行過程中的任何時間加載。它們特別適合在函數中加載一些模組和plugin擴展模組的場合，因為它可以在當程式需要某個plugin模組
時才動態的加載。例如，Pluggable Authentication Modules(PAM)系統就是用動態加載函數庫來使得管理員可以配置和重新配置身份驗證資訊。
Linux系統下，DL函數庫與其他函數庫在格式上沒有特殊的區別，我們前面提到過，它們創建的時候是標準的object格式。主要的區別就是這些函數庫不是在程式鏈接的時候或
者啟動的時候加載，而是通過一個API來打開一個函數庫，尋找符號表，處理錯誤和關閉函數庫。通常C語言環境下，需要包含這個頭文件。
Linux中使用的函數和Solaris中一樣，都是dlpoen（）API。當時不是所有的平台都使用同樣的介面，例如HP-UX使用shl_load()機制，而Windows平台用另外的其他的調用介面
。如果你的目的是使得你的代碼有很強的移植性，你應該使用一些wrapping函數庫，這樣的wrapping函數庫隱藏不同的平台的介面區別。一種方法是使用glibc函數庫中的對動
態加載模組的支援，它使用一些潛在的動態加載函數庫界面使得它們可以誇平台使用。
具體可以參考http://developer.gnome.org/doc/API/glib/glib-dynamic-loading-of-modules.html.
另外一個方法是使用libltdl，是GNU libtool的一部分，可以進一步參考CORBA相關資料。
4.1. dlopen()
dlopen函數打開一個函數庫然後為後面的使用做準備。C語言原形是： void * dlopen(const char *filename, int flag);
如果文件名filename是以「/」開頭，也就是使用絕對路徑，那麼dlopne就直接使用它，而不去查找某些環境變數或者系統設置的函數庫所在的目錄了。否則dlopen（）就會按
照下面的次序查找函數庫文件：
1. 環境變數LD_LIBRARY指明的路徑。 
2. /etc/ld.so.cache中的函數庫列表。 
3. /lib目錄，然後/usr/lib。
不過一些很老的a.out的loader則是採用相反的次序，也就是先查/usr/lib，然後是/lib。
Dlopen()函數中，參數flag的值必須是RTLD_LAZY或者RTLD_NOW，RTLD_LAZY的意思是resolve undefined symbols as code from the dynamic library is executed，
而RTLD_NOW的含義是resolve all undefined symbols before dlopen() returns and fail if this cannot be done'。
如果有好幾個函數庫，它們之間有一些依賴關係的話，例如X依賴Y，那麼你就要先加載那些被依賴的函數。例如先加載Y，然後加載X。
dlopen（）函數的返回值是一個控制碼，然後後面的函數就通過使用這個控制碼來做進一步的操作。如果打開失敗dlopen()就返回一個NULL。如果一個函數庫被多次打開，它
會返回同樣的控制碼。如果一個函數庫裡面有一個輸出的函數名字為_init,那麼_init就會在dlopen（）這個函數返回前被執行。我們可以利用這個函數在我的函數庫裡面做一
些初始化的工作。我們後面會繼續討論這個問題的。
4.2. dlerror()
通過調用dlerror()函數，我們可以獲得最後一次調用dlopen()，dlsym()，或者dlclose（）的錯誤資訊。
4.3. dlsym()
如果你加載了一個DL函數庫而不去使用當然是不可能的了，使用一個DL函數庫的最主要的一個函數就是dlsym()，這個函數在一個已經打開的函數庫裡面查找給定的符號。這個
函數如下定義： void * dlsym(void *handle, char *symbol); 函數中的參數handle就是由dlopen打開後返回的控制碼，symbol是一個以NIL結尾的字串。
如果dlsym()函數沒有找到需要查找的symbol，則返回NULL。如果你知道某個symbol的值不可能是NULL或者0，那麼就很好，你就可以根據這個返回結果判斷查找的symbol是否
存在了；不過，如果某個symbol的值就是NULL，那麼這個判斷就有問題了。標準的判斷方法是先調用dlerror()，清除以前可能存在的錯誤，然後調用dlsym（）來訪問一個
symbol，然後再調用dlerror（）來判斷是否出現了錯誤。一個典型的過程如下：
dlerror(); /* clear error code */
s = (actual_type) dlsym(handle, symbol_being_searched_for);
if ((err = dlerror()) != NULL)
{
    /* handle error, the symbol wasn't found */
}
else
{
    /* symbol found, its value is in s */
}
4.4. dlclose()
dlopen()函數的反過程就是dlclose（）函數，dlclose（）函數用力關閉一個DL函數庫。Dl函數庫維持一個資源利用的計數器，當調用dlclose的時候，就把這個計數器的計數
減一，如果計數器為0，則真正的釋放掉。真正釋放的時候，如果函數庫裡面有_fini()這個函數，則自動調用_fini（）這個函數，做一些必要的處理。Dlclose（）返回0表示
成功，其他非0值表示錯誤。
4.5. DL Library Example
下面是一個例子。例子中調入math函數庫，然後列印2.0的余弦函數值。例子中每次都檢查是否出錯。應該是個不錯的範例：
#include
#include
#include
int main(int argc, char **argv)
{
    void *handle;
    double (*cosine)(double);
    char *error;
    handle = dlopen ("/lib/libm.so.6", RTLD_LAZY);
    if (!handle) 
    {
        fputs (dlerror(), stderr);
        exit(1);
    }
    cosine = dlsym(handle, "cos");
    if ((error = dlerror()) != NULL)
    {
        fputs(error, stderr);
        exit(1);
    }
    printf ("%f ", (*cosine)(2.0));
    dlclose(handle);
}
如果這個程式名字叫foo.c,那麼用下面的命令來編譯：
gcc -o foo foo.c -ldl
5. 其他
5.1. nm命令
nm命令可以列出一個函數庫文件中的符號表。它對於靜態的函數庫和共享的函數庫都起作用。對於一個給定的函數庫，nm命令可以列出函數庫中定義的所有符號，包括每個符
號的值和類型。還可以給出在原程式中這個函數（符號）是在多少行定義的，不過這必須要求編譯該函數庫的時候加「-l」選項。
關於符號的類型，這裡我們再多討論一下。符號的類型是以一個字母的形式顯示的，小寫字母表示這個符號是本地（local）的，而大寫字母則表示這個符號是全局的
（global,externel）。一般來說，類型有一下幾種：T、D、B、U、W。各自的含義如下：T表示在代碼段中定義的一般變數符號；D表示時初始化過的數據段；B表示初始化的數
據段；U表示沒有定義的，在這個庫裡面使用了，但是在其他庫中定義的符號；W，weak的縮寫，表示如果其他函數庫中也有對這個符號的定義，則其他符號的定義可以覆蓋這
個定義。如果你知道一個函數的名字，但是你不知道這個函數在什麼庫中定義的，那麼可以用mn的「-o」選項和grep命令來查找庫的名字。-o選項使得顯示的每一行都有這個
函數庫文件名。例如，你要查找「cos」這個是在什麼地方定義的，大致可以用下面的命令： 
nm -o /lib/* /usr/lib/* /usr/lib/*/* /usr/local/lib/* 2> /dev/null | grep 'cos$'
關於nm的更詳細的用法我們可以參考info文檔，位置是info:binutils#nm。
5.2. 特殊函數_init和_fini
函數庫裡面有兩個特殊的函數，_init和_fini，這個我們在前面已經說過了。主要是分別用來初始化函數庫和關閉的時候做一些必要的處理，我們可以把自己認為需要的代碼
放到這兩個函數里面，它們分別在函數庫被加載和釋放的時候被執行。具體說，如果一個函數庫裡面有一個名字為「_init」的函數輸出，那麼在第一次通過dlopen()函數打開
這個函數庫，或者只是簡單的作為共享函數庫被打開的時候，_init函數被自動調用執行。與之相對應的就是_fini函數，當一個程式調用dlclose()去釋放對這個函數庫的引用
的時候，如果該函數庫的被引用計數器為0了，或者這個函數庫是作為一般的共享函數庫被使用而使用它的程式正常退出的時候，_fini就會被調用執行。C語言定義它們的原型
如下：void _init(void); void _fini(void); 當用gcc編譯源程式為「.o」文件的時候，需要加一個「-nostartfiles」選項。這個選項使得C編譯器不鏈接系統的啟動函數庫
裡面的啟動函數。否則，就會得到一個「multiple-definition」的錯誤。
5.3. 共享函數庫也可以使腳本（Scripts）
GNU的loader允許使用特殊格式的腳本語言來寫一個函數庫。這對於那些需要間接包含其他函數庫的情況還是有用的。例如，下面是一個/usr/lib/libc.so的例子：
/* GNU ld script Use the shared library, but some functions are only in the static library, so try that secondarily. */
GROUP ( /lib/libc.so.6 /usr/lib/libc_nonshared.a )
更多的資訊可以參考texinfo文檔中關於ld鏈接的腳本部分。一般的資訊還可以參考: info:ld#Options 和info:ld#Commands，也可以參考info:ld#Option Commands。
5.4. GNU libtool
如果你正在編譯的系統相很方便的移植到其他作業系統下，你可以使用GNU libtool來創建和安裝這個函數庫。GNU libtool是一個函數庫支援的典型的腳本。Libtool隱藏了使
用一個可移植的函數庫的負責性。Libtool提供了一個可以移植的界面來創建object文件，鏈接函數庫（靜態或者共享的），並且安裝這些庫。它還包含了libltdl，一個可移
植的動態函數庫調入程式的wrapper。更多的詳細討論，可以在http://www.gnu.org/software/libtool/manual.html看到。
5.5. 刪除一些符號
在一個生產的文件中很多符號都是為了debug而包含的，佔用了不少空間。如果空間不夠，而且這些符號也許不再需要，就可以將其中一些刪除。
最好的方法就是先正常的生成你需要的object文件，然後debug和測試你需要的一些東西。一旦你完全測試完畢了，就可以用strip去刪除一些不需要的符號了。Strip命令可以
使你很方便的控制刪除什麼符號，而保留什麼符號。Strip的具體用法可以參考其幫助文件。另外的方法就是使用GNU ld的選項「-S」和「-s」;「-S」會刪除一些debugger的
符號，而「-s」則是將所有的符號資訊都刪除。通常我們可以在gcc中加這樣的參數「-Wl,-S」和「-Wl,-s」來達到這個目的。摘要下面是一些例子，例子中我們會使用三種函
數庫（靜態的、共享的和動態加載的函數庫）。文件libhello.c是一個函數庫，libhello.h是它的頭文件；demo_use.c則是一個使用了libhello函數庫的。Script_static和
script_dynamic分別演示如何以靜態和共享方式使用函數庫，而後面的demo_dynamic.c和script_dynamic則表示演示如何以動態加載函數庫的方式來使用它。
6. 更多的例子
下面是一些例子，例子中我們會使用三種函數庫（靜態的、共享的和動態加載的函數庫）。文件libhello.c是一個函數庫，libhello.h是它的頭文件；demo_use.c則是一個使
用了libhello函數庫的。Script_static和script_dynamic分別演示如何以靜態和共享方式使用函數庫，而後面的demo_dynamic.c和script_dynamic則表示演示如何以動態加載
函數庫的方式來使用它。
6.1. File libhello.c
/* libhello.c - demonstrate library use. */
#include
void hello(void)
{
    printf("Hello, library world.");
}
6.2. File libhello.h
/* libhello.h - demonstrate library use. */
void hello(void);
6.3. File demo_use.c
/* demo_use.c -- demonstrate direct use of the "hello" routine */
#include "libhello.h"
int main(void)
{
    hello();
    return 0;
}
6.4. File script_static
#!/bin/sh
# Static library demo
# Create static library's object file, libhello-static.o.
# I'm using the name libhello-static to clearly differentiate the static library 
# from the dynamic library examples, but you don't need to use "-static" in the 
# names of your object files or static libraries.gcc -Wall -g -c -o libhello-static.o libhello.c
# Create static library.ar rcs libhello-static.a libhello-static.o
# At this point we could just copy libhello-static.a somewhere else to use it.
# For demo purposes, we'll just keep the library in the current directory.
# Compile demo_use program file.gcc -Wall -g -c demo_use.c -o demo_use.o
# Create demo_use program; -L. causes "." to be searched during creation of the program. 
# Note that this command causes the relevant object file in libhello-static.a to be
# incorporated into file demo_use_static.gcc -g -o demo_use_static demo_use.o -L. -lhello-static
# Execute the program../demo_use_static
6.5. File script_shared
#!/bin/sh
# Shared library demo
# Create shared library's object file, libhello.o.gcc -fPIC -Wall -g -c libhello.c
# Create shared library.
# Use -lc to link it against C library, since libhello
# depends on the C library.gcc -g -shared -Wl,-soname,libhello.so.0 -o libhello.so.0.0 libhello.o -lc# At this point we could just copy libhello.so.0.0 into
# some directory, say /usr/local/lib.
# Now we need to call ldconfig to fix up the symbolic links.
# Set up the soname. We could just execute:
# ln -sf libhello.so.0.0 libhello.so.0
# but let's let ldconfig figure it out./sbin/ldconfig -n .
# Set up the linker name.
# In a more sophisticated setting, we'd need to make
# sure that if there was an existing linker name,
# and if so, check if it should stay or not.ln -sf libhello.so.0 libhello.so
# Compile demo_use program file.gcc -Wall -g -c demo_use.c -o demo_use.o
# Create program demo_use.
# The -L. causes "." to be searched during creation
# of the program; note that this does NOT mean that "."
# will be searched when the program is executed.gcc -g -o demo_use demo_use.o -L. -lhello
# Execute the program. Note that we need to tell the program
# where the shared library is, using LD_LIBRARY_PATH.LD_LIBRARY_PATH="." ./demo_use
6.6. File demo_dynamic.c
/* demo_dynamic.c -- demonstrate dynamic loading and use of the "hello" routine */
/* Need dlfcn.h for the routines to dynamically load libraries */
#include
#include
#include
/* Note that we don't have to include "libhello.h". However, we do need to specify something related;
we need to specify a type that will hold the value we're going to get from dlsym(). */
/* The type "simple_demo_function" describes a function that takes no arguments, and returns no value: */
typedef void (*simple_demo_function)(void);
int main(void)
{
    const char *error;
    void *module;
    simple_demo_function demo_function;
    /* Load dynamically loaded library */
    module = dlopen("libhello.so", RTLD_LAZY);
    if (!module)
    {
        fprintf(stderr, "Couldn't open libhello.so: %s",dlerror());
        exit(1);
    }
    /* Get symbol */
    dlerror();
    demo_function = dlsym(module, "hello");
    if ((error = dlerror()))
    {
        fprintf(stderr, "Couldn't find hello: %s
        ", error);
        exit(1);
    }
    /* Now call the function in the DL library */
    (*demo_function)();
    /* All done, close things cleanly */
    dlclose(module);
    return 0;
}
6.7. File script_dynamic
#!/bin/sh
# Dynamically loaded library demo
# Presume that libhello.so and friends have
# been created (see dynamic example).
# Compile demo_dynamic program file into an object file.gcc -Wall -g -c demo_dynamic.c
# Create program demo_use.
# Note that we don't have to tell it where to search for DL libraries,
# since the only special library this program uses won't be
# loaded until after the program starts up.
# However, we DO need the option -ldl to include the library
# that loads the DL libraries.gcc -g -o demo_dynamic demo_dynamic.o -ldl
# Execute the program. Note that we need to tell the
# program where get the dynamically loaded library,
# using LD_LIBRARY_PATH.LD_LIBRARY_PATH="." ./demo_dynamic


/***************************************************************************/
// checking host system type... Invalid configuration
/***************************************************************************/
checking host system type... Invalid configuration `x86_64-unknown-linux-gnu': machine `x86_64-unknown' not recognized 

在做 configure 的時候，報上述的錯誤。 
解決方案： 
把 /usr/share/libtool/config.guess 覆蓋到相關軟體自帶的config.guess 
把 /usr/share/libtool/config.sub 覆蓋到相關軟體自帶的config.sub 
./configure --enable-shared --enable-static  


/***************************************************************************/
// Gentoo Linux USB指南
/***************************************************************************/
1.  簡介
USB是什麼?
USB的意思是通用串行總線(Universal Serial Bus)，是一種擴展介面標準，主要用於不同電腦或其周邊設備之間的通信。
一些大眾化的USB設備有鍵盤、滑鼠、U盤、數碼相機、CD和DVD外接讀寫器、印表機等。
目前USB標準有兩種版本：USB 1.1 與USB 2.0。由於USB的前一版總是向後相容的，所以USB 2.0相容USB 1.1。最新的USB設備通常都是支援USB 2.0。USB 2.0支援的最大數據
傳輸速率為480 MBps與60 MBps，這分別是USB 2.0與其所相容的USB 1.1的數據傳輸速率。USB還具有支援設備熱插拔的優點，這意味著不必重啟系統即可使用USB設備。
技術剖析
在進行內核有關USB配置之前，先來瞭解一下它的一些知識細節。如果沒有多少時間或者不想閱讀這一節，可直接閱讀配置內核一節。
USB系統有一個主控制器(host controller)，一些集線器(hub)（不是網路工具中的那個「集線器」）以及一個 根集線器(root hub)，根集線器所能連接的USB設備的上限是
127個。主控制器只是USB設備與作業系統之間的硬體介面。
目前有兩種主控制器介面(HCI, Host Controller Interface)：
Compaq的OHCI (Open HCI)，Intel的UHCI (Universal HCI)和EHCI (Enhanced HCI)。OHCI/UHCI是針對USB 1.1的工業標準，而EHCI是針對USB 2.0的。
硬體商向程式員提供開發介面，即所謂的HCD (Host Controller Device)。通過HCD，USB設備可以與系統軟體進行交互，看下面的圖示會更易於理解這一點。
代碼 1.1: USB一般體系結構
(軟體層還有設備驅動之類的成份構成，但出於簡化問題的目的，在此略去)
    + ----    硬體    ----   + ----    軟體    ---- +
    |                        |                      |
    | [USB Dev] -+-> {EHCI} -+--->  ( EHCD )        |
    |            |           |                      |  用戶
    |            `-> {UHCI} -+--->  ( UHCD )        |
    |                        |                      |
    + ----    硬體    ----   + ----    軟體    ---- +
USB設備可以有單獨的驅動程式，也可以使用系統提供的驅動程式，這依賴於設備的類別。也就是說，如果一個USB設備屬於某種類別，那麼其他屬於該類別的設備就可以使用
同一種設備驅動。在USB設備類別中有一些是USB HID (Human Interface Device)類別，它包括：輸入設備，如鍵盤、滑鼠；USB塊存儲設備，比如U盤、數碼相機、音頻播放
器等；USB CDC (Communication Devices Class，通信設備類別)，比如USB口的modem或其他類似設備。
你的機器上有什麼?
要想弄清楚你的機器是否支援USB 2.0是很簡單的，可以使用lspci來查看。
注意: lspci工具是sys-apps/pciutils包的一部分，如果未有安裝該套裝軟體，請emerge pciutils。要注意的是，必須是root用戶才有權限執行lspci命令。
代碼 1.2: lspci的輸出
(系統是相容USB 1.1的，即UHCI介面)
# lspci -v | grep USB
0000:00:04.2 USB Controller: Intel Corp. 82371AB/EB/MB PIIX4 USB (rev 01) (prog-if 00 [UHCI])
(A system that is USB 2.0 compliant, note the EHCI and UHCI)
00:1d.0 USB Controller: Intel Corp. 82801DB USB (Hub #1) (rev 01) (prog-if 00 [UHCI])
00:1d.1 USB Controller: Intel Corp. 82801DB USB (Hub #2) (rev 01) (prog-if 00 [UHCI])
00:1d.2 USB Controller: Intel Corp. 82801DB USB (Hub #3) (rev 01) (prog-if 00 [UHCI])
00:1d.7 USB Controller: Intel Corp. 82801DB USB EHCI Controller (rev 01) (prog-if 20 [EHCI])
使用lspci，可以搞清楚系統是否支援USB 2.0，這在配置內核編譯選項時有用。
2.  配置內核
獲得內核
首先emerge你所要使用的內核源碼，這裡所使用的是gentoo-sources。關於Portage中其它的內核源碼說明，請參考Gentoo Linux Kernel Guide。
代碼 2.1: 獲取內核源碼
# emerge gentoo-sources
現在開始配置內核。
代碼 2.2: 準備配置
# cd /usr/src/linux
# make menuconfig
注意: 上例假定/usr/src/linux是一個符號連接，指向你要使用的內核源碼目錄。在進行內核配置之前，你要保證有這樣的連接。
內核配置選項
現在來看一下需要啟用哪些內核選項以確保我們的硬體能夠得到正確的 USB 支援。
注意: 本文檔示例只針對一些基本的USB支援，當然這也是大多數人所需要的，譬如USB塊存儲設備（數碼相機與U盤驅動）。若對一些特殊的USB設備進行配置，請參考設備的用戶手冊，或者在網上搜索一下內核是否已經實現了對這些設備的支援，再或者使用你所能找到的對應驅動程式。請注意，本文為了簡化問題，所有的示例配置都是編譯到內核中去的，如果你希望使用內核的模組機制，在確認要編譯哪些模組時，相應地調整一下內核配置文件。
代碼 2.3: make menuconfig選項
Device Drivers  --->
  SCSI device support  --->
(儘管在選擇USB Mass Storage時會自動啟用SCSI支援，也必需啟用disk支援)
---   SCSI support type (disk, tape, CD-ROM)
<*>   SCSI disk support
(然後返回上一層，進入USB support)
USB support  --->
(這是根集線器(Root Hub)，對於USB支援而言是必須的。如果你想把它編譯成模組，那麼它就叫做usbcore)
<*> Support for Host-side USB
(至少要選擇一個HCD。如果你不能確定，就都選上好了)
--- USB Host Controller Drivers
<*> EHCI HCD (USB 2.0) support
< > OHCI HCD support
<*> UHCI HCD (most Intel and VIA) support
(向下移動一下，就可以看到CDC和mass storage的配置選項了)
< > USB Modem (CDC ACM) support
<*> USB Printer support
<*> USB Mass Storage support
(如果你有USB網卡，比如RTL8150，應當開啟這個選項)
USB Network Adapters  --->
    <*> USB RTL8150 based ethernet device support (EXPERIMENTAL)
(如果你有串口-USB轉接器，譬如Prolific 2303，你需要開啟這一選項)
USB Serial Converter support  --->
    <*> USB Serial Converter support
    <*> USB Prolific 2303 Single Port Serial Driver (NEW)
如果你擁有 USB 主板、滑鼠、控制桿或者其它類型的輸入設備，則有必要啟用 HID 支援。請閱讀「設備驅動」一節，並像下面這樣啟用 HID：
代碼 2.4: Enabling HID support
Device Drivers --->
  [*] HID Devices  --->
    <*>   USB Human Interface Device (full HID) support
內核選項已經配置完畢，你可以（重新）編譯內核，然後使用新內核重啟機器就可以實現對USB設備的支援了。
現在你可以向下閱讀查看USB設備工作狀況，查看是否設備是否正常工作。
3.  查看USB設備工作狀況
dmesg是你的朋友！
現在終於到了與USB設備共舞的時刻了:) 在本章中，將會看到系統如何響應各種USB設備的。先從一個512M的U盤的插入開始，你也可以使用其他類似設備。
我們主要是使用dmesg來查看U盤插入後發生了什麼以及系統如何響應的。
注意: dmesg在顯示我們所需要的資訊之前會輸出大量的冗余資訊，因為它要讀取內核的環緩衝區(ring buffer)，會輸出許多啟動資訊。
下面示例中的輸出資訊只給出了一部分資訊，為了更好的閱讀，還添加了一些空行。使用dmesg | more或dmesg | less來查看輸出資訊會更好一些。
代碼 3.1: 記憶棒的dmesg輸出
(先將U盤插入可用的USB連接埠，然後...)
# dmesg | less
(當前設備被識別為USB 1.1並為之分配一個地址。這也能說明哪一種HCD正在被使用)
usb 1-1: new full speed USB device using uhci_hcd and address 2
(SCSI模擬器會自動載入)
scsi0 : SCSI emulation for USB Mass Storage devices
usb-storage: device found at 2
(現在設備資訊，包括模組號，都可以被檢索到)
usb-storage: waiting for device to settle before scanning
  Vendor: JetFlash  Model: TS512MJF2A        Rev: 1.00
  Type:   Direct-Access                      ANSI SCSI revision: 02
SCSI device sda: 1003600 512-byte hdwr sectors (514 MB)
(寫保護語句是未來新版本內核的試驗性代碼)
sda: Write Protect is off
sda: Mode Sense: 0b 00 00 08
sda: assuming drive cache: write through
SCSI device sda: 1003600 512-byte hdwr sectors (514 MB)
/dev/scsi/host0/bus0/target0/lun0: p1
Attached scsi removable disk sda at scsi0, channel 0, id 0, lun 0
Attached scsi generic sg0 at scsi0, channel 0, id 0, lun 0,  type 0
usb-storage: device scan complete
(在此，設備通常可以通過掛載/dev/sda1來訪問)
(當設備斷開連接時，系統會給出這樣的反饋資訊)
usb 1-1: USB disconnect, address 2
一旦設備連接上並被掛載，就可以像普通硬碟那樣訪問了。一些大眾化的操作，譬如cp，mv，rm之類，都可以正常執行。也可以在U盤上創建文件系統。
代碼 3.2: 訪問U盤
# mount /dev/sda1 /mnt/usb
# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/hda8             9.4G  7.5G  1.9G  80% /
/dev/hda9              11G  8.1G  2.4G  78% /usr
none                  189M     0  189M   0% /dev/shm
/dev/sda1             490M   34M  457M   7% /mnt/usb
注意: 也可以像U盤那樣訪問數碼相機。我曾有一個Nikon Coolpix 5200，我正是採用這種方式訪問它的。數碼相機中的圖片通常有兩種面向電腦的傳輸模式：
USB塊存儲與PTP (Picture Transfer Protocol)。相機要是被設置為USB塊存儲模式，就如同上面所講的U盤訪問過程一樣，但是也要注意這並非放之四海皆准的。
對於USB滑鼠又是怎樣一種情況呢？它應當被顯示為一種HID設備。
代碼 3.3: USB光電滑鼠
# dmesg | grep USB
drivers/usb/input/hid-core.c: v2.0:USB HID core driver
usb 1-1: new low speed USB device using address 2
input: USB HID v1.10 Mouse [Logitech USB-PS/2 Optical Mouse] on usb-0000:00:07.2-1
另外一個時髦的命令lsusb可以查看你的USB連接埠。這個命令是sys-apps/usbutils套裝軟體的一部分，下一章會介紹該套裝軟體。
4.  用戶級的USB
時髦的工具
內核/系統對USB的支援已經見識得很多了。現在，我們將看看由Gentoo為USB提供的用戶級支援。
一個非常有用的工具是lsusb，它可以列出所有連接到系統的USB設備，而且它的安裝也非常easy。
代碼 4.1: 安裝usbutils
# emerge usbutils
安裝完後，可以運行lsusb獲得連接到機器上的USB設備的一些簡要資訊。
注意: 通常你必須以根用戶身份運行lsusb。
警告: lsusb從/proc/bus/usb中讀取USB設備資訊，如果你在編譯內核時沒有進行相應配置，那麼lsusb就無法工作了。
      所以，一定要確認你的內核配置啟用了/proc文件系統支援，並且保證usbfs是掛載在/proc/bus/usb上的（默認就是如此）。
代碼 4.2: 執行lsusb
# lsusb
(This is the 512 MB Memory Stick from Transcend)
Bus 001 Device 003: ID 0c76:0005 JMTek, LLC. USBdisk
(This is the Optical Mouse)
Bus 001 Device 002: ID 046d:c00e Logitech, Inc. Optical Mouse
(This is the root hub)
Bus 001 Device 001: ID 0000:0000
如果你喜歡看大量的輸出資訊，運行lsusb -v就可以滿足你的這一慾望。lsusb另一個有用的選項是給出當前USB物理層次的樹狀資訊，這可以更容易讓你準確理解設備體
系結構，這個命令就是lsusb -t，例如：
代碼 4.3: lsusb顯示USB物理層
# lsusb -t
Bus#  1
--Dev#   1 Vendor 0x0000 Product 0x0000
|-Dev#   2 Vendor 0x046d Product 0xc00e
--Dev#   3 Vendor 0x0c76 Product 0x0005
可以很容易地將lsusb與lsusb -t的輸出資訊聯繫起來，這有助於調試與理解USB的工作機制。


/***************************************************************************/
// ERROR: OAFIID:GNOME:NotificationAreaApplet
/***************************************************************************/
Ubuntu開機後，面板出現「OAFIID:GNOME:NotificationAreaApplet」錯誤--解決方法
今天一早開機載入面板時，出現了「OAFIID:GNOME:NotificationAreaApplet」錯誤，問我是否要刪除， 
而且上方面板的gcin等少數幾個小圖示沒出現。 
===>不要刪除喔！  
到網路搜尋一下解決方法如下： 
到「系統」/「管理」/「Synaptic套件管理程式」 
1.搜尋 libindicate-gtk2 ，按右鍵，標記為重新安裝 
2.搜尋 perlpanel ，按右鍵，標記為安裝 
等以上都裝好了，登出再登入即正常了


/***************************************************************************/
ushare 交叉編譯         from: http://blog.163.com/kivi0806@126/blog/static/87931241200912354020721/
/***************************************************************************/
差不多編了兩個星期的ushare-1.1a ，今天終於完工。現在將個人的安裝步驟貼出來，希望自己以後有個參考，也希望能幫到進行交叉編譯ushare的人。
如果有不足的或者有誤的地方，也希望能得到大家的指點。
環境：arm9
1.支援mp3 （即lame）
# cd lame-*
export PATH=/usr/local/920t_le/arm-linux/bin:$PATH 
#CC=/usr/local/920t_le/bin/arm_920t_le-gcc CPP=/usr/local/920t_le/bin/arm_920t_le-cpp CXX=/usr/local/920t_le/bin/arm_920t_le-g++ AR=/usr/local/920t_le/bin/arm_920t_le-ar ./configure --host=arm-920t_le-linux --prefix=/usr/local/920t_le/sysroot --enable-shared
#make
#make install

2.支援Xvid和x264
# cd x264-*
export PATH=/usr/local/920t_le/arm-linux/bin:$PATH 
CC=/usr/local/920t_le/bin/arm_920t_le-gcc  CPP=/usr/local/920t_le/bin/arm_920t_le-cpp CXX=/usr/local/920t_le/bin/arm_920t_le-g++ ./configure --host=arm-920t_le-linux --prefix=/usr /local/920t_le/sysroot  --enable-shared
#make 
#make install
#cd xvidcore-*/build/generic
export PATH=/usr/local/920t_le/arm-linux/bin:$PATH 
#CC=/usr/local/920t_le/bin/arm_920t_le-gcc CPP=/usr/local/920t_le/bin/arm_920t_le-cpp CXX=/usr/local/920t_le/bin/arm_920t_le-g++ ./configure --host=arm-920t_le-linux --prefix=/usr /local/920t_le/sysroot   --enable-shared
#make
#make install

3.支援支援MPEG4和AAC
#cd libmp4v2-*
export PATH=/usr/local/920t_le/arm-linux/bin:$PATH 
#CC=/usr/local/920t_le/bin/arm_920t_le-gcc CPP=/usr/local/920t_le/bin/arm_920t_le-cpp CXX=/usr/local/920t_le/bin/arm_920t_le-g++ ./configure --host=arm-920t_le-linux --prefix=/usr /local/920t_le/sysroot   --enable-shared
#make
#make install
faac：
在編譯faac的時候如果有錯誤報告：「不能運行./config.sub 或者找不到install.sh」
則要 #ls -l install.sh ，然後將 install.sh鏈接的真正的文件拷貝到編譯環境的對應目錄中config.sub跟install. sh一樣的操作方法。
#cd faac-*
export PATH=/usr/local/920t_le/arm-linux/bin:$PATH 
#CC=/usr/local/920t_le/bin/arm_920t_le-gcc CPP=/usr/local/920t_le/bin/arm_920t_le-cpp CXX=/usr/local/920t_le/bin/arm_920t_le-g++ AR=/usr/local/920t_le/bin/arm_920t_le-ar ./configure --host=arm-920t_le-linux --prefix=/usr /local/920t_le/sysroot --enable-shared --with-mp4v2
#make
#make install
faad：
先在x86中./bootstrap
然後在arm環境中，
#cd faad-*
export PATH=/usr/local/920t_le/arm-linux/bin:$PATH 
#CC=/usr/local/920t_le/bin/arm_920t_le-gcc CPP=/usr/local/920t_le/bin/arm_920t_le-cpp CXX=/usr/local/920t_le/bin/arm_920t_le-g++ AR=/usr/local/920t_le/bin/arm_920t_le-ar ./configure --host=arm-920t_le-linux --prefix=/usr/local/920t_le/sysroot  --with-mpeg4ip   --enable-shared
#make
#make install

4.編譯安裝ffmpeg
export LDFLAGS="-L/usr/local/920t_le/lib/gcc/arm-linux/3.4.4/  -L/usr/local/920t_le/sysroot/lib/"
export PATH=/usr/local/920t_le/arm-linux/bin:$PATH 
ffmepg：
 #NM=/usr/local/920t_le/bin/arm_920t_le-nm LD=/usr/local/920t_le/bin/arm_920t_le-ld  CC=/usr/local/920t_le/bin/arm_920t_le-gcc CXX=/usr/local/920t_le/bin/arm_920t_le-g++  RANLIB=/usr/local/920t_le/bin/arm_920t_le-ranlib AR=/usr/local/920t_le/bin/arm_920t_le-ar  ./configure --enable-shared --enable-nonfree --enable-gpl --enable-pthreads  --enable-postproc  --enable-swscale --enable-libfaac --enable-libfaad --enable-libfaadbin --enable-libmp3lame --enable-libx264 --enable-libxvid --cross-prefix=arm_920t_le- --enable-cross-compile --cc=/usr/local/920t_le/bin/arm_920t_le-gcc --host-cc=/usr/local/920t_le/bin --host-ldflags=/usr/local/920t_le/lib/gcc/arm-linux/3.4.4/ --host-cflags=/usr/local/920t_le/lib/gcc/arm-linux/3.4.4/include --extra-ldflags=-L/usr/local/920t_le/sysroot/lib  --extra-cflags=-I/usr/local/920t_le/sysroot/include --source-path=/x86/ffmpeg/  --arch=arm-920t_le  --prefix=/usr/local/ffmepg 
make的時候的錯誤資訊：
make: *** No rule to make target `libavdevice/libavdevice.so', needed by `all'.  Stop.
解決辦法是將X86中對應目錄中在每個libav*中的對應文件拷貝過來即可
繼續make將會出現的錯誤資訊：
./libavformat/framehook.h:25:2: warning: #warning VHOOK is deprecated. Please help finishing libavfilter instead of wasting your time writing new filters for this crappy filter system.
/usr/local/920t_le/bin/arm_920t_le-gcc -L/usr/local/920t_le/lib/gcc/arm-linux/3.4.4/ -L/usr/local/920t_le/sysroot/lib/ -L/usr/local/920t_le/sysroot/lib -rdynamic -export-dynamic -Wl,--warn-common -Wl,--as-needed -Wl,-rpath-link,"/x86/ffmpeg"/libpostproc -Wl,-rpath-link,"/x86/ffmpeg"/libswscale -Wl,-rpath-link,"/x86/ffmpeg"/libavfilter -Wl,-rpath-link,"/x86/ffmpeg"/libavdevice -Wl,-rpath-link,"/x86/ffmpeg"/libavformat -Wl,-rpath-link,"/x86/ffmpeg"/libavcodec -Wl,-rpath-link,"/x86/ffmpeg"/libavutil -Wl,-Bsymbolic -o vhook/ppm.so -shared -Wl,-soname,$(@F) vhook/ppm.o
/bin/sh: line 1: @F: command not found
bash-2.05b# make install
make: *** No rule to make target `install-libs', needed by `install'.  Stop.
make的版本過低。要>=3.81
此時就要重新安裝make-3.81的版本
在編譯make-3.81之前，先要更改PATH編譯。
export PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:/usr/local/920t_le/bin"
#cd make-3.81
#./configure --prefix=/usr
然後要將PATH變數的路徑修改成：export PATH=/usr/local/920t_le/arm-linux/bin:$PATH 
#make
#make install
然後進入ffmpeg目錄
#make distclean
重新安裝上面步驟安裝即可。

5.安裝pkg-config-0.2.3（因為pkg-config跟make是一樣的，因此做法跟make是一樣的。）
#cd pkg-config-0.2.3
export PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:/usr/local/920t_le/bin"
#./configre --prefix=/usr
然後要將PATH變數的路徑修改成：export PATH=/usr/local/920t_le/arm-linux/bin:$PATH 
#make
此時就會出現找不到arm環境中的線程的相關文件libpthread.a。
然後就x86中的libpthread.a拷貝都提示出錯的對應目錄中去，繼續make
但是還會有同樣的錯誤資訊提示,最後將libpthread_nonshared.a也拷貝到libpthread.a所在的目錄。繼續make即可。
#make install

6.安裝libupnnp-1.6.6：
#cd libupnp-1.6.6
export PATH=/usr/local/920t_le/arm-linux/bin:$PATH 
#CC=/usr/local/920t_le/bin/arm_920t_le-gcc CPP=/usr/local/920t_le/bin/arm_920t_le-cpp CXX=/usr/local/920t_le/bin/arm_920t_le-g++ ./configure --host=arm-920t_le-linux --prefix=/usr/local/libupnp --enable-shared
#make
#make install

7.安裝libdlna-0.2.3
#cd libldna-0.2.3
export PATH=/usr/local/920t_le/arm-linux/bin:$PATH 
 # ./configure --cross-compile --cross-prefix=/usr/local/920t_le/bin/arm_920t_le- --enable-shared  --prefix=/usr/local/dlna --with-ffmpeg-dir=/usr/local/ffmpeg
錯誤資訊：/usr/local/920t_le/bin/arm_920t_le-gcc -W -Wall -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -D_REENTRANT -O3 -I/usr/local/920t_le/sysroot/ffmpeg -c -o /tmp/libdlna-22550-2999-8346.o /tmp/libdlna-25070-2999-1459.c
/usr/local/920t_le/bin/arm_920t_le-gcc -L/usr/local/920t_le/lib/gcc/arm-linux/3.4.4 -L/usr/local/920t_le/sysroot/lib -L/usr/local/920t_le/sysroot/ffmpeg -o /tmp/libdlna-16273-2999-21050 /tmp/libdlna-22550-2999-8346.o -lavformat
/usr/local/920t_le/bin/../lib/gcc/arm-linux/3.4.4/../../../../arm-linux/bin/ld: cannot find -lavformat
collect2: ld returned 1 exit status
Error, can't find libavformat !
則要export LDFLAGS="-L/usr/local/920t_le/lib/gcc/arm-linux/3.4.4/ -L/usr/local/920t_le/sysroot/lib -L/usr/local/ffmpeg/lib"
export CPPFLAGS=-I/usr/local/ffmepg/include
然後繼續 ./configure
如果還有問題，就#pkg-config -lavformat -libs
然後將avformat鏈接的庫文件，添加到confugre中check_lib include/libavformat/avformat.h av_register_all -lavformat 的後面。
還要將configure中的.h文件的路徑修改正確。
這樣confgiure就可以通過了。
#make
在make的時候如果有這樣的錯誤：
#############################################
#         Linking shared objects            #
#############################################
/usr/local/920t_le/bin/arm_920t_le-gcc -shared -Wl,-soname,libdlna.so. profiles.lo containers.lo image_jpeg.lo image_png.lo audio_aac.lo audio_ac3.lo audio_amr.lo audio_atrac3.lo audio_g726.lo audio_lpcm.lo audio_mp2.lo audio_mp3.lo audio_wma.lo av_mpeg1.lo av_mpeg2.lo av_mpeg4_part2.lo av_mpeg4_part10.lo av_wmv9.lo upnp_dms.lo \
          -L/usr/local/ffmepg -lavformat -lz -pthread -lm -lfaac -lfaad -lmp3lame -lx264 -lxvidcore -ldl -lavcodec -o libdlna.so.
ln -sf libdlna.so. libdlna.so.
ln: `libdlna.so.' and `libdlna.so.' are the same file
make[1]: *** [lib_shared] Error 1
make[1]: Leaving directory `/x86/libdlna-0.2.3.bak/src'
make: *** [lib] Error 2
則進入src目錄。運行以下的代碼：
/usr/local/920t_le/bin/arm_920t_le-gcc -shared -Wl,-soname,libdlna.so.0 profiles.lo containers.lo image_jpeg.lo image_png.lo audio_aac.lo audio_ac3.lo audio_amr.lo audio_atrac3.lo audio_g726.lo audio_lpcm.lo audio_mp2.lo audio_mp3.lo audio_wma.lo av_mpeg1.lo av_mpeg2.lo av_mpeg4_part2.lo av_mpeg4_part10.lo av_wmv9.lo upnp_dms.lo \
          -L/usr/local/ffmepg -lavformat -lz -pthread -lm -lfaac -lfaad -lmp3lame -lx264 -lxvidcore -ldl -lavcodec -o libdlna.so.0.2.3
ln -sf libdlna.so.2.3  libdlna.so.0
ln -sf libdlna.so.0  libdlna.so
/usr/bin/install -c -d /usr/local/dlna/lib
/usr/bin/install -c libdlna.so.0.2.3 /usr/local/dlna/lib
ln -sf libdlna.so.0.2.3 /usr/local/dlna/lib/libdlna.so.0
ln -sf libdlna.so.0 /usr/local/dlna/lib/libdlna.so
/usr/bin/install -c -d /usr/local/dlna/include
/usr/bin/install -c -m 644 dlna.h /usr/local/dlna/include
/usr/bin/install -c -d /usr/local/libdlna-0.2.3/lib/pkgconfig
/usr/bin/install -c libdlna.pc /usr/local/libdlna-0.2.3/lib/pkgconfig/
這樣dlna就裝了好。

8.安裝ushare :
export PKG_CONFIG_PATH="/ust/local/dlna/lib/pkgconfig/:/usr/local/ffmpeg/lib/pkgconfig:/usr/local/pkgconfig"
export PATH=/usr/local/920t_le/arm-linux/bin:$PATH 
#cd  ushare-*
# ./configure --prefix=/usr/local/920t_le/sysroot/ushare --enable-dlna --with-libupnp-dir=/usr/local/libupnp/  --with-libdlna-dir=/usr/local/dlna --cross-prefix=/usr/local/920t_le/bin/arm_920t_le- --cross-compile
錯誤資訊：
/usr/local/920t_le/bin/arm_920t_le-gcc -I.. -W -Wall -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -D_REENTRANT -D_GNU_SOURCE -O3 -DHAVE_LOCALE_H -DHAVE_SETLOCALE -DHAVE_IFADDRS_H -DHAVE_LANGINFO_H -DHAVE_LANGINFO_CODESET -DHAVE_ICONV -I/usr/local/920t_le/sysroot/libupnp/ -c -o /tmp/ushare-24638-2796-17001.o /tmp/ushare-12524-2796-696.c
/usr/local/920t_le/bin/arm_920t_le-gcc -L/usr/local/920t_le/lib/gcc/arm-linux/3.4.4 -L/usr/local/920t_le/sysroot/lib -L/usr/local/920t_le/sysroot/libupnp/ -o /tmp/ushare-10712-2796-25654 /tmp/ushare-24638-2796-17001.o -lixml
/usr/local/920t_le/bin/../lib/gcc/arm-linux/3.4.4/../../../../arm-linux/bin/ld: cannot find -lixml
collect2: ld returned 1 exit status
Error, can't find libixml !
將/usr/local/libupnp/lib 中所有的文件拷貝到/usr/local/920t_le/arm-linux/lib 中即可。
然後繼續configure，將會遇到如下錯誤：
gcc -I.. -W -Wall -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -D_REENTRANT -D_GNU_SOURCE -O3 -DHAVE_LOCALE_H -DHAVE_SETLOCALE -DHAVE_IFADDRS_H -DHAVE_LANGINFO_H -DHAVE_LANGINFO_CODESET -DHAVE_ICONV -I/usr/local/920t_le/libupnp/ -pthread -I/usr/local/920t_le/libupnp/include/upnp -I/usr/local/920t_le/dlna/ -c -o /tmp/ushare-28560-20314-19126.o /tmp/ushare-3547-20314-9692.c
gcc -L/usr/local/920t_le/libupnp/ -L/usr/local/920t_le/dlna/ -o /tmp/ushare-22-20314-6190 /tmp/ushare-28560-20314-19126.o -lixml -lthreadutil -lpthread -lupnp -L/usr/local/920t_le/libupnp/lib -ldlna
/usr/local/920t_le/bin/../lib/gcc/arm-linux/3.4.4/../../../../arm-linux/bin/ld: warning: libdl.so.2, needed by /usr/local/920t_le/bin/../arm-linux/lib/libavformat.so.52, not found (try using -rpath or -rpath-link)
/usr/local/920t_le/bin/../arm-linux/lib/libavcodec.so.52: undefined reference to `dlclose@GLIBC_2.0'
/usr/local/920t_le/bin/../arm-linux/lib/libavformat.so.52: undefined reference to `dlerror@GLIBC_2.0'
/usr/local/920t_le/bin/../arm-linux/lib/libavformat.so.52: undefined reference to `dlopen@GLIBC_2.1'
/usr/local/920t_le/bin/../arm-linux/lib/libavformat.so.52: undefined reference to `dlsym@GLIBC_2.0'
collect2: ld returned 1 exit status
Error, can't find libdlna (install it or use --disable-dlna) !
解決辦法就是將libdl.so.2的文件可以沒有在/usr/local/920t_le/arm-linux/lib 目錄中。將其拷貝進來就可以。
export PKG_CONFIG_PATH中如果包含了libdlna的時候，但是configure的 時候還是顯示Error, libdlna < 0.2.1 !就有可能是libdlna.pc文件 中的Verison：一欄沒有標上版本號。要改成Verison： 0.2.3
這樣configure就可以通過了
#make
#make install
這樣ushare的交叉編譯就完成了。


/******************************************************************************/
// 如何啟動USB sound  (Emmebedded System)
/******************************************************************************/
ref: http://victoryuembeddedlinux.blogspot.com/2011/01/usb-sound.html
簡介
USB喇叭是一個標準的USB class，它是一個USB接頭直接接到一對喇叭，而在喇叭中直接有
音訊解碼器及擴大機，可以讓你播放各音樂檔檔式，如mp3 or wav格式，在kernel中有其
標準的驅動程式可供使用，在此說明如何在kernel source code做設定，以及要如何安裝
才可以使用。

Kernel驅動程式的選項
在原始中已有現成的驅動程式，我們只要設定使用它就可以了，要設定原始碼，當然是執行
' make menuconfig' 其選項如下 :
首先要進入『Device Driver'的選項如下：
Device Driver ---> 
  [*]USB support --->
      [*] Support for Host-side USB
      [*]     EHCI HCD (USB2.0) support
      [*]     OHCI HCD support

  [*] Sound card support --->
      [*] Advanced Linux Sound Architecture --->
      [*]   Sequencer support
      [*]     Sequencer dummy client
      [*]   OSS Mixer API
      [*]   OSS PCM (digital audio) API
      [*]     OSS PCM (digital audio) API - Include plugin system
      [*]   OSS Sequencer API
      .
      .
      [*]   Generic sound device
      [ ]     Dummy (/dev/null) soundcard
      [*]     Virtual MIDI soundcard
      [*]     MOTU MidiTimePiece AV multiport MIDI
      [*]     UART16550 serial MIDI driver
      [*]     Generic MPU-401 UART driver
      .
      .
      [*]   USB sound device --->
            [*] USB Audio/MIDI driver
            [*] Native Instruments USB audio device
            [*]   enable input device for controllers

以上完成kernel的選項設定，重新編繹kernel即可.

需要建立的Device Node
有幾個device node必需建立給應用程式使用如下：
> mknod dsp c 14 3
> mknod audio c 14 4
> mknod mixer c 14 0
需要載入的驅動程式
> modprobe snd_usb_audio
> modprobe snd_pcm_oss

若載入正常可以看到以下的驅動程式被載入：
> lsmod
snd_pcm_oss 33872 0 - Live 0xbf19f000
snd_mixer_oss 11280 1 snd_pcm_oss, Live 0xbf19b000
snd_usb_audio 50992 0 - Live 0xbf18d000
snd_timer 13620 1 snd_pcm, Live 0xbf17a000
snd_page_alloc 4472 1 snd_pcm, Live 0xbf177000
snd_usb_lib 10192 1 snd_usb_audio, Live 0xbf173000
snd_rawmidi 13024 1 snd_usb_lib, Live 0xbf16e000
snd_swq_device 3336 1 snd_rawmidi, Live 0xbf16c000
snd_hwdep 3892 1 snd_usb_audio, Live 0xbf16a000
snd 29556 8 snd_pcm_oos,snd_mixer_oxx,snd_usb_audio,snd_pcm,snd_timer,snd_rawmi
soundcore 3044 1 snd, Live 0xbf15f000
ipw 5460 0 - Live 0xbf15c000
usbserial 20320 1 ipw, Live 0xbf156000
......
.....
...
scsi_mod 59644 3 sg,sd_mod,usb_storage, Live 0xbf12b000
uhci_hcd 19724 0 - Live 0xbf125000
ehci_hcd 30556 0 - Live 0xbf11c000
usbcore 87488 8 snd_usb_audio,snd_usb_lib,ipw,usbserial........

若USB Speaker插入有被正常找到，你可以在目錄/proc/asound之下看到檔案
> ls /proc/asound -al
# ls /proc/asound/ -al
dr-xr-xr-x    5 root     root            0 Sep  7 10:42 .
dr-xr-xr-x   41 root     root            0 Jan  1  1970 ..
lrwxrwxrwx    1 root     root            5 Sep  7 10:42 VirMIDI -> card0
dr-xr-xr-x    2 root     root            0 Sep  7 10:42 card0
-r--r--r--    1 root     root            0 Sep  7 10:42 cards
-r--r--r--    1 root     root            0 Sep  7 10:42 devices
-r--r--r--    1 root     root            0 Sep  7 10:42 hwdep
-r--r--r--    1 root     root            0 Sep  7 10:42 modules
dr-xr-xr-x    2 root     root            0 Sep  7 10:42 oss
-r--r--r--    1 root     root            0 Sep  7 10:42 pcm
dr-xr-xr-x    2 root     root            0 Sep  7 10:42 seq
-r--r--r--    1 root     root            0 Sep  7 10:42 timers
-r--r--r--    1 root     root            0 Sep  7 10:42 version
這時你可以執行一下程式測試，若一切正常你可以聽到聲音，大功告成。


/******************************************************************************/
// 安裝 JS USB speaker. 
/******************************************************************************/
當 JS USB Speaker插入ubuntu system 中 用dmesg觀看
> dmesg
[2099917.352053] usb 5-1: USB disconnect, address 5
[2161390.636021] usb 5-1: new full speed USB device using uhci_hcd and address 6
[2161390.820165] usb 5-1: configuration #1 chosen from 1 choice

在Ubuntu上用lsusb查看 JS USB speaker 資訊
root@dexter-desktop:/home/Allegro-Release-V0.3/metag-buildroot2# lsusb -t
/:  Bus 05.Port 1: Dev 1, Class=root_hub, Driver=uhci_hcd/2p, 12M
    |__ Port 1: Dev 6, If 0, Class=audio, Driver=snd-usb-audio, 12M
    |__ Port 1: Dev 6, If 1, Class=audio, Driver=snd-usb-audio, 12M
/:  Bus 04.Port 1: Dev 1, Class=root_hub, Driver=uhci_hcd/2p, 12M
/:  Bus 03.Port 1: Dev 1, Class=root_hub, Driver=uhci_hcd/2p, 12M
/:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=uhci_hcd/2p, 12M
/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=ehci_hcd/8p, 480M

root@dexter-desktop:/home/Allegro-Release-V0.3/metag-buildroot2# lsusb
Bus 005 Device 006: ID 0d8c:0001 C-Media Electronics, Inc. Audio Device
Bus 005 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
Bus 004 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
Bus 003 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
root@dexter-desktop:/home/Allegro-Release-V0.3/metag-buildroot2#

在rtl819x-sdk-v2.5/rtl819x/romfs/dev中，增加下列3個device
> mknod dsp c 14 3
> mknod audio c 14 4
> mknod mixer c 14 0
> chmod 666 dsp
> chmod 666 audio
> chmod 666 mixer
再用
> make image 將romfs build成為image檔(root.bin)


/******************************************************************************/
mplayer移植             ref: http://blog.chinaunix.net/space.php?uid=23121765&do=blog&id=198014
/******************************************************************************/
主機系統:ubuntu 9.10 amd64 (gcc version 4.4.1 (Ubuntu 4.4.1-4ubuntu9))
目標平台:mini2440 (S3C2440 ARM920T)
交叉編譯器:arm-linux-gcc-4.3.2 (arm-none-linux-gnueabi)
軟體準備:MPlayer-1.0rc2.tar.bz2 下載套裝軟體到~/download目錄
本次移植的目標系統環境使用的是友善之臂官網上提供的arm-linux-gcc-4.3.2交叉編譯器以及使用該編譯器編譯的linux-2.6.32.2內核及其相應的glibc庫。
1、解壓
cd ~/download
tar xf MPlayer-1.0rc2.tar.bz2 -C /tmp

2、配置
cd /tmp/MPlayer-1.0rc2
./configure  --disable-mencoder --enable-linux-devfs --disable-iconv --enable-network --disable-live  \
--disable-dvdnav --disable-dvdread --disable-dvdread-internal --disable-libdvdcss-internal --enable-ftp  \
--enable-libavcodec_a --enable-libavcodec_mpegaudio_hp --enable-mad --disable-mp3lib --enable-fbdev \
--enable-ossaudio --enable-cross-compile --cc=arm-linux-gcc --host-cc=gcc --target=arm-linux --enable-static \
--with-extraincdir=/opt/toolchains/arm920t-eabi/lib/include --with-extralibdir=/opt/toolchains/arm920t-eabi/lib/lib 2>&1 |tee logfile
紅色部分的參數都是比較重要的，一般都需要指定(--disable-mencoder參數指定不編譯mencoder以節省編譯時間，因為不需要也不應該在ARM平台上使用mencoder來編輯視頻
)。其中--enable-mad是為了改善mplayer在ARM處理器上的音頻播放性能。因為S3C2440還不支援硬浮點運算，而mp3lib庫是使用浮點運算的，所以使用mp3lib庫來播放mp3文件
則相當佔用CPU資源。因此，考慮使用libmad庫來播放mp3等格式音頻文件。由於libmad庫並不包含在mplayer源碼中，所以得事先另外安裝，然後在編譯mplayer時啟用libmad
庫，即"--enable-mad"，並指定libmad庫頭文件以及編譯完成的庫文件所在的目錄，即"--with-extraincdir"、"--extralibdir"參數指定的路徑。其他參數可以通過
 ./configure -h 來查看詳細說明。由於這裡指定了靜態編譯方式"--enable-static"，故沒有另外指定"--prefix"安裝路徑前綴（當然你也可以指定為/tmp/mplayer，即
 "--prefix=/tmp/mplayer"），也不需要執行 make install 命令安裝，編譯完成後手動拷貝mplayer可執行文件到目標系統的/usr/bin目錄則可。
ps:其實在執行 make install 命令時會有一個錯誤提示，但這個不礙事。
install -m 755 -s mplayer /tmp/mplayer/bin
strip: Unable to recognise the format of the input file `/tmp/mplayer/bin/mplayer'
install: strip process terminated abnormally
make: *** [install-mplayer] 錯誤 1

3、編譯
執行
>make   命令編譯。
下面參考http://hi.baidu.com/linuxcfan/blog/item/d448a758f2906e232934f04f.html
執行過程中會出現類似如下錯誤提示：
armv4l/dsputil_arm_s.S:79:error:selected processor does not support 'pld [r1]'
......
原因分析：armv5以下的版本不支援pld指令（mini2440的arm9屬於armv4）
解決方法一：替換MPlayer-1.0rc2/libmpeg2/motion_comp_arm_s.S文件和MPlayer-1.0rc2/libavcodec/armv4l/dsputil_arm_s.S文件中的pld [r1]為空即可！
ps:為什麼要修改兩個文件呢？因為只修改錯誤提示中的那個文件後繼續編譯則會繼續提示MPlayer-1.0rc2/libmpeg2/motion_comp_arm_s.S文件中同樣的錯誤^_^
修改方法：使用vim分別打開dsputil_arm_s.S、motion_comp_arm_s.S這兩個彙編源文件，執行
:%s/pld \[r1\]//
命令完成替換。
解決方法二：分別編輯dsputil_arm_s.S、motion_comp_arm_s.S這兩個彙編源文件，在前面添加
#ifndef HAVE_PLD
.macro pld reg
.endm
#endif
詳細可以參考：http://hi.baidu.com/serial_story/blog/item/ce608601a32c540b728da5cc.html
ps:這個問題確實與使用的交叉編譯工具鏈相關，因為我之前使用arm920t-eabi交叉編譯器編譯時並沒有出現這個錯誤。
4、編譯libmad庫
前面提到了使用libmad庫來替代mp3lib庫來改善mplayer在ARM處理器上播放音頻的性能，那麼在編譯mplayer之前得編譯好libmad庫。
下載 libmad 包(libmad-0.15.1b.tar.gz) http://sourceforge.net/project/showfiles.php?group_id=12349
將其解壓後，進入 libmad 的目錄，輸入配置命令:
./configure --enable-fpm=arm \
--host=arm-linux \
--disable-shared   \ (這個選項就是說明要靜態編譯)
--disable-debugging    \
--prefix=/opt/toolchains/arm920t-eabi/lib
--cc=arm-linux-gcc
對於 --cc=arm-linux-gcc 選項要保證 arm-linux-gcc 的路徑已經有 export 過，否則給出完整路徑。
ps:其實意思就是事先已經搭建好交叉編譯環境。
#make
#make install
這樣就可以看到在 /opt/toolchains/arm920t-eabi/lib 目錄下多了 include 和 lib 目錄，這些就是 libmad 的庫文件及其頭文件。
ps:其實可以指定路徑為/opt/toolchains/arm920t-eabi，這樣如果使用的是arm920t-eabi交叉編譯器，那麼在編譯mplayer時應該不需要再額外指定libmad庫相關文件的所在
路徑了。
5、測試
在播放音頻或視頻文件時會出現沒有聲音輸出的問題，終端提示
[AO OSS] audio_setup: Can't open audio device /dev/sound/dsp: No such file or dy
然而目標系統上有 /dev/dsp 音頻設備文件，只是OSS音頻驅動需要的是 /dev/sound/dsp 設備文件，這問題的簡單解決方法是建一個符號鏈接。
mkdir -p /dev/sound
ln -s /dev/dsp /dev/sound/
這樣問題就搞定了。可以把這兩條命令添加到目標系統的啟動文件的適當位置，修改目標系統的 /etc/init.d/rcS 文件。
後記：我編譯的libmad庫的安裝路徑為 /opt/toolchains/arm920t-eabi/lib，這是由於之前使用arm-linux-gcc-4.3.2交叉編譯qte-4.5.3時出現了問題而改用arm920t-eabi交
叉編譯工具鏈造成的。原以為使用arm920t-eabi交叉編譯器編譯mplayer也能正常移植，不過事實證明是不行的（能夠編譯成功，只是移植過去程式執行出錯），因為目標系統
內核以及glibc庫都是使用arm-linux-gcc-4.3.2編譯的，而mplayer是用arm920t-eabi編譯的，因此可能是不同版本的編譯器之間的不相容而造成了奇奇怪怪的鬱悶的問題>_<。
嘗試過移植mplayer的最新版本，移植過去能正常播放音頻，只是播放視頻時一閃即逝（有時卻又像程式死循環一樣），出錯資訊也看不懂，暈。
三、MPlayer slave命令
在命令中添加 -slave 和 -quiet就可以通過命令設置Mplayer實現相應的功能。在mplayer源碼中的，/DOCS/tech/slave.txt中對這些命令有詳細的解析。
mplayer 背景執行
mplayer *.mp3 </dev/null > /dev/null 2>1&
mplayer *.mp3 </dev/null > /dev/null &


/******************************************************************************/
// Linux 共享庫 LD_LIBRARY_PATH 與ld.so.conf的使用ldconfig
/******************************************************************************/
現象：error while loading shared libraries: libfreerdp.so.0:
關於ubuntu添加共享庫路徑：
1. 將絕對路徑寫入 /etc/ld.so.conf 
2. ldconfig
詳細介紹：
Linux運行的時候，是如何管理共享庫(*.so)的？
在Linux下面，共享庫的尋找和加載是由 /lib/ld.so 實現的。 ld.so 在標準路經(/lib, /usr/lib) 中尋找應用程式用到的共享庫。
但是，如果需要用到的共享庫在非標準路經，ld.so 怎麼找到它呢？
目前，Linux 通用的做法是將非標準路經加入 /etc/ld.so.conf，然後運行 ldconfig 生成 /etc/ld.so.cache。
ld.so 加載共享庫的時候，會從 ld.so.cache 查找。

LD_LIBRARY_PATH 這個環境變數是大家最為熟悉的，它告訴loader：在哪些目錄中可以找到共享庫。可以設置多個搜索目錄，這些目錄之間用冒號分隔開。
在linux下，還提供了另外一種方式來完成同樣的功能，你可以把這些目錄加到/etc/ld.so.conf中，然後調用ldconfig。
當然，這是系統範圍內全局有效的，而環境變數只對當前shell有效。按照慣例，除非你用上述方式指明，loader是不會在當前目錄下去找共享庫的，正如shell不會在當前目
前找可執行文件一樣。

ldconfig及 LD_LIBRARY_PATH:
1. 往/lib和/usr/lib裡面加東西，是不用修改/etc/ld.so.conf的，但是完了之後要調一下ldconfig，不然這個library會找不到
2. 想往上面兩個目錄以外加東西的時候，一定要修改/etc/ld.so.conf，然後再調用ldconfig，不然也會找不到比 如安裝了一個mysql到/usr/local/mysql，mysql有一大堆
 library在/usr/local/mysql/lib下面，這時就 需要在/etc/ld.so.conf下面加一行/usr/local/mysql/lib，保存過後ldconfig一下，新的library才能在程序運行時被找到。
3. 如果想在這兩個目錄以外放lib，但是又不想在/etc/ld.so.conf中加東西（或者是沒有權限加東西）。那也可以，就是export一個全局變量LD_LIBRARY_PATH，然後運行程
   式的時候就會去這個目錄中找library。一般來講這只是一種臨時的解決方案，在沒有權限或臨時需要的時候使用。
4. ldconfig做的這些東西都與運行程式時有關，跟編譯時一點關係都沒有。編譯的時候還是該加-L就得加，不要混淆了。
5. 總之，就是不管做了什麼關於library的變動後，最好都ldconfig一下，不然會出現一些意想不到的結果。不會花太多的時間，但是會省很多的事。


/******************************************************************************/
// Linux 函式庫  ref: http://www.suse.url.tw/sles10/lesson7.htm#26
/******************************************************************************/
在 Linux 系統上所執行的程式都會使用到函式庫，而依照應用程式與函式庫連結的方式，可區分為
靜態函式庫(Static Libraries) 
1. 通常為 xx.a 
2. 靜態函式庫裡的函式原始碼需要被編譯到主程式裡頭，所以主程式會顯得比較大，但好處是該程式可以獨立執行。
動態函式庫(Dynamic Link Libraries、Shared Libraries) 
1. 通常為 xx.so，如你看到的 xx.so.2.1 之類的，那個 2.1 就是版本
2. 動態函式庫則不需整個被編譯到主程式裡邊，只需在程式的原始碼裡設計去呼叫動態函式庫即可。
在 Linux 中所執行的程式幾乎都是使用動態連結資料庫。

一般傳統函式庫是安在 /lib 及 /usr/lib ，而提供系統來搜尋的函式庫，其放置的目錄是定義在 /etc/ld.so.conf 裡。
當執行 ldconfig 指令時，會先去讀取 /etc/ld.so.conf，以找出函式庫所放置的目錄位置，然後才能將這些函式庫資料寫入 cache 內，並存放一份在 /etc/ld.so.cache 中。
而我們在執行一支程式時，就會由 ld.so 這個動態連結器 (dynamic linker) 程式，到 cache 內去尋找執行程式所需的函式，以提供程式做動態連結。
不過您要是看過 /etc/ld.so.conf，會發現 /lib 及 /usr/lib 並沒有定義在 ld.so.conf 內，因為這兩個目錄是內定值，所以不需要做設定啦 ! 
最後如果您有設定 LD_LIBRARY_PATH 這個環境變數的話，其所定義的目錄也會被讀入。
如果哪天您函式庫所存放的目錄有所異動，請記得修改 /etc/ld.so.conf，然後再執行 ldconfig 指令，這樣才可以更新 cache 內的資料。
以下我們稍作整理：
1. DLL 一般是安置在 /lib 或 /usr/lib 目錄下，而除了這兩個目錄外，DLL 所存放的目錄必須在 /etc/ld.so.conf 或 LD_LIBRARY_PATH 中做定義。 
2. 執行指令 ldconfig 時，會先去讀取 /etc/ld.so.conf，然後將 DLL 讀入 cache，並紀錄一份在 /etc/ld.so.cache。
   當執行程式在執行時，ld.so 就會根據 cache 來找出並載入程式所需的函式庫，以讓程式能正確的執行。
3. 欲瀏覽 /etc/ld.so.cache 內的資料，可執行：
   ~# ldconfig -p
4. 增加、減少、刪除部份 DLL 或 DLL 目錄有異動，就須執行 ldconfig，以更新 cache 的資料。
5. 系統於開機時，預設就會執行 ldconfig，以確保 cache 內的資料是最新的。


/******************************************************************************/
// Linux 程式減肥(strip & objcopy)
/******************************************************************************/
對於設計嵌入式Linux系統的研發人員來說，記憶體的空間是非常斤斤計較的。
嵌入式Linux系統所用的記憶體不是軟碟、硬碟、ZIP 盤、CD-ROM、DVD這些大容量記憶裝置，而是使用的是Rom,Flash, CompactFlash, SD...等體積極小,與主板上的BIOS大小
相近，存儲容量很小的記憶體。所以怎樣盡可能的節省空間就顯的很重要。嵌入式系統的記憶體中放置的是Linux核心，文件系統，軟體，以及自己開發的程式。
以一個簡單的C程式來做例子，讓它減肥。
HelloWorld.c:
#include <stdio.h>

int main()
{
        printf("Hello, World1.\n");
        printf("Hello, World2.\n");
        printf("Hello, World3.\n");
        return 0;
}
先用正常的編譯方法編譯，看看生成的程式的大小是多少
~#gcc –o HelloWorld HelloWorld.c
~# ls HelloWorld -al
-rwxr-xr-x 1 root root 7144 2011-11-25 11:23 HelloWorld
從結果可以看到正常編譯後的程式大小是 7144Byte

1. 用 strip 命令
二進位程式中包含了大量的符號資訊(symbol table)，有一部分是用來gdb除錯提供必要幫助的。可以通過 readelf –S 查看到這些符號資訊。
~# readelf -S HelloWorld
There are 30 section headers, starting at offset 0x1128:
Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .interp           PROGBITS        08048134 000134 000013 00   A  0   0  1
  [ 2] .note.ABI-tag     NOTE            08048148 000148 000020 00   A  0   0  4
  [ 3] .note.gnu.build-i NOTE            08048168 000168 000024 00   A  0   0  4
  [ 4] .hash             HASH            0804818c 00018c 000028 04   A  6   0  4
  [ 5] .gnu.hash         GNU_HASH        080481b4 0001b4 000020 04   A  6   0  4
  [ 6] .dynsym           DYNSYM          080481d4 0001d4 000050 10   A  7   1  4
  [ 7] .dynstr           STRTAB          08048224 000224 00004a 00   A  0   0  1
  [ 8] .gnu.version      VERSYM          0804826e 00026e 00000a 02   A  6   0  2
  [ 9] .gnu.version_r    VERNEED         08048278 000278 000020 00   A  7   1  4
  [10] .rel.dyn          REL             08048298 000298 000008 08   A  6   0  4
  [11] .rel.plt          REL             080482a0 0002a0 000018 08   A  6  13  4
  [12] .init             PROGBITS        080482b8 0002b8 000030 00  AX  0   0  4
  [13] .plt              PROGBITS        080482e8 0002e8 000040 04  AX  0   0  4
  [14] .text             PROGBITS        08048330 000330 00018c 00  AX  0   0 16
  [15] .fini             PROGBITS        080484bc 0004bc 00001c 00  AX  0   0  4
  [16] .rodata           PROGBITS        080484d8 0004d8 000035 00   A  0   0  4
  [17] .eh_frame         PROGBITS        08048510 000510 000004 00   A  0   0  4
  [18] .ctors            PROGBITS        08049f0c 000f0c 000008 00  WA  0   0  4
  [19] .dtors            PROGBITS        08049f14 000f14 000008 00  WA  0   0  4
  [20] .jcr              PROGBITS        08049f1c 000f1c 000004 00  WA  0   0  4
  [21] .dynamic          DYNAMIC         08049f20 000f20 0000d0 08  WA  7   0  4
  [22] .got              PROGBITS        08049ff0 000ff0 000004 04  WA  0   0  4
  [23] .got.plt          PROGBITS        08049ff4 000ff4 000018 04  WA  0   0  4
  [24] .data             PROGBITS        0804a00c 00100c 000008 00  WA  0   0  4
  [25] .bss              NOBITS          0804a014 001014 000008 00  WA  0   0  4
  [26] .comment          PROGBITS        00000000 001014 000023 01  MS  0   0  1
  [27] .shstrtab         STRTAB          00000000 001037 0000ee 00      0   0  1
  [28] .symtab           SYMTAB          00000000 0015d8 000410 10     29  45  4
  [29] .strtab           STRTAB          00000000 0019e8 000200 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)

以減小程式的 size。這裏我們通過 strip 命令拿掉它們。
~# cp HelloWorld HelloWorld_org
~# strip HelloWorld
~# ll
total 28
drwxr-xr-x  2 root root 4096 2011-11-25 12:01 ./
drwxr-xr-x 19 root root 4096 2011-11-25 11:20 ../
-rwxr-xr-x  1 root root 5496 2011-11-25 12:01 HelloWorld*
-rw-r--r--  1 root root  156 2011-11-25 11:56 HelloWorld.c
-rwxr-xr-x  1 root root 7144 2011-11-25 12:01 HelloWorld_org*
程式立刻變成 5496Byte了，效果不錯。

2. 用 objcopy 命令
上一步的 strip 命令只能拿掉一般 symbol table，有些資訊還是沒拿掉，而這些資訊對於程式的最終執行是沒有什麼影響的。
如:.comment; .note.ABI-tag; .gnu.version 就是完全可以去掉的。所以說程式還有簡化的餘地，我們可以使用 objcopy 命令把它們抽取掉。
~# objcopy -R .comment -R .note.ABI-tag -R .gnu.version HelloWorld HelloWorld_obj
~# ll
total 52
drwxr-xr-x  2 root root 4096 2011-11-25 13:17 ./
drwxr-xr-x 19 root root 4096 2011-11-25 11:20 ../
-rwxr-xr-x  1 root root 5496 2011-11-25 13:15 HelloWorld*
-rw-r--r--  1 root root  156 2011-11-25 11:56 HelloWorld.c
-rwxr-xr-x  1 root root 5304 2011-11-25 13:17 HelloWorld_obj*   
-rwxr-xr-x  1 root root 7144 2011-11-25 12:01 HelloWorld_org*
-rwxr-xr-x  1 root root 5496 2011-11-25 12:02 HelloWorld_strip*
查看一下 HelloWorld_obj為5304Bytes，又少了一點。

比較一下原始bin，strip後的bin，objcopy後的bin：
-rwxr-xr-x  1 root root 7144 2011-11-25 12:01 HelloWorld_org*
-rwxr-xr-x  1 root root 5496 2011-11-25 12:02 HelloWorld_strip*
-rwxr-xr-x  1 root root 5304 2011-11-25 13:17 HelloWorld_obj*   
程式容量的減小對嵌入式 Linux系統的設計很有意義，節省了大量空間，使得我們可以利用這部分空間來完善我們的系統,如可再加大Linux核心等等。


/******************************************************************************/
// 用 GStreamer 簡化 Linux 多媒體開發   ref: http://www.ibm.com/developerworks/cn/linux/l-gstreamer/
/******************************************************************************/
GStreamer 是 GNOME 桌面環境下用來構建流媒體應用的編程框架（framework），其目標是要簡化音/視頻應用程式的開發，
目前已經能夠被用來處理像 MP3、Ogg、MPEG1、MPEG2、AVI、Quicktime 等多種格式的多媒體數據。

一、基本概念
GStreamer 作為 GNOME 桌面環境推薦的流媒體應用框架，採用了基於插件（plugin）和管道（pipeline）的體系結構，框架中的所有的功能模組都被實現成可以插拔的元件
（component），並且在需要的時候能夠很方便地安裝到任意一個管道上，由於所有插件都通過管道機制進行統一的數據交換，因此很容易利用已有的各種插件「組裝」出一個
功能完善的多媒體應用程式。
1.1 元件處理
對於需要應用 GStreamer 框架的程式員來講，GstElement 是一個必須理解的概念，因為它是組成管道的基本構件，也是框架中所有可用元件的基礎，這也難怪 GStreamer 框
架中的大部分函數都會涉及到對 GstElement 對象的操作。從 GStreamer 自身的觀點來看，GstElement 可以描述為一個具有特定屬性的黑盒子，它通過連接點（link point）
與外界進行交互，向框架中的其餘部分表徵自己的特性或者功能。
按照各自功能上的差異，GStreamer 又將 GstElement 細分成如下幾類：
Source Element 數據源元件只有輸出端，它僅能用來產生供管道消費的數據，而不能對數據做任何處理。一個典型的數據源元件的例子是音頻捕獲單元，它負責從聲卡讀取原
始的音頻數據，然後作為數據源提供給其它模組使用。
Filter Element 過濾器元件　既有輸入端又有輸出端，它從輸入端獲得相應的數據，並在經過特殊處理之後傳遞給輸出端。一個典型的過濾器元件的例子是音頻編碼單元，它
首先從外界獲得音頻數據，然後根據特定的壓縮算法對其進行編碼，最後再將編碼後的結果提供給其它模組使用。
Sink Element 接收器元件只有輸入端，它僅具有消費數據的能力，是整條媒體管道的終端。一個典型的接收器元件的例子是音頻回放單元，它負責將接收到的數據寫到聲卡上
，通常這也是音頻處理過程中的最後一個環節。
圖1將有助於你更好地理解數據源元件、過濾器元件和接收器元件三者的區別，同時也不難看出它們是如何相互配合形成管道的：
圖1    Source Element         Filter Element              Sink Element
   ┌──數據源元件──┐     ┌──過濾器元件──┐     ┌──接收器元件──┐
   │            output│---> │Input ===>  Output│---> │Input             │
   └─────────┘     └─────────┘     └─────────┘
需要注意的是，過濾器元件的具體形式是非常靈活的，GStreamer並沒有嚴格規定輸入端和輸出端的數目，事實上它們都可以是一個或者多個。
圖2是一個 AVI分離器的基本結構，它能夠將輸入數據分離成單獨的音頻資訊和視頻資訊，用於實現該功能的過濾器元件很明顯只具有一個輸入端，但卻需要有兩個輸出端。
圖2
┌────────┐
│      AVI分離器 │
│     ┌ 音頻    │==>
│輸入 ┤         │
│     └ 視頻    │==>
└────────┘
要想在應用程式中創建GstElement對像，唯一的辦法是借助於工廠對像GstElementFactory。由於GStreamer框架提供了多種類型的GstElement對像，因此對應地提供了多種類
型的GstElementFactory對像，它們是通過特定的工廠名稱來進行區分的。例如，下面的代碼通過gst_element_factory_find()函數獲得了一個名為mad的工廠對像，它之後可
以用來創建與之對應的MP3解碼器元件：
GstElementFactory *factory; factory = gst_element_factory_find ("mad");
成功獲得工廠對像之後，接下來就可以通過gst_element_factory_create()函數來創建特定的GstElement對象了，該函數在調用時有兩個參數，分別是需要用到的工廠對像，
以及即將創建的元件名稱。元件名稱可以用查詢的辦法獲得，也可以通過傳入空指針（NULL）來生成工廠對象的默認元件。下面的代碼示範了如何利用已經獲得的工廠對像，
來創建名為decoder的MP3解碼器元件：
GstElement *element; element = gst_element_factory_create (factory, "decoder");
當創建的GstElement不再使用的時候，還必須調用gst_element_unref()函數釋放其佔用的記憶體資源：
gst_element_unref (element);
GStreamer使用了與GObject相同的機制來對屬性（property）進行管理，包括查詢（query）、設置（set）和讀取（get）等。所有的 GstElement對象都需要從其父對像
GstObject那裡繼承名稱（name）這一最基本的屬性，這是因為像 gst_element_factory_make()和gst_element_factory_create()這樣的函數在創建工廠對像和元件對像時都
會用到名稱屬性，通過調用gst_object_set_name()和gst_object_get_name()函數可以設置和讀取 GstElement對象的名稱屬性。

1.2 襯墊處理
襯墊（pad）是GStreamer框架引入的另外一個基本概念，它指的是元件（element）與外界的連接通道，對於框架中的某個特定元件來說，其能夠處理的媒體類型正是通過襯墊
暴露給其它元件的。成功創建GstElement對像之後，可以通過gst_element_get_pad()獲得該元件的指定襯墊。例如，下面的代碼將返回element元件中名為src的襯墊：
GstPad *srcpad; srcpad = gst_element_get_pad (element, "src");
如果需要的話也可以通過gst_element_get_pad_list()函數，來查詢指定元件中的所有襯墊。例如，下面的代碼將輸出element元件中所有襯墊的名稱：
GList *pads; 
pads = gst_element_get_pad_list (element); 
while (pads) { 
    GstPad *pad = GST_PAD (pads->data); 
    g_print ("pad name is: %s/n", gst_pad_get_name (pad)); 
    pads = g_list_next (pads); 
}
與元件一樣，襯墊的名稱也能夠動態設置或者讀取，這是通過調用gst_pad_get_name ()和gst_pad_set_name()函數來完成的。所有元件的襯墊都可以細分成輸入襯墊和輸出襯
墊兩種，其中輸入襯墊只能接收數據但不能產生數據，而輸出襯墊則正好相反，只能產生數據但不能接收數據，利用函數gst_pad_get_direction()可以獲得指定襯墊的類型。
GStreamer框架中的所有襯墊都必然依附於某個元件之上，調用gst_pad_get_parent()可以獲得指定襯墊所屬的元件，該函數的返回值是一個指向GstElement的指針。襯墊從某
種程度上可以看成是元件的代言人，因為它要負責向外界描述該元件所具有的能力。GStreamer框架提供了統一的機制來讓襯墊描述元件所具有的能力（capability），這是借
助數據結構_GstCaps來實現的：
struct _GstCaps { 
    gchar *name; /* the name of this caps */ 
    guint16 id; /* type id (major type) */ 
    guint refcount; /* caps are refcounted */ 
    GstProps *properties; /* properties for this capability */ 
    GstCaps *next; /* caps can be chained together */ 
};
以下是對mad元件的能力描述，不難看出該元件中實際包含sink和src兩個襯墊，並且每個襯墊都帶有特定的功能資訊。名為sink的襯墊是mad元件的輸入端，它能夠接受 MIME
類型為audio/mp3的媒體數據，此外還具有layer、bitrate和framed三種屬性。名為src的襯墊是mad元件的輸出端，它負責產生MIME類型為audio/raw媒體數據，此外還具有
format、depth、rate和channels等多種屬性。
Pads: SINK template: "sink" Availability: Always Capabilities: "mad_sink": MIME type: "audio/mp3": SRC template: "src" 
Availability: Always Capabilities: "mad_src": MIME type: "audio/raw": format: String: int endianness: Integer: 1234 width: Integer: 16 depth: Integer: 
16 channels: Integer range: 1 - 2 law: Integer: 0 signed: Boolean: TRUE rate: Integer range: 11025 - 48000
準確地說，GStreamer框架中的每個襯墊都可能對應於多個能力描述，它們能夠通過函數gst_pad_get_caps()來獲得。例如，下面的代碼將輸出pad襯墊中所有能力描述的名稱
及其MIME類型：
GstCaps *caps; 
caps = gst_pad_get_caps (pad); 
g_print ("pad name is: %s/n", gst_pad_get_name (pad)); 
while (caps) { 
    g_print (" Capability name is %s, MIME type is %s/n", gst_caps_get_name (cap), gst_caps_get_mime (cap)); caps = caps->next; 
}

1.3 箱櫃
箱櫃（bin）是GStreamer框架中的容器元件，它通常被用來容納其它的元件對像，但由於其自身也是一個GstElement對像，因此實際上也能夠被用來容納其它的箱櫃對象。利
用箱櫃可以將需要處理的多個元件組合成一個邏輯元件，由於不再需要對箱櫃中的元件逐個進行操作，因此能夠很容易地利用它來構造更加複雜的管道。在GStreamer框架中使
用箱櫃還有另外一個優點，那就是它會試著對數據流進行優化，這對於多媒體應用來講是很具吸引力的。
圖3描述了箱櫃在GStreamer框架中的典型結構：
圖3
    ┌────元件────┐     ┌────元件────┐     ┌────元件────┐
    │              輸出端│---> │輸入端  ===>  輸出端│---> │輸入端              │
    └──────────┘     └──────────┘     └──────────┘
在GStreamer應用程式中使用的箱櫃主要有兩種類型：
GstPipeline 管道是最常用到的容器，對於一個GStreamer應用程式來講，其頂層箱櫃必須是一條管道。
GstThread 線程的作用在於能夠提供同步處理能力，如果GStreamer應用程式需要進行嚴格的音視頻同步，一般都需要用到這種類型的箱櫃。
GStreamer框架提供了兩種方法來創建箱櫃：一種是借助工廠方法，另一種則是使用特定的函數。下面的代碼示範了如何使用工廠方法創建線程對像，以及如何使用特定函數來
創建管道對像：
GstElement *thread, *pipeline; // 創建線程對像，同時為其指定唯一的名稱。 
thread = gst_element_factory_make ("thread", NULL); // 根據給出的名稱，創建一個特定的管道對象。 
pipeline = gst_pipeline_new ("pipeline_name");
箱櫃成功創建之後，就可以調用gst_bin_add()函數將已經存在的元件添加到其中來了：
GstElement *element;
GstElement *bin; bin = gst_bin_new ("bin_name"); 
element = gst_element_factory_make ("mpg123", "decoder"); 
gst_bin_add (GST_BIN (bin), element);
而要從箱櫃中找到特定的元件也很容易，可以借助gst_bin_get_by_name()函數實現：
GstElement *element; element = gst_bin_get_by_name (GST_BIN (bin), "decoder");
由於GStreamer框架中的一個箱櫃能夠添加到另一個箱櫃之中，因此有可能會出現箱櫃嵌套的情況，gst_bin_get_by_name()函數在查找元件時會對嵌套的箱櫃作遞歸查找。元
件有添加到箱櫃之中以後，在需要的時候還可以從中移出，這是通過調用gst_bin_remove()函數來完成的：
GstElement *element; 
gst_bin_remove (GST_BIN (bin), element);
如果仔細研究一下圖3中描述的箱櫃，會發現它沒有屬於自己的輸入襯墊和輸出襯墊，因此顯然是無法作為一個邏輯整體與其它元件交互的。為了解決這一問題，GStreamer引
入了精靈襯墊（ghost pad）的概念，它是從箱櫃裡面所有元件的襯墊中推舉出來的，通常來講會同時選出輸入襯墊和輸出襯墊，如圖4所示：
圖4
              ┌────元件────┐     ┌────元件────┐     ┌────元件────┐
    精靈   -->│輸入端  ===>  輸出端│---> │輸入端  ===>  輸出端│---> │輸入端  ===>  輸出端│--> 精靈
    輸入端    └──────────┘     └──────────┘     └──────────┘    輸出端
具有精靈襯墊的箱櫃在行為上與元件是完全相同的，所有元件具有的屬性它都具有，所有針對元件能夠進行的操作也同樣能夠針對箱櫃進行，因此在GStreamer應用程式中能夠
像使用元件一樣使用這類箱櫃。下面的代碼示範了如何為箱櫃添加一個精靈襯墊：
GstElement *bin; 
GstElement *element; 
element = gst_element_factory_create ("mad", "decoder"); 
bin = gst_bin_new ("bin_name"); 
gst_bin_add (GST_BIN (bin), element); 
gst_element_add_ghost_pad (bin, gst_element_get_pad (element, "sink"), "sink");

二、元件連接
在引入了元件和襯墊的概念之後，GStreamer對多媒體數據的處理過程就變得非常清晰了：通過將不同元件的襯墊依次連接起來構成一條媒體處理管道，使數據在流經管道的過
程能夠被各個元件正常處理，最終實現特定的多媒體功能。
圖１就描述了一條很簡單的管道，它由三個基本元件構成：數據源元件只負責產生數據，它的輸出襯墊與過濾器元件的輸入襯墊相連；過濾器元件負責從自己的輸入襯墊中獲
取數據，並在經過特定的處理之後，將結果通過輸出襯墊傳給與之相連的接收器元件；接收器元件只負責接收數據，它的輸入襯墊與過濾器元件的輸出襯墊相連，負責對最終
結果進行相應的處理。
GStreamer框架中的元件是通過各自的襯墊連接起來的，下面的代碼示範了如何將兩個元件通過襯墊連接起來，以及如何在需要的時候斷開它們之間的連接：
GstPad *srcpad, *sinkpad; 
srcpad = gst_element_get_pad (element1, "src"); 
sinpad = gst_element_get_pad (element2, "sink"); 
gst_pad_link (srcpad, sinkpad); // 連接 
gst_pad_unlink (srcpad, sinkpad); // 斷開
如果需要建立起連接的元件都只有一個輸入襯墊和一個輸出襯墊，那麼更簡單的做法是調用gst_element_link()函數直接在它們之間建立起連接，
或者調用gst_element_unlink()函數斷開它們之間的連接：
// 連接 gst_element_link (element1, element2); 
// 斷開 gst_element_unlink (element1, element2);

三、元件狀態
當GStreamer框架中的元件通過管道連接好之後，它們就開始了各自的處理流程，期間一般會經歷多次狀態切換，其中每個元件在特定時刻將處於如下四種狀態之一：
NULL    這是所有元件的默認狀態，表明它剛剛創建，還沒有開始做任何事情。
READY   表明元件已經做好準備，隨時可以開始處理流程。
PAUSED  表明元件因某種原因暫時停止處理數據。
PLAYING 表明元件正在進行數據處理。
所有的元件都從NULL狀態開始，依次經歷NULL、READY、PAUSED、PLAYING等狀態間的轉換。元件當前所處的狀態可以通過調用gst_element_set_state()函數進行切換：
GstElement *bin; /* 創建元件，並將其連接成箱櫃bin */ 
gst_element_set_state (bin, GST_STATE_PLAYING);
默認情況下，管道及其包含的所有元件在創建之後將處於NULL狀態，此時它們不會進行任何操作。當管道使用完畢之後，不要忘記重新將管道的狀態切換回NULL狀態，讓其中
包含的所有元件能夠有機會釋放它們正在佔用的資源。
管道真正的處理流程是從第一次將其切換到READY狀態時開始的，此時管道及其包含的所有元件將做好相應的初始化工作，來為即將執行的數據處理過程做好準備。對於一個典
型的元件來講，處於READY狀態時需要執行的操作包括打開媒體文件和音頻設備等，或者試圖與位於遠端的媒體伺服器建立起連接。
處於READY狀態的管道一旦切換到PLAYING狀態，需要處理的多媒體數據就開始在整個管道中流動，並依次被管道中包含的各個元件進行處理，從而最終實現管道預先定義好的
某種多媒體功能。GStreamer框架也允許將管道直接從NULL狀態切換到PLAYING狀態，而不必經過中間的READY狀態。
正處於播放狀態的管道能夠隨時切換到PAUSED狀態，暫時停止管道中所有數據的流動，並能夠在需要的時候再次切換回PLAYING狀態。如果需要插入或者更改管道中的某個元件
，必須先將其切換到PAUSED或者NULL狀態，元件在處於PAUSED狀態時並不會釋放其佔用的資源。

四、實現MP3播放器
在理解了一些基本概念和處理流程之後，下面來看看如何利用GStreamer框架提供的元件，來實現一個簡單的MP3播放器。在圖１中描述的結構能夠很容易地映射成MP3播放器，
其中數據源元件負責從磁碟上讀取數據，過濾器元件負責對數據進行解碼，而接受器元件則負責將解碼後的數據寫入聲卡。
與其它眾多GNOME項目一樣，GStreamer也是用C語言實現的。如果想要在程式中應用GStreamer提供的各種功能，首先必須在主函數中調用 gst_init()來完成相應的初始化工作
，以便將用戶從命令行輸入的參數傳遞給GStreamer函數庫。一個典型的GStreamer應用程式的初始化如下所示：
#include <gst/gst.h> 
int main (int argc, char *argv[]) 
{ 
    gst_init (&argc, &argv); 
    /* ... */ 
}
接下去需要創建三個元件並連接成管道，由於所有GStreamer元件都具有相同的基類GstElement，因此能夠採用如下方式進行定義：
GstElement *pipeline, *filesrc, *decoder, *audiosink;
管道在GStreamer框架中是用來容納和管理元件的，下面的代碼將創建一條名為pipeline的新管道：
/* 創建用來容納元件的新管道 */ 
pipeline = gst_pipeline_new ("pipeline");       
數據源元件負責從磁碟文件中讀取數據，它具有名為location的屬性，用來指明文件在磁碟上的位置。使用標準的GObject屬性機制可以為元件設置相應的屬性：
/* 創建數據源元件 */ 
filesrc = gst_element_factory_make ("filesrc", "disk_source"); 
g_object_set (G_OBJECT (filesrc), "location", argv[1], NULL);
過濾器元件負責完成對MP3格式的數據進行解碼，最簡單的辦法是安裝mad這一插件，借助它來完成相應的解碼工作：
/* 創建過濾器元件 */ 
decoder = gst_element_factory_make ("mad", "decoder");
接收器元件負責將解碼後的數據利用聲卡播放出來：
/* 創建接收器元件 */ 
audiosink = gst_element_factory_make ("audiosink", "play_audio");
已經創建好的三個元件需要全部添加到管道中，並按順序連接起來：
/* 添加元件到管道中 */ 
gst_bin_add_many (GST_BIN (pipeline), filesrc, decoder, audiosink, NULL); 
/* 通過襯墊連接元件 */ 
gst_element_link_many (filesrc, decoder, audiosink, NULL);
所有準備工作都做好之後，就可以通過將管道的狀態切換到PLAYING狀態，來啟動整個管道的數據處理流程：
/* 啟動管道 */ 
gst_element_set_state (pipeline, GST_STATE_PLAYING);
由於沒有用到線程，因此必須通過不斷調用gst_bin_iterate()函數的辦法，來判斷管道的處理過程會在何時結束：
while (gst_bin_iterate (GST_BIN (pipeline)));
只要管道內還會繼續有新的事件產生，gst_bin_iterate()函數就會一直返回TRUE，只有當整個處理過程都結束的時候，該函數才會返回FALSE，此時就該終止管道並釋放佔用
的資源了：
/* 終止管道 */ 
gst_element_set_state (pipeline, GST_STATE_NULL); 
/* 釋放資源 */ 
gst_object_unref (GST_OBJECT (pipeline));

用GStreamer實現的MP3播放器的源代碼如下所示：
#include <gst/gst.h> 
int main (int argc, char *argv[]) 
{
    GstElement *pipeline, *filesrc, *decoder, *audiosink; gst_init(&argc, &argv); 
    if (argc != 2) { 
        g_print ("usage: %s <mp3 filename>/n", argv[0]); 
        exit (-1); 
    } 
    /* 創建一條新的管道 */ 
    pipeline = gst_pipeline_new ("pipeline"); 
    /* 生成用於讀取硬碟數據的元件 */ 
    filesrc = gst_element_factory_make ("filesrc", "disk_source"); 
    g_object_set (G_OBJECT (filesrc), "location", argv[1], NULL); 
    /* 創建解碼器元件 */ 
    decoder = gst_element_factory_make ("mad", "decoder"); 
    /* 創建音頻回放元件 */ 
    audiosink = gst_element_factory_make ("osssink", "play_audio"); 
    /* 將生成的元件添加到管道中 */ 
    gst_bin_add_many (GST_BIN (pipeline), filesrc, decoder, audiosink, NULL); 
    /* 連接各個元件 */ 
    gst_element_link_many (filesrc, decoder, audiosink, NULL); 
    /* 開始播放 */ 
    gst_element_set_state (pipeline, GST_STATE_PLAYING); 
    while (gst_bin_iterate (GST_BIN (pipeline))); 
    /* 停止管道處理流程 */ 
    gst_element_set_state (pipeline, GST_STATE_NULL); 
    /* 釋放佔用的資源 */ 
    gst_object_unref (GST_OBJECT (pipeline)); exit (0); 
}

五、小結
隨著 GNOME 桌面環境的不斷普及，GStreamer 作為一個強大的多媒體應用開發框架，已經開始受到越來越多人的關注。Gstreamer在設計時採用了非常靈活的體系結構，並且
提供了許多預定義的媒體處理模組，因此能夠極大簡化在Linux下開發多媒體應用的難度。
Ref website: http://hi.baidu.com/zhxust/blog/category/Gstreamer


/******************************************************************************/
cross compile gstreamer-0.10.25
/******************************************************************************/
I.設定環境變數並且編譯dependence library
#設定環境變數
export PATH=$PATH:$PWD/toolchain/crosstools_hf-linux-2.6.18.0_gcc-4.2-10ts_uclibc-nptl-0.9.29-20070423_20080721/bin 
export INSTALL_PATH=/opt/gstreamer
export CROSS_COMPILE_PATH=$PWD/toolchain/crosstools_hf-linux-2.6.18.0_gcc-4.2-10ts_uclibc-nptl-0.9.29-20070423_20080721/bin
export PKG_CONFIG_PATH=/opt/gstreamer/lib/pkgconfig

#install dependence library
1. gettext-0.17
download from: http://ftp.gnu.org/pub/gnu/gettext/gettext-0.17.tar.gz
./configure --prefix=$INSTALL_PATH --host=mipsel-linux --enable-static=no
make 
make install

2.libiconv-1.13
download from:http://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.13.1.tar.gz
./configure --prefix=$INSTALL_PATH --host=mipsel-linux --enable-static=no
make 
make install

3.glib-2.20.1
download from:http://ftp.acc.umu.se/pub/GNOME/sources/glib/2.20/glib-2.20.1.tar.gz
#create mipsel-linux.cache
mipsel-linux.cache content is:
-------------------------------------
glib_cv_stack_grows=no
glib_cv_uscore=no
ac_cv_func_posix_getpwuid_r=no
ac_cv_func_posix_getgrgid_r=no
-------------------------------------
./configure --prefix=$INSTALL_PATH --host=mipsel-linux --cache-file=mipsel-linux.cache --with-libiconv=gnu LDFLAGS=-L$INSTALL_PATH/lib CFLAGS=-I$INSTALL_PATH/include --enable-static=no
make 
make install

4.libxml2-2.7.2
download from:http://xmlsoft.org/sources/libxml2-2.7.2.tar.gz
./configure --prefix=$INSTALL_PATH --host=mipsel-linux LDFLAGS=-L$INSTALL_PATH/lib CFLAG=-I$INSTALL_PATH/include --enable-static=no
make 
make install

5.liboil-0.3.16
download from:http://liboil.freedesktop.org/download/liboil-0.3.16.tar.gz
./configure --prefix=$INSTALL_PATH --host=mipsel-linux LDFLAGS=-L$INSTALL_PATH/lib CFLAGS=-I$INSTALL_PATH/include
make
makeinstall

II.開始編譯gstreamer-0.10.25
download from:http://gstreamer.freedesktop.org/src/gstreamer/gstreamer-0.10.25.tar.gz
./configure --prefix=$INSTALL_PATH --host=mipsel-linux LDFLAGS=-L$INSTALL_PATH/lib CFLAGS=-I$INSTALL_PATH/include --disable-nls --disable-static --enable-binary-registry
make
make install

III.編譯gstreamer plugin (gst-plugins-base-0.10.25)
1.gst-plugins-base-0.10.25
download from:http://gstreamer.freedesktop.org/src/gst-plugins-base/gst-plugins-base-0.10.25.tar.gz
./configure --prefix=$INSTALL_PATH --host=mipsel-linux LDFLAGS=-L$INSTALL_PATH/lib CFLAGS=-I$INSTALL_PATH/include --with-pkg-config-path=/opt/gstreamer/lib/pkgconfig --disable-x --disable-xvideo --disable-xshm --disable-gnome_vfs --disable-cdparanoia --disable-libvisual --disable-alsa --disable-ogg --disable-oggtest --disable-pango --disable-vorbis --disable-vorbistest --disable-examples
make
make install
p.s. build gst-plugins-base-0.10.25 example need gtk-x11 dependence library, so --disable-examples
2.gst-plugins-good-0.10.17
download from:http://gstreamer.freedesktop.org/src/gst-plugins-good/gst-plugins-good-0.10.17.tar.gz

IV.執行 gstreamer
1.設定環境變數:
export LD_LIBRARY_PATH="/your/gstreamer/path/lib:${LD_LIBRARY_PATH}"
export GST_PLUGIN_PATH=/your/gstreamer/path/lib/gstreamer-0.10/

2.測試gstreamer
gst-launch -v fakesrc num_buffers=5 ! fakesink
gst-inspect: Element 與 plugin 查詢工具，，可觀看目前所擁有的elements
gst-launch: 動態建立管線的指令工具
 

/******************************************************************************/
// Build Gmediarender           
/******************************************************************************/
Requirements:
1. libupnp
2. liboil
3. gstreamer
4. gmediarender
5. gst-plugins-base

UBUNTU上先測試
1. libupnp
$ ./configure --prefix=/home/app_fd/libupnp-1.6.6/output
$ make clean && make && make install

2. liboil-0.3.14
$ ./configure --prefix=/home/app_fd/liboil-0.3.16/output
$ make clean && make && make install

3. gstreamer-0.10.35
$ ./configure --prefix=/home/app_fd/gstreamer0.10-0.10.28/output
$ make clean && make && make install

4. gmediarender-0.0.6
$ ./configure --prefix=/home/app_fd/gstreamer0.10-0.10.28/output
$ make clean && make && make install
$ 

excute output/bin/gmediarender
$ cd output/bin
$ ./gmediarender
可以在windows xp中的網路上的芳鄰中看到一個device : gmediarender 

;-------------------------------
Cross compiler
1. libupnp
$ ./configure --prefix=/home/app_fd/libupnp-1.6.6/output_96d CC=rsdk-linux-gcc --host=mips-linux --disable-static --enable-shared
$ make clean && make && make install

2. liboil-0.3.14
$ ./configure --prefix=/home/app_fd/liboil-0.3.16/output_96d

3. gstreamer-0.10.35
需要glib，所以要先裝glib
   a. zlib (已有build過了)
   b. libiconv
        $ ./configure --prefix=/home/app_fd/libiconv-1.14/output_96d --host=mips-linux CC=rsdk-linux-gcc
        $ make && make install
   c. gettext
        $ ./configure --prefix=/home/app_fd/gettext-0.18.1.1/output_96d --host=mips-linux CC=rsdk-linux-gcc CPPFLAGS=-L/home/app_fd/libxml2-2.7.8/output_96d/include -L/home/app_fd/libiconv-1.14/output_96d/lib LDFLAGS=-L/home/app_fd/libxml2-2.7.8/output_96d/include -L/home/app_fd/libiconv-1.14/output_96d/lib
        $ apt-get source gettext
        需要對spawn.h做如下修改：增加打「+」號的代碼
        # include <signal.h>
        #endif
       +#ifdef __UCLIBC__
       +# include <sched.h>
       +#endif
       +
        #include <sys/types.h>
        #ifndef __THROW
       $ make clean && make && make install
   d. glib
   出現了如下錯誤：
   checking for growing stack pointer... configure: error: cannot run test program while cross compiling

   參考 from :http://blog.csdn.net/absurd/article/details/646993
   原來configure不能為交叉編譯檢查glib_cv_stack_grows，glib_cv_stack_grows表示堆棧的增長方向。
   configure無法在目標機上運行測試程式，自然無法檢查，只好手工指定。順便看一下還哪些相關的變數不能檢查的，一起寫到cache文件中，並重新配置：
   $ vim mips-linux.cache
   glib_cv_stack_grows=no
   glib_cv_uscore=no
   ac_cv_func_posix_getpwuid_r=no
   ac_cv_func_posix_getgrgid_r=no
    $ ./configure --prefix=/home/app_fd/glib2.0-2.24.1/output_96d --host=mips-linux CC=rsdk-linux-gcc --cache-file=mips-linux.cache CPPFLAGS=-I/home/app_fd/libiconv-1.14/output_96d/include -I/home/app_fd/zlib-1.2.5/output_96d/include -I/home/app_fd/gettext-0.18.1.1/output_96d/include LDFLAGS=-L/home/app_fd/libiconv-1.14/output_96d/lib -L/home/app_fd/zlib-1.2.5/output_96d/lib -L/home/app_fd/gettext-0.18.1.1/output_96d/lib
    $ make && make install

   e. 安裝 gstreamer-0.10.35
    $ ./configure --prefix=/home/app_fd/gstreamer-0.10.35/output_96d --disable-gst-debug --disable-examples --disable-tests --disable-loadsave --enable-gobject-cast-checks=no --enable-glib-assert=no --without-gnu-ld --disable-debug --host=mips-linux CC=rsdk-linux-gcc GLIB_CFLAGS="-I/home/app_fd/glib2.0-2.24.1/output_96d/include/glib-2.0 -I/home/app_fd/glib2.0-2.24.1/output_96d/lib/glib-2.0/include" GLIB_LIBS="-L/home/app_fd/glib2.0-2.24.1/output_96d/lib -lglib-2.0 -lgio-2.0 -lgobject-2.0 -lgthread-2.0 -lgmodule-2.0" GLIB_ONLY_CFLAGS="-I/home/app_fd/glib2.0-2.24.1/output_96d/include -I/home/app_fd/glib2.0-2.24.1/output_96d/lib/glib-2.0/include" GLIB_ONLY_LIBS=/home/app_fd/glib2.0-2.24.1/output_96d/lib/ XML_CFLAGS=-I/home/app_fd/libxml2-2.7.8/output_96d/include XML_LIBS=-L/home/app_fd/libxml2-2.7.8/output_96d/lib
    $ make clean && make && make install

   出現了如下錯誤：
    /home/app_fd/glib2.0-2.24.1/output_96d/lib/libgio-2.0.so: undefined reference to `inflateReset'
    /home/app_fd/glib2.0-2.24.1/output_96d/lib/libglib-2.0.so: undefined reference to `libintl_gettext'
    /home/app_fd/glib2.0-2.24.1/output_96d/lib/libgio-2.0.so: undefined reference to `inflateEnd'
    /home/app_fd/glib2.0-2.24.1/output_96d/lib/libglib-2.0.so: undefined reference to `libintl_bind_textdomain_codeset'
    /home/app_fd/glib2.0-2.24.1/output_96d/lib/libgio-2.0.so: undefined reference to `deflate'
    /home/app_fd/glib2.0-2.24.1/output_96d/lib/libgio-2.0.so: undefined reference to `deflateInit_'
    /home/app_fd/glib2.0-2.24.1/output_96d/lib/libglib-2.0.so: undefined reference to `libiconv'
    /home/app_fd/glib2.0-2.24.1/output_96d/lib/libgio-2.0.so: undefined reference to `inflateInit2_'
    /home/app_fd/glib2.0-2.24.1/output_96d/lib/libgio-2.0.so: undefined reference to `inflate'
    /home/app_fd/glib2.0-2.24.1/output_96d/lib/libgio-2.0.so: undefined reference to `deflateEnd'
    /home/app_fd/glib2.0-2.24.1/output_96d/lib/libgio-2.0.so: undefined reference to `deflateReset'
    /home/app_fd/glib2.0-2.24.1/output_96d/lib/libglib-2.0.so: undefined reference to `libintl_dgettext'
    /home/app_fd/glib2.0-2.24.1/output_96d/lib/libglib-2.0.so: undefined reference to `libiconv_close'
    /home/app_fd/glib2.0-2.24.1/output_96d/lib/libglib-2.0.so: undefined reference to `libintl_textdomain'
    /home/app_fd/glib2.0-2.24.1/output_96d/lib/libglib-2.0.so: undefined reference to `libiconv_open'
    /home/app_fd/glib2.0-2.24.1/output_96d/lib/libglib-2.0.so: undefined reference to `libintl_bindtextdomain'
    /home/app_fd/glib2.0-2.24.1/output_96d/lib/libgio-2.0.so: undefined reference to `inflateInit_'
    /home/app_fd/glib2.0-2.24.1/output_96d/lib/libgio-2.0.so: undefined reference to `deflateInit2_'
    /home/app_fd/glib2.0-2.24.1/output_96d/lib/libglib-2.0.so: undefined reference to `libintl_dngettext'
    collect2: ld returned 1 exit status
    make[4]: *** [gst-plugin-scanner] Error 1
    make[4]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/helpers'
    make[3]: *** [all-recursive] Error 1
    make[3]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst'
    make[2]: *** [all-recursive] Error 1
    make[2]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs'
    make[1]: *** [all-recursive] Error 1
    make[1]: Leaving directory `/home/app_fd/gstreamer-0.10.35'
    make: *** [all] Error 2

    $ ./configure --prefix=/home/app_fd/gstreamer-0.10.35/output_96d --disable-gst-debug --disable-examples --disable-tests --disable-loadsave --without-gnu-ld --disable-debug --host=mips-linux CC=rsdk-linux-gcc --with-libiconv-prefix=/home/app_fd/libiconv-1.14/output_96d GLIB_CFLAGS="-I/home/app_fd/glib2.0-2.24.1/output_96d/include/glib-2.0 -I/home/app_fd/glib2.0-2.24.1/output_96d/lib/glib-2.0/include" GLIB_LIBS="-L/home/app_fd/glib2.0-2.24.1/output_96d/lib -lgio-2.0 -lgobject-2.0 -lgthread-2.0 -lgmodule-2.0 -lintl -lasprintf -lgettextlib -lz" XML_CFLAGS=-I/home/app_fd/libxml2-2.7.8/output_96d/include XML_LIBS=-L/home/app_fd/libxml2-2.7.8/output_96d/lib CPPFLAGS="-I/home/app_fd/gettext-0.18.1.1/output_96d/include -I/home/app_fd/zlib-1.2.5/output_96d/include" LDFLAGS="-L/home/app_fd/gettext-0.18.1.1/output_96d/lib -L/home/app_fd/zlib-1.2.5/output_96d/lib"
    $ make
   出現了如下錯誤：
     CCLD   libgstreamer-0.10.la
    libtool: link: cannot find the library `/home/shunyen/rsdk/release/rsdk-1.5.5/linux/uclibc/mips-linux/lib/5281/libstdc++.la' or unhandled argument `/home/shunyen/rsdk/release/rsdk-1.5.5/linux/uclibc/mips-linux/lib/5281/libstdc++.la'
    make[4]: *** [libgstreamer-0.10.la] Error 1
    make[4]: Leaving directory `/home/app_fd/gstreamer-0.10.35/gst'
    make[3]: *** [all-recursive] Error 1
    make[3]: Leaving directory `/home/app_fd/gstreamer-0.10.35/gst'
    make[2]: *** [all] Error 2
    make[2]: Leaving directory `/home/app_fd/gstreamer-0.10.35/gst'
    make[1]: *** [all-recursive] Error 1
    make[1]: Leaving directory `/home/app_fd/gstreamer-0.10.35'
    make: *** [all] Error 2

//----------------------- 
//---  SDK v3.2
//----------------------- 
Cross compiler step
1. libupnp
$ ./configure --prefix=/home/app_fd/libupnp-1.6.15/output_96d-SDKv3.2 CC=rsdk-linux-gcc --host=mips-linux --disable-static --enable-shared
$ make clean && make && make install

需要glib，所以要先裝glib
2. libxml2-2.7.8#
$ ./configure --prefix=/home/app_fd/libxml2-2.7.8/output_96d-SDKv3.2 CC=rsdk-linux-gcc --host=mips-linux
發現錯誤：
/bin/rm: cannot remove `libtoolT': No such file or directory
解決方法：
在執行./configure 之前，先執行：
# autoreconf --force --install
# libtoolize --automake --force
# automake --force --add-missing
還是無法解決，改用下個方法：
直接打開 configure，把 $RM 「$cfgfile」 那行刪除掉，重新再運行 ./configure 就可以了。
$ make clean && make && make install

3. zlib (已有build過了)

4. libiconv
   $ ./configure --prefix=/home/app_fd/libiconv-1.14/output_96d_SDKv3.2 --host=mips-linux CC=rsdk-linux-gcc
   $ make && make install

5. gettext
   $ ./configure --prefix=/home/app_fd/gettext-0.18.1.1/output_96d-SDKv3.2 --host=mips-linux CC=rsdk-linux-gcc CPPFLAGS="-I/home/app_fd/libxml2-2.7.8/output_96d-SDKv3.2/include -I/home/app_fd/libiconv-1.14/output_96d-SDKv3.2/include" LDFLAGS="-L/home/app_fd/libxml2-2.7.8/output_96d-SDKv3.2/lib -L/home/app_fd/libiconv-1.14/output_96d-SDKv3.2/lib"
        需要對spawn.h做如下修改：增加打「+」號的代碼
        # include <signal.h>
        #endif
       +#ifdef __UCLIBC__
       +# include <sched.h>
       +#endif
       +
        #include <sys/types.h>
        #ifndef __THROW
       $ make clean && make && make install
   $ make clean && make && make install

6. liboil-0.3.14
$ ./configure --prefix=/home/app_fd/liboil-0.3.16/output_96d-SDKv3.2 CC=rsdk-linux-gcc --host=mips-linux --disable-static --enable-shared --disable-glib
$ make clean && make && make install

7. glib2
   在build時會出現了如下錯誤：
   checking for growing stack pointer... configure: error: cannot run test program while cross compiling

   參考 from :http://blog.csdn.net/absurd/article/details/646993
   原來configure不能為交叉編譯檢查glib_cv_stack_grows，glib_cv_stack_grows表示堆棧的增長方向。
   configure無法在目標機上運行測試程式，自然無法檢查，只好手工指定。順便看一下還哪些相關的變數不能檢查的，一起寫到cache文件中，並重新配置：
   $ vim mips-linux.cache
   glib_cv_stack_grows=no
   glib_cv_uscore=no
   ac_cv_func_posix_getpwuid_r=no
   ac_cv_func_posix_getgrgid_r=no
   $ ./configure --prefix=/home/app_fd/glib2.0-2.24.1/output_96d-SDKv3.2 --host=mips-linux CC=rsdk-linux-gcc --cache-file=mips-linux.cache --with-libiconv=gnu CPPFLAGS="-I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/include -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include" LDFLAGS="-L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib"
   $ make && make install


8. 安裝 gstreamer-0.10.35
   $ ./configure --prefix=/home/app_fd/gstreamer-0.10.35/output_96d_SDKv3.2 --disable-gst-debug --disable-examples --disable-tests --disable-loadsave --without-gnu-ld --disable-debug --host=mips-linux CC=rsdk-linux-gcc --with-libiconv-prefix=/home/app_fd/libiconv-1.14/output_96d_SDKv3.2 GLIB_CFLAGS="-I/home/app_fd/glib2.0-2.24.1/output_96d_SDKv3.2/include -I/home/app_fd/glib2.0-2.24.1/output_96d_SDKv3.2/lib/glib-2.0/include" GLIB_LIBS=-L/home/app_fd/glib2.0-2.24.1/output_96d_SDKv3.2/lib XML_CFLAGS=-I/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/include XML_LIBS=-L/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/lib CPPFLAGS=-I/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/include LIBS=-L/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/lib
   $ make clean && make && make install
   出現了如下錯誤：
   lex._gst_parse_yy.c:2470: error: expected '=', ',', ';', 'asm' or '__attribute__' before '{' token
   lex._gst_parse_yy.c:2482: error: expected '=', ',', ';', 'asm' or '__attribute__' before '{' token
   ../../gst/gstcaps.h:221: error: old-style parameter declarations in prototyped function definition
   parse.l:148: error: expected '{' at end of input
   make[4]: *** [libgstparse_la-lex._gst_parse_yy.lo] Error 1
   make[4]: Leaving directory `/home/app_fd/gstreamer-0.10.35/gst/parse'
   make[3]: *** [all-recursive] Error 1
   make[3]: Leaving directory `/home/app_fd/gstreamer-0.10.35/gst'
   make[2]: *** [all] Error 2
   make[2]: Leaving directory `/home/app_fd/gstreamer-0.10.35/gst'
   make[1]: *** [all-recursive] Error 1
   make[1]: Leaving directory `/home/app_fd/gstreamer-0.10.35'
   make: *** [all] Error 2

更正configure 設定：
   $ ./configure --prefix=/home/app_fd/gstreamer-0.10.35/output_96d_SDKv3.2 --disable-nls --disable-gst-debug --disable-examples --disable-tests --disable-loadsave --without-gnu-ld --disable-debug --host=mips-linux CC=rsdk-linux-gcc CPPFLAGS=-I/home/app_fd/glib2.0-2.24.1/output_96d_SDKv3.2/include -I/home/app_fd/glib2.0-2.24.1/output_96d_SDKv3.2/lib/glib-2.0 -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include -I/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/include -I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/include LDFLAGS=-L/home/app_fd/glib2.0-2.24.1/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib -L/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/lib -L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/lib
   $ make clean && make && make install
出現了如下錯誤：
/home/Realtek/rtl819x-SDK-v3.2/rtl819x/toolchain/rsdk-1.5.5-5281-EB-2.6.30-0.9.30.3-110714/bin/../lib/gcc/mips-linux/4.4.5-1.5.5p4/../../../../mips-linux/bin/ld: warning: libiconv.so.2, needed by ../../../gst/.libs/libgstreamer-0.10.so, not found (try using -rpath or -rpath-link)
/home/Realtek/rtl819x-SDK-v3.2/rtl819x/toolchain/rsdk-1.5.5-5281-EB-2.6.30-0.9.30.3-110714/bin/../lib/gcc/mips-linux/4.4.5-1.5.5p4/../../../../mips-linux/bin/ld: warning: libintl.so.8, needed by ../../../gst/.libs/libgstreamer-0.10.so, not found (try using -rpath or -rpath-link)
/home/app_fd/glib2.0-2.24.1/output_96d-SDKv3.2/lib/libglib-2.0.so: undefined reference to `libintl_gettext'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_date_time_get_month'
/home/app_fd/glib2.0-2.24.1/output_96d-SDKv3.2/lib/libglib-2.0.so: undefined reference to `libintl_bind_textdomain_codeset'
/home/app_fd/glib2.0-2.24.1/output_96d-SDKv3.2/lib/libglib-2.0.so: undefined reference to `libiconv'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_date_time_new_from_unix_local'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_date_time_get_hour'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_date_time_new_now_local'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_date_time_get_utc_offset'
/home/app_fd/glib2.0-2.24.1/output_96d-SDKv3.2/lib/libglib-2.0.so: undefined reference to `libintl_dgettext'
/home/app_fd/glib2.0-2.24.1/output_96d-SDKv3.2/lib/libglib-2.0.so: undefined reference to `libiconv_close'
/home/app_fd/glib2.0-2.24.1/output_96d-SDKv3.2/lib/libglib-2.0.so: undefined reference to `libintl_textdomain'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_time_zone_unref'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_date_time_new_local'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `__sync_fetch_and_sub_4'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_time_zone_new'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `__sync_fetch_and_add_4'
/home/app_fd/glib2.0-2.24.1/output_96d-SDKv3.2/lib/libglib-2.0.so: undefined reference to `libiconv_open'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_date_time_unref'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_date_time_new_now_utc'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_date_time_new'
/home/app_fd/glib2.0-2.24.1/output_96d-SDKv3.2/lib/libglib-2.0.so: undefined reference to `libintl_bindtextdomain'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_date_time_new_from_unix_utc'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_date_time_get_year'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_date_time_get_microsecond'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_date_time_compare'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_date_time_get_day_of_month'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_object_notify_by_pspec'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_date_time_get_minute'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `__sync_bool_compare_and_swap_4'
/home/app_fd/glib2.0-2.24.1/output_96d-SDKv3.2/lib/libglib-2.0.so: undefined reference to `libintl_dngettext'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_error_get_type'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `g_date_time_get_second'
collect2: ld returned 1 exit status
make[4]: *** [gst-plugin-scanner] Error 1
make[4]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/helpers'
make[3]: *** [all-recursive] Error 1
make[3]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst'
make[2]: *** [all-recursive] Error 1
make[2]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/gstreamer-0.10.35'
make: *** [all] Error 2
root@js-desktop:/home/app_fd/gstreamer-0.10.35#
[dexter] 2010-04-17 testing...

9. 在glib2中找不到錯誤訊息中的定義，所以改安裝 glib-2.33.1
./configure --prefix=/home/app_fd/glib-2.33.1/output_96d-SDKv3.2 --host=mips-linux CC=rsdk-linux-gcc --cache-file=mips-linux.cache --with-libiconv=gnu CPPFLAGS="-I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/include -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include" LDFLAGS="-L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib"
出現下列錯誤：
configure: error: cannot run test program while cross compiling
   在build時會出現了如下錯誤：
   checking for growing stack pointer... configure: error: cannot run test program while cross compiling

   參考 from :http://blog.csdn.net/absurd/article/details/646993
   原來configure不能為交叉編譯檢查glib_cv_stack_grows，glib_cv_stack_grows表示堆棧的增長方向。
   configure無法在目標機上運行測試程式，自然無法檢查，只好手工指定。順便看一下還哪些相關的變數不能檢查的，一起寫到cache文件中，並重新配置：
   $ vim mips-linux.cache
   glib_cv_stack_grows=no
   glib_cv_uscore=no
   ac_cv_func_posix_getpwuid_r=no
   ac_cv_func_posix_getgrgid_r=no

再configure...
   $ ./configure --prefix=/home/app_fd/glib-2.33.1/output_96d-SDKv3.2 --host=mips-linux CC=rsdk-linux-gcc --cache-file=mips-linux.cache --with-libiconv=gnu CPPFLAGS="-I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/include -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include" LDFLAGS="-L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib"
   $ make && make install
出現下列錯誤：
configure: error: Could not find a glib-compile-resources in your PATH
再configure...
$ ./configure --prefix=/home/app_fd/glib-2.33.1/output_96d-SDKv3.2 --host=mips-linux CC=rsdk-linux-gcc --cache-file=mips-linux.cache CPPFLAGS="-I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/include -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include" LDFLAGS="-L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib"
增加ac_cv_path_GLIB_COMPILE_RESOURCES=yes
   $ vim mips-linux.cache
  glib_cv_stack_grows=no
  glib_cv_uscore=no
  ac_cv_func_posix_getpwuid_r=no
  ac_cv_func_posix_getgrgid_r=no
  ac_cv_path_GLIB_COMPILE_RESOURCES=yes

再configure...
$ ./configure --prefix=/home/app_fd/glib-2.33.1/output_96d-SDKv3.2 --host=mips-linux CC=rsdk-linux-gcc --cache-file=mips-linux.cache CPPFLAGS="-I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/include -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include" LDFLAGS="-L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib"
configure 成功，
$make clean && make && make install
出現下列錯誤：
/home/Realtek/rtl819x-SDK-v3.2/rtl819x/toolchain/rsdk-1.5.5-5281-EB-2.6.30-0.9.30.3-110714/bin/../lib/gcc/mips-linux/4.4.5-1.5.5p4/../../../../mips-linux/bin/ld: warning: libiconv.so.2, needed by ./.libs/libglib-2.0.so, not found (try using -rpath or -rpath-link)
./.libs/libglib-2.0.so: undefined reference to `libiconv'
./.libs/libglib-2.0.so: undefined reference to `libiconv_close'
./.libs/libglib-2.0.so: undefined reference to `libiconv_open'
collect2: ld returned 1 exit status
make[4]: *** [gtester] Error 1
make[4]: Leaving directory `/home/app_fd/glib-2.33.1/glib'
make[3]: *** [all-recursive] Error 1
make[3]: Leaving directory `/home/app_fd/glib-2.33.1/glib'
make[2]: *** [all] Error 2
make[2]: Leaving directory `/home/app_fd/glib-2.33.1/glib'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/glib-2.33.1'
make: *** [all] Error 2

再configure...
./configure --prefix=/home/app_fd/glib-2.33.1/output_96d-SDKv3.2 --host=mips-linux CC=rsdk-linux-gcc --cache-file=mips-linux.cache CFLAGS=-liconv CPPFLAGS="-I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/include -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include" LDFLAGS="-L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib"
configure 成功，
$make clean && make && make install
出現錯誤：
  CC     libgobject_2_0_la-gclosure.lo
gclosure.c:29:17: error: ffi.h: No such file or directory
gclosure.c:1128: error: expected '=', ',', ';', 'asm' or '__attribute__' before '*' token
gclosure.c: In function 'value_from_ffi_type':
gclosure.c:1217: error: 'ffi_arg' undeclared (first use in this function)
gclosure.c:1217: error: (Each undeclared identifier is reported only once
gclosure.c:1217: error: for each function it appears in.)
gclosure.c:1217: error: 'int_val' undeclared (first use in this function)
gclosure.c:1217: error: expected expression before ')' token
gclosure.c: At top level:
gclosure.c:1296: error: expected '=', ',', ';', 'asm' or '__attribute__' before '*' token
gclosure.c: In function 'g_cclosure_marshal_generic':
gclosure.c:1391: error: 'ffi_type' undeclared (first use in this function)
gclosure.c:1391: error: 'rtype' undeclared (first use in this function)
gclosure.c:1394: error: 'atypes' undeclared (first use in this function)
gclosure.c:1397: error: 'ffi_cif' undeclared (first use in this function)
gclosure.c:1397: error: expected ';' before 'cif'
gclosure.c:1405: warning: implicit declaration of function 'value_to_ffi_type'
gclosure.c:1409: error: 'ffi_type_void' undeclared (first use in this function)
gclosure.c:1412: error: 'ffi_arg' undeclared (first use in this function)
gclosure.c:1415: error: expected expression before ')' token
gclosure.c:1427: error: 'ffi_type_pointer' undeclared (first use in this function)
gclosure.c:1451: warning: implicit declaration of function 'ffi_prep_cif'
gclosure.c:1451: error: 'cif' undeclared (first use in this function)
gclosure.c:1451: error: 'FFI_DEFAULT_ABI' undeclared (first use in this function)
gclosure.c:1451: error: 'FFI_OK' undeclared (first use in this function)
gclosure.c:1454: warning: implicit declaration of function 'ffi_call'
gclosure.c: In function 'g_cclosure_marshal_generic_va':
gclosure.c:1469: error: 'ffi_type' undeclared (first use in this function)
gclosure.c:1469: error: 'rtype' undeclared (first use in this function)
gclosure.c:1472: error: 'atypes' undeclared (first use in this function)
gclosure.c:1476: error: 'ffi_cif' undeclared (first use in this function)
gclosure.c:1476: error: expected ';' before 'cif'
gclosure.c:1489: error: 'ffi_type_void' undeclared (first use in this function)
gclosure.c:1492: error: 'ffi_arg' undeclared (first use in this function)
gclosure.c:1495: error: expected expression before ')' token
gclosure.c:1504: error: 'ffi_type_pointer' undeclared (first use in this function)
gclosure.c:1525: warning: implicit declaration of function 'va_to_ffi_type'
gclosure.c:1547: error: 'cif' undeclared (first use in this function)
gclosure.c:1547: error: 'FFI_DEFAULT_ABI' undeclared (first use in this function)
gclosure.c:1547: error: 'FFI_OK' undeclared (first use in this function)
make[4]: *** [libgobject_2_0_la-gclosure.lo] Error 1
make[4]: Leaving directory `/home/app_fd/glib-2.33.1/gobject'
make[3]: *** [all-recursive] Error 1
make[3]: Leaving directory `/home/app_fd/glib-2.33.1/gobject'
make[2]: *** [all] Error 2
make[2]: Leaving directory `/home/app_fd/glib-2.33.1/gobject'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/glib-2.33.1'
make: *** [all] Error 2

再configure...
./configure --prefix=/home/app_fd/glib-2.33.1/output_96d-SDKv3.2 --host=mips-linux CC=rsdk-linux-gcc --cache-file=mips-linux.cache CFLAGS="-liconv -lffi" CPPFLAGS="-I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/include -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include" LDFLAGS="-L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib"
configure 成功，
$make clean && make && make install
出現錯誤：
(process:4605): GLib-Genmarshal-WARNING **: failed to open "--valist-marshallers": No such file or directory
make[4]: *** [marshalers.c] Error 1
make[4]: Leaving directory `/home/app_fd/glib-2.33.1/gobject/tests'
make[3]: *** [all-recursive] Error 1
make[3]: Leaving directory `/home/app_fd/glib-2.33.1/gobject'
make[2]: *** [all] Error 2
make[2]: Leaving directory `/home/app_fd/glib-2.33.1/gobject'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/glib-2.33.1'
make: *** [all] Error 2

再configure...
./configure --prefix=/home/app_fd/glib-2.33.1/output_96d-SDKv3.2 --host=mips-linux CC=rsdk-linux-gcc --cache-file=mips-linux.cache CFLAGS=-liconv CPPFLAGS="-I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/include -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include" LDFLAGS="-L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib"
出現錯誤：
Could not find a glib-genmarshal in your PAT mips-linux.cache
修改mips-linux.cache
ac_cv_type_long_long=yes
glib_cv_stack_grows=no
glib_cv_uscore=no
ac_cv_func_posix_getpwuid_r=no
ac_cv_func_posix_getgrgid_r=yes
ac_cv_path_GLIB_COMPILE_RESOURCES=yes
ac_cv_path_GLIB_GENMARSHAL=yes
ac_cv_path_GLIB_COMPILE_SCHEMAS=yes


再configure...
./configure --prefix=/home/app_fd/glib-2.33.1/output_96d-SDKv3.2 --host=mips-linux CC=rsdk-linux-gcc --cache-file=mips-linux.cache CFLAGS=-liconv CPPFLAGS="-I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/include -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include" LDFLAGS="-L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib"
configure 成功，
$make clean && make && make install
出現錯誤：
同：無libffi

再configure...
./configure --prefix=/home/app_fd/glib-2.33.1/output_96d-SDKv3.2 --host=mips-linux CC=rsdk-linux-gcc --cache-file=mips-linux.cache CFLAGS="-liconv -lffi" CPPFLAGS="-I/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi-3.0.11/include -I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/include -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include" LDFLAGS="-L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib -L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib"
configure 成功，
$make clean && make && make install
出現錯誤：
echo glib-types.h gbinding.h gboxed.h gclosure.h genums.h gmarshal.h gobject.h gparam.h gparamspecs.h gsignal.h gsourceclosure.h gtype.h gtypemodule.h gtypeplugin.h gvalue.h gvaluearray.h gvaluecollector.h gvaluetypes.h gobjectnotifyqueue.c > gobject-public-headers.txt.tmp && mv gobject-public-headers.txt.tmp gobject-public-headers.txt
make[4]: Leaving directory `/home/app_fd/glib-2.33.1/gobject'
Making all in tests
make[4]: Entering directory `/home/app_fd/glib-2.33.1/gobject/tests'
  GEN    marshalers.h
(process:9186): GLib-Genmarshal-WARNING **: failed to open "--valist-marshallers": No such file or directory
make[4]: *** [marshalers.h] Error 1
make[4]: Leaving directory `/home/app_fd/glib-2.33.1/gobject/tests'
make[3]: *** [all-recursive] Error 1
make[3]: Leaving directory `/home/app_fd/glib-2.33.1/gobject'
make[2]: *** [all] Error 2
make[2]: Leaving directory `/home/app_fd/glib-2.33.1/gobject'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/glib-2.33.1'
make: *** [all] Error 2

PS:有人回說修改一下Makefile.am，讓它使用Host的glib-genmarshal。(未測過)
系統裡本來有一個 glib-genmarshal，調用系統原來的 glib-genmarshal，估計不能編譯新版本的glib，把本地編譯出來的 glib-genmarshal，也copy到/usr/local/bin.
需要讓make調用新的 glib-genmarshal，怎麼辦？直接修改powerpc-linux.cache文件，找到 glib-genmarshal這一行，把路徑改成/usr/local/bin,在執行configure，make 
，make install。

增加ac_cv_path_GLIB_GENMARSHAL=yes
   $ vim mips-linux.cache
再configure...
$ ./configure --prefix=/home/app_fd/glib-2.33.1/output_96d-SDKv3.2 --host=mips-linux CC=rsdk-linux-gcc --cache-file=mips-linux.cache CFLAGS="-liconv -lffi" CPPFLAGS="-I/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi-3.0.11/include -I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/include -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include" LDFLAGS="-L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib -L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib"
configure 成功，
$ make clean && make && make install
出現錯誤：
echo glib-types.h gbinding.h gboxed.h gclosure.h genums.h gmarshal.h gobject.h gparam.h gparamspecs.h gsignal.h gsourceclosure.h gtype.h gtypemodule.h gtypeplugin.h gvalue.h gvaluearray.h gvaluecollector.h gvaluetypes.h gobjectnotifyqueue.c > gobject-public-headers.txt.tmp && mv gobject-public-headers.txt.tmp gobject-public-headers.txt
make[4]: Leaving directory `/home/app_fd/glib-2.33.1/gobject'
Making all in tests
make[4]: Entering directory `/home/app_fd/glib-2.33.1/gobject/tests'
  GEN    marshalers.h
yes: invalid option -- '-'
Try `yes --help' for more information.
make[4]: *** [marshalers.h] Error 1
make[4]: Leaving directory `/home/app_fd/glib-2.33.1/gobject/tests'
make[3]: *** [all-recursive] Error 1
make[3]: Leaving directory `/home/app_fd/glib-2.33.1/gobject'
make[2]: *** [all] Error 2
make[2]: Leaving directory `/home/app_fd/glib-2.33.1/gobject'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/glib-2.33.1'
make: *** [all] Error 2

再configure...
$ ./configure --prefix=/home/app_fd/glib-2.33.1/output_96d-SDKv3.2 --host=mips-linux CC=rsdk-linux-gcc --cache-file=mips-linux.cache CFLAGS="-liconv -lffi" CPPFLAGS="-I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include -I/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi-3.0.11/include" LDFLAGS="-L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib -L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib" ZLIB_CFLAGS=-I/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/include ZLIB_LIBS=-L/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/lib
$ make clean && make && make install
出現錯誤：
同上。

再輸入一次make
$make
出現錯誤：
make[5]: Entering directory `/home/app_fd/glib-2.33.1/gobject/tests'
  CC     boxed.o
  CCLD   boxed
  CC     enums.o
  CCLD   enums
  CC     param.o
  CCLD   param
  CC     signals.o
signals.c: In function 'test_class_init':
signals.c:159: error: 'test_INT__VOID' undeclared (first use in this function)
signals.c:159: error: (Each undeclared identifier is reported only once
signals.c:159: error: for each function it appears in.)
signals.c:163: error: 'test_INT__VOIDv' undeclared (first use in this function)
signals.c:181: error: 'test_UINT__VOIDv' undeclared (first use in this function)
signals.c:205: error: 'test_VOID__INT_BOOLEAN_CHAR_UCHAR_UINT_LONG_ULONG_ENUM_FLAGS_FLOAT_DOUBLE_STRING_PARAM_BOXED_POINTER_OBJECT_VARIANT_INT64_UINT64' undeclared (first use in this function)
signals.c:255: error: 'test_VOID__INT_BOOLEAN_CHAR_UCHAR_UINT_LONG_ULONG_ENUM_FLAGS_FLOAT_DOUBLE_STRING_PARAM_BOXED_POINTER_OBJECT_VARIANT_INT64_UINT64v' undeclared (first use in this function)
make[5]: *** [signals.o] Error 1
make[5]: Leaving directory `/home/app_fd/glib-2.33.1/gobject/tests'
make[4]: *** [all] Error 2
make[4]: Leaving directory `/home/app_fd/glib-2.33.1/gobject/tests'
make[3]: *** [all-recursive] Error 1
make[3]: Leaving directory `/home/app_fd/glib-2.33.1/gobject'
make[2]: *** [all] Error 2
make[2]: Leaving directory `/home/app_fd/glib-2.33.1/gobject'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/glib-2.33.1'
make: *** [all] Error 2

放棄glib-2.33.1，改用 glib-2.30.3版
1. echo ac_cv_type_long_long=yes>mips-linux.cache;echo glib_cv_long_long_format=ll>>mips-linux.cache;echo glib_cv_stack_grows=no>>mips-linux.cache;echo glib_cv_uscore=no>>mips-linux.cache;echo ac_cv_func_posix_getpwuid_r=yes>>mips-linux.cache;echo ac_cv_func_posix_getgrgid_r=yes>>mips-linux.cache;echo ac_cv_c_bigendian=no >> mips-linux.cache
2. $ ./configure --prefix=/home/app_fd/glib-2.30.3/output_96d_SDKv3.2 --host=mips-linux --target=mips-linux CC=rsdk-linux-gcc --cache-file=mips-linux.cache CFLAGS="-liconv -lffi" CPPFLAGS="-I/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi-3.0.11/include -I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/include -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include" LDFLAGS="-L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib -L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/zlib-1.2.5/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib"
3. make && make install
成功。

10. 安裝 gstreamer-0.10.35
$ ./configure --prefix=/home/app_fd/gstreamer-0.10.35/output_96d_SDKv3.2 --disable-gst-debug --disable-examples --disable-tests --disable-loadsave --enable-gobject-cast-checks=no --enable-glib-assert=no --without-gnu-ld --disable-debug --host=mips-linux CC=rsdk-linux-gcc GLIB_CFLAGS="-I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/include/glib-2.0 -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/glib-2.0/include" GLIB_LIBS="-L/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib -lglib-2.0 -lgio-2.0 -lgobject-2.0 -lgthread-2.0 -lgmodule-2.0" GLIB_ONLY_CFLAGS="-I/home/app_fd/glib2.0-2.24.1/output_96d_SDKv3.2/include -I/home/app_fd/glib2.0-2.24.1/output_96d_SDKv3.2/lib/glib-2.0/include" GLIB_ONLY_LIBS=/home/app_fd/glib2.0-2.24.1/output_96d_SDKv3.2/lib/ XML_CFLAGS=-I/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/include XML_LIBS=-L/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/lib
$ make clean && make && make install

出現錯誤：
make[5]: Entering directory `/home/app_fd/gstreamer-0.10.35/libs/gst/check'
Making all in libcheck
make[6]: Entering directory `/home/app_fd/gstreamer-0.10.35/libs/gst/check/libcheck'
  CC     libcheckinternal_la-check.lo
  CC     libcheckinternal_la-check_error.lo
  CC     libcheckinternal_la-check_list.lo
  CC     libcheckinternal_la-check_log.lo
  CC     libcheckinternal_la-check_msg.lo
  CC     libcheckinternal_la-check_pack.lo
  CC     libcheckinternal_la-check_print.lo
  CC     libcheckinternal_la-check_run.lo
  CC     libcheckinternal_la-check_str.lo
  CCLD   libcheckinternal.la
make[6]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/check/libcheck'
make[6]: Entering directory `/home/app_fd/gstreamer-0.10.35/libs/gst/check'
  CC     libgstcheck_0.10_la-gstbufferstraw.lo
  CC     libgstcheck_0.10_la-gstcheck.lo
  CC     libgstcheck_0.10_la-gstconsistencychecker.lo
  GEN    exports.sym
  CCLD   libgstcheck-0.10.la
make[6]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/check'
make[5]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/check'
make[4]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/check'
Making all in net
make[4]: Entering directory `/home/app_fd/gstreamer-0.10.35/libs/gst/net'
  CC     libgstnet_0.10_la-gstnetclientclock.lo
  CC     libgstnet_0.10_la-gstnettimepacket.lo
  CC     libgstnet_0.10_la-gstnettimeprovider.lo
  CCLD   libgstnet-0.10.la
make[4]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/net'
Making all in helpers
make[4]: Entering directory `/home/app_fd/gstreamer-0.10.35/libs/gst/helpers'
  CC     gst_plugin_scanner-gst-plugin-scanner.o
  CCLD   gst-plugin-scanner
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgio-2.0.so: warning: the use of LEGACY `utimes' is discouraged, use `utime'
/home/Realtek/rtl819x-SDK-v3.2/rtl819x/toolchain/rsdk-1.5.5-5281-EB-2.6.30-0.9.30.3-110714/bin/../lib/gcc/mips-linux/4.4.5-1.5.5p4/../../../../mips-linux/bin/ld: warning: libz.so.1, needed by ../../../gst/.libs/libgstreamer-0.10.so, not found (try using -rpath or -rpath-link)
/home/Realtek/rtl819x-SDK-v3.2/rtl819x/toolchain/rsdk-1.5.5-5281-EB-2.6.30-0.9.30.3-110714/bin/../lib/gcc/mips-linux/4.4.5-1.5.5p4/../../../../mips-linux/bin/ld: warning: libiconv.so.2, needed by ../../../gst/.libs/libgstreamer-0.10.so, not found (try using -rpath or -rpath-link)
/home/Realtek/rtl819x-SDK-v3.2/rtl819x/toolchain/rsdk-1.5.5-5281-EB-2.6.30-0.9.30.3-110714/bin/../lib/gcc/mips-linux/4.4.5-1.5.5p4/../../../../mips-linux/bin/ld: warning: libffi.so.6, needed by ../../../gst/.libs/libgstreamer-0.10.so, not found (try using -rpath or -rpath-link)
/home/Realtek/rtl819x-SDK-v3.2/rtl819x/toolchain/rsdk-1.5.5-5281-EB-2.6.30-0.9.30.3-110714/bin/../lib/gcc/mips-linux/4.4.5-1.5.5p4/../../../../mips-linux/bin/ld: warning: libintl.so.8, needed by ../../../gst/.libs/libgstreamer-0.10.so, not found (try using -rpath or -rpath-link)
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so: undefined reference to `libintl_dcgettext'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgio-2.0.so: undefined reference to `inflateReset'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_pointer'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so: undefined reference to `libintl_gettext'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgio-2.0.so: undefined reference to `inflateEnd'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so: undefined reference to `libintl_bind_textdomain_codeset'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgio-2.0.so: undefined reference to `deflate'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgio-2.0.so: undefined reference to `deflateInit_'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_float'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so: undefined reference to `libiconv'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgio-2.0.so: undefined reference to `inflateInit2_'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgio-2.0.so: undefined reference to `deflateSetHeader@ZLIB_1.2.2'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgio-2.0.so: undefined reference to `inflate'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_void'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_sint64'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgio-2.0.so: undefined reference to `deflateEnd'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgio-2.0.so: undefined reference to `deflateReset'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so: undefined reference to `libintl_dgettext'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so: undefined reference to `libiconv_close'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so: undefined reference to `libintl_textdomain'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_prep_cif'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_uint32'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_double'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_call'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so: undefined reference to `libiconv_open'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so: undefined reference to `libintl_bindtextdomain'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgio-2.0.so: undefined reference to `inflateGetHeader@ZLIB_1.2.2'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgio-2.0.so: undefined reference to `inflateInit_'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgio-2.0.so: undefined reference to `deflateInit2_'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_sint32'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_uint64'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so: undefined reference to `libintl_dngettext'
collect2: ld returned 1 exit status
make[4]: *** [gst-plugin-scanner] Error 1
make[4]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/helpers'
make[3]: *** [all-recursive] Error 1
make[3]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst'
make[2]: *** [all-recursive] Error 1
make[2]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/gstreamer-0.10.35'
make: *** [all] Error 2

再configure...
$ ./configure --prefix=/home/app_fd/gstreamer-0.10.35/output_96d_SDKv3.2 --host=mips-linux --disable-gst-debug --disable-examples --disable-tests --disable-loadsave --enable-gobject-cast-checks=no --enable-glib-assert=no --without-gnu-ld --disable-debug CC=rsdk-linux-gcc GLIBS_CFLAGS="-I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/include/glib-2.0 -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/glib-2.0/include" GLIB_LIBS="-lgobject-2.0 -lgmodule-2.0 -L/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib" XML_CFLAGS=-I/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/include/libxml2/libxml XML_LIBS=-L/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/lib
$ make clean && make && make install
出現錯誤：
make[6]: Entering directory `/home/app_fd/gstreamer-0.10.35/libs/gst/check/libcheck'
  CC     libcheckinternal_la-check.lo
  CC     libcheckinternal_la-check_error.lo
  CC     libcheckinternal_la-check_list.lo
  CC     libcheckinternal_la-check_log.lo
  CC     libcheckinternal_la-check_msg.lo
  CC     libcheckinternal_la-check_pack.lo
  CC     libcheckinternal_la-check_print.lo
  CC     libcheckinternal_la-check_run.lo
  CC     libcheckinternal_la-check_str.lo
  CCLD   libcheckinternal.la
make[6]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/check/libcheck'
make[6]: Entering directory `/home/app_fd/gstreamer-0.10.35/libs/gst/check'
  CC     libgstcheck_0.10_la-gstbufferstraw.lo
  CC     libgstcheck_0.10_la-gstcheck.lo
  CC     libgstcheck_0.10_la-gstconsistencychecker.lo
  GEN    exports.sym
  CCLD   libgstcheck-0.10.la
make[6]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/check'
make[5]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/check'
make[4]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/check'
Making all in net
make[4]: Entering directory `/home/app_fd/gstreamer-0.10.35/libs/gst/net'
  CC     libgstnet_0.10_la-gstnetclientclock.lo
  CC     libgstnet_0.10_la-gstnettimepacket.lo
  CC     libgstnet_0.10_la-gstnettimeprovider.lo
  CCLD   libgstnet-0.10.la
make[4]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/net'
Making all in helpers
make[4]: Entering directory `/home/app_fd/gstreamer-0.10.35/libs/gst/helpers'
  CC     gst_plugin_scanner-gst-plugin-scanner.o
  CCLD   gst-plugin-scanner
/home/Realtek/rtl819x-SDK-v3.2/rtl819x/toolchain/rsdk-1.5.5-5281-EB-2.6.30-0.9.30.3-110714/bin/../lib/gcc/mips-linux/4.4.5-1.5.5p4/../../../../mips-linux/bin/ld: warning: libiconv.so.2, needed by ../../../gst/.libs/libgstreamer-0.10.so, not found (try using -rpath or -rpath-link)
/home/Realtek/rtl819x-SDK-v3.2/rtl819x/toolchain/rsdk-1.5.5-5281-EB-2.6.30-0.9.30.3-110714/bin/../lib/gcc/mips-linux/4.4.5-1.5.5p4/../../../../mips-linux/bin/ld: warning: libffi.so.6, needed by ../../../gst/.libs/libgstreamer-0.10.so, not found (try using -rpath or -rpath-link)
/home/Realtek/rtl819x-SDK-v3.2/rtl819x/toolchain/rsdk-1.5.5-5281-EB-2.6.30-0.9.30.3-110714/bin/../lib/gcc/mips-linux/4.4.5-1.5.5p4/../../../../mips-linux/bin/ld: warning: libintl.so.8, needed by ../../../gst/.libs/libgstreamer-0.10.so, not found (try using -rpath or -rpath-link)
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_dcgettext'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_pointer'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_gettext'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_bind_textdomain_codeset'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_float'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libiconv'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_void'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_sint64'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_dgettext'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libiconv_close'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_textdomain'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_prep_cif'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_uint32'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_double'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `__sync_fetch_and_sub_4'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_call'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `__sync_fetch_and_add_4'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libiconv_open'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_bindtextdomain'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_sint32'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `__sync_bool_compare_and_swap_4'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_uint64'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_dngettext'
collect2: ld returned 1 exit status
make[4]: *** [gst-plugin-scanner] Error 1
make[4]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/helpers'
make[3]: *** [all-recursive] Error 1
make[3]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst'
make[2]: *** [all-recursive] Error 1
make[2]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/gstreamer-0.10.35'
make: *** [all] Error 2


$ ./configure --prefix=/home/app_fd/gstreamer-0.10.35/output_96d_SDKv3.2 --host=mips-linux --disable-gst-debug --disable-examples --disable-tests --disable-loadsave --enable-gobject-cast-checks=no --enable-glib-assert=no --without-gnu-ld --disable-debug CC=rsdk-linux-gcc CPPFLAGS=-I/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi-3.0.11/include LDFLAGS=-L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib GLIBS_CFLAGS="-I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/include/glib-2.0 -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/glib-2.0/include" GLIB_LIBS="-lgobject-2.0 -lgmodule-2.0 -L/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib" XML_CFLAGS=-I/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/include/libxml2/libxml XML_LIBS=-L/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/lib
$ make clean && make && make install

make[4]: Entering directory `/home/app_fd/gstreamer-0.10.35/libs/gst/net'
  CC     libgstnet_0.10_la-gstnetclientclock.lo
  CC     libgstnet_0.10_la-gstnettimepacket.lo
  CC     libgstnet_0.10_la-gstnettimeprovider.lo
  CCLD   libgstnet-0.10.la
make[4]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/net'
Making all in helpers
make[4]: Entering directory `/home/app_fd/gstreamer-0.10.35/libs/gst/helpers'
  CC     gst_plugin_scanner-gst-plugin-scanner.o
  CCLD   gst-plugin-scanner
/home/Realtek/rtl819x-SDK-v3.2/rtl819x/toolchain/rsdk-1.5.5-5281-EB-2.6.30-0.9.30.3-110714/bin/../lib/gcc/mips-linux/4.4.5-1.5.5p4/../../../../mips-linux/bin/ld: warning: libiconv.so.2, needed by ../../../gst/.libs/libgstreamer-0.10.so, not found (try using -rpath or -rpath-link)
/home/Realtek/rtl819x-SDK-v3.2/rtl819x/toolchain/rsdk-1.5.5-5281-EB-2.6.30-0.9.30.3-110714/bin/../lib/gcc/mips-linux/4.4.5-1.5.5p4/../../../../mips-linux/bin/ld: warning: libffi.so.6, needed by ../../../gst/.libs/libgstreamer-0.10.so, not found (try using -rpath or -rpath-link)
/home/Realtek/rtl819x-SDK-v3.2/rtl819x/toolchain/rsdk-1.5.5-5281-EB-2.6.30-0.9.30.3-110714/bin/../lib/gcc/mips-linux/4.4.5-1.5.5p4/../../../../mips-linux/bin/ld: warning: libintl.so.8, needed by ../../../gst/.libs/libgstreamer-0.10.so, not found (try using -rpath or -rpath-link)
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_dcgettext'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_pointer'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_gettext'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_bind_textdomain_codeset'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_float'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libiconv'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_void'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_sint64'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_dgettext'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libiconv_close'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_textdomain'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_prep_cif'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_uint32'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_double'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `__sync_fetch_and_sub_4'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_call'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `__sync_fetch_and_add_4'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libiconv_open'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_bindtextdomain'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_sint32'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `__sync_bool_compare_and_swap_4'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libgobject-2.0.so: undefined reference to `ffi_type_uint64'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_dngettext'
collect2: ld returned 1 exit status
make[4]: *** [gst-plugin-scanner] Error 1
make[4]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/helpers'
make[3]: *** [all-recursive] Error 1
make[3]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst'
make[2]: *** [all-recursive] Error 1
make[2]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/gstreamer-0.10.35'
make: *** [all] Error 2

重新configure
$ ./configure --prefix=/home/app_fd/gstreamer-0.10.35/output_96d_SDKv3.2 --host=mips-linux --disable-gst-debug --disable-examples --disable-tests --disable-loadsave --enable-gobject-cast-checks=no --enable-glib-assert=no --without-gnu-ld --disable-debug CC=rsdk-linux-gcc CPPFLAGS=-I/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi-3.0.11/include LDFLAGS="-lffi -L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib" GLIBS_CFLAGS="-I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/include/glib-2.0 -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/glib-2.0/include" GLIB_LIBS="-lgobject-2.0 -lgmodule-2.0 -L/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib" XML_CFLAGS=-I/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/include/libxml2/libxml XML_LIBS=-L/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/lib
$ make clean && make && make install
出現錯誤：
make[4]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/net'
Making all in helpers
make[4]: Entering directory `/home/app_fd/gstreamer-0.10.35/libs/gst/helpers'
  CC     gst_plugin_scanner-gst-plugin-scanner.o
  CCLD   gst-plugin-scanner
/home/Realtek/rtl819x-SDK-v3.2/rtl819x/toolchain/rsdk-1.5.5-5281-EB-2.6.30-0.9.30.3-110714/bin/../lib/gcc/mips-linux/4.4.5-1.5.5p4/../../../../mips-linux/bin/ld: warning: libiconv.so.2, needed by ../../../gst/.libs/libgstreamer-0.10.so, not found (try using -rpath or -rpath-link)
/home/Realtek/rtl819x-SDK-v3.2/rtl819x/toolchain/rsdk-1.5.5-5281-EB-2.6.30-0.9.30.3-110714/bin/../lib/gcc/mips-linux/4.4.5-1.5.5p4/../../../../mips-linux/bin/ld: warning: libintl.so.8, needed by ../../../gst/.libs/libgstreamer-0.10.so, not found (try using -rpath or -rpath-link)
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_dcgettext'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_gettext'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_bind_textdomain_codeset'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libiconv'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_dgettext'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libiconv_close'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_textdomain'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `__sync_fetch_and_sub_4'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `__sync_fetch_and_add_4'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libiconv_open'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_bindtextdomain'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `__sync_bool_compare_and_swap_4'
/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/libglib-2.0.so.0: undefined reference to `libintl_dngettext'
collect2: ld returned 1 exit status
make[4]: *** [gst-plugin-scanner] Error 1
make[4]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/helpers'
make[3]: *** [all-recursive] Error 1
make[3]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst'
make[2]: *** [all-recursive] Error 1
make[2]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/gstreamer-0.10.35'
make: *** [all] Error 2

重新configure
./configure --prefix=/home/app_fd/gstreamer-0.10.35/output_96d_SDKv3.2 --host=mips-linux --disable-gst-debug --disable-examples --disable-tests --disable-loadsave --enable-gobject-cast-checks=no --enable-glib-assert=no --without-gnu-ld --disable-debug CC=rsdk-linux-gcc CPPFLAGS="-I/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi-3.0.11/include -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include -I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include" LDFLAGS="-lffi -liconv -L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib -L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib" GLIBS_CFLAGS="-I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/include/glib-2.0 -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/glib-2.0/include" GLIB_LIBS="-lgobject-2.0 -lgmodule-2.0 -L/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib" XML_CFLAGS=-I/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/include/libxml2/libxml XML_LIBS=-L/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/lib
$ make && make install
出現錯誤：
make[4]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/net'
Making all in helpers
make[4]: Entering directory `/home/app_fd/gstreamer-0.10.35/libs/gst/helpers'
  CC     gst_plugin_scanner-gst-plugin-scanner.o
  CCLD   gst-plugin-scanner
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `__sync_fetch_and_sub_4'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `__sync_fetch_and_add_4'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `__sync_bool_compare_and_swap_4'
collect2: ld returned 1 exit status
make[4]: *** [gst-plugin-scanner] Error 1
make[4]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/helpers'
make[3]: *** [all-recursive] Error 1
make[3]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst'
make[2]: *** [all-recursive] Error 1
make[2]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/gstreamer-0.10.35'
make: *** [all] Error 2

參考：http://beyondmagic.blog.51cto.com/3492045/765319
出現這個錯誤是因為編譯的時候產生的代碼是給老式的cpu機器使用的，而現在libgcc不支援它，所以更改編譯資訊
[tanxi@localhost 1.1.29]$ vim common.mk
GCC_FLAGS=-pthread改為GCC_FLAGS=-pthread -march=i686
然後把剛才的編譯產生的.o文件刪除
$ vim Makefile
找到
#GLIB_CFLAGS = -pthread -I/usr/local/include/glib-2.0 -I/usr/local/lib/glib-2.0/include
GLIB_CFLAGS = -pthread -march=mips -I/usr/local/include/glib-2.0 -I/usr/local/lib/glib-2.0/include
重新make
$ make clean && make && make install
仍然是同樣的錯誤：
make[4]: Entering directory `/home/app_fd/gstreamer-0.10.35/libs/gst/helpers'
  CC     gst_plugin_scanner-gst-plugin-scanner.o
  CCLD   gst-plugin-scanner
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `__sync_fetch_and_sub_4'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `__sync_fetch_and_add_4'
../../../gst/.libs/libgstreamer-0.10.so: undefined reference to `__sync_bool_compare_and_swap_4'
collect2: ld returned 1 exit status
make[4]: *** [gst-plugin-scanner] Error 1
make[4]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst/helpers'
make[3]: *** [all-recursive] Error 1
make[3]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs/gst'
make[2]: *** [all-recursive] Error 1
make[2]: Leaving directory `/home/app_fd/gstreamer-0.10.35/libs'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/gstreamer-0.10.35'
make: *** [all] Error 2

重新configure
增加 -march=5281
./configure --prefix=/home/app_fd/gstreamer-0.10.35/output_96d_SDKv3.2 --host=mips-linux CC=rsdk-linux-gcc --disable-gst-debug --disable-examples --disable-tests --disable-loadsave --enable-glib-assert=yes --disable-debug CPPFLAGS="-I/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi-3.0.11/include -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include -I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include" LDFLAGS="-lgcc -lffi -liconv -L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib -L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib" GLIBS_CFLAGS="-I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/include/glib-2.0 -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/glib-2.0/include" GLIB_LIBS="-lgobject-2.0 -lgmodule-2.0 -march=5281 -L/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib" XML_CFLAGS=-I/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/include/libxml2/libxml XML_LIBS=-L/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/lib
$ make && make install
出現錯誤：
同上。

下載 0.11.0 版 重新compile試試：
$ ./configure --prefix=/home/app_fd/gstreamer-0.11.91/output_96d_SDKv3.2 --host=mips-linux CC=rsdk-linux-gcc --disable-gst-debug --disable-examples --disable-tests --disable-loadsave --enable-glib-assert=yes --disable-debug CPPFLAGS="-I/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi-3.0.11/include -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include -I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include" LDFLAGS="-lgcc -lffi -liconv -L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib -L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib" GLIBS_CFLAGS="-I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/include/glib-2.0 -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/glib-2.0/include" GLIB_LIBS="-lgobject-2.0 -lgmodule-2.0 -march=5281 -L/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib" XML_CFLAGS=-I/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/include/libxml2/libxml XML_LIBS=-L/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/lib
$ make && make install
出現錯誤：
同上。

下載 0.10.30 版 重新compile試試：
$ ./configure --prefix=/home/app_fd/gstreamer-0.10.30/output_96d_SDKv3.2 --host=mips-linux CC=rsdk-linux-gcc CPPFLAGS="-march=5281 -I/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi-3.0.11/include -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include -I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/include/libxml2" LDFLAGS="-lgcc -lffi -liconv -lxml2 -L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib -L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/lib" GLIBS_CFLAGS="-I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/include/glib-2.0 -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/glib-2.0/include" GLIB_LIBS="-lgobject-2.0 -lgmodule-2.0 -L/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib"
$ make && make install
出現錯誤：
  CC     libgstreamer_0.10_la-gstelementfactory.lo
gstelementfactory.c: In function 'gst_element_factory_create':
gstelementfactory.c:385: error: size of array '_GStaticAssertCompileTimeAssertion_1' is negative
gstelementfactory.c:385: error: invalid use of void expression
gstelementfactory.c:385: error: incompatible type for argument 1 of '__sync_bool_compare_and_swap'
make[4]: *** [libgstreamer_0.10_la-gstelementfactory.lo] Error 1
make[4]: Leaving directory `/home/app_fd/gstreamer-0.10.30/gst'
make[3]: *** [all-recursive] Error 1
make[3]: Leaving directory `/home/app_fd/gstreamer-0.10.30/gst'
make[2]: *** [all] Error 2
make[2]: Leaving directory `/home/app_fd/gstreamer-0.10.30/gst'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/gstreamer-0.10.30'
make: *** [all] Error 2

降版 下載 0.10.22 版 重新compile試試：
$ make && make install
出現錯誤：
./configure --prefix=/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2 --host=mips-linux CC=rsdk-linux-gcc --enable-maintainer-mode --enable-poisioning --disable-gtk-doc --disable-tests CPPFLAGS="-march=5281 -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/include/glib-2.0 -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/glib-2.0/include -I/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi-3.0.11/include -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include -I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/include/libxml2" LDFLAGS="-lgcc -lffi -liconv -lxml2 -L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib -L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/lib -L/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib"
libtool: link: rsdk-linux-gcc -I/usr/local/include/glib-2.0 -I/usr/local/lib/glib-2.0/include -g -O2 -o gst-xmllaunch gst-run.o  /home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi.so /home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib/libiconv.so /home/app_fd/libxml2-2.7.8/output_96d-SDKv3.2/lib/libxml2.so -lm -L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib -L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/lib -L/usr/local/lib /usr/local/lib/libglib-2.0.so -lrt -ldl -Wl,-rpath -Wl,/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib -Wl,-rpath -Wl,/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -Wl,-rpath -Wl,/home/app_fd/libxml2-2.7.8/output_96d-SDKv3.2/lib -Wl,-rpath -Wl,/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib -Wl,-rpath -Wl,/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -Wl,-rpath -Wl,/home/app_fd/libxml2-2.7.8/output_96d-SDKv3.2/lib
/usr/local/lib/libglib-2.0.so: could not read symbols: File in wrong format
collect2: ld returned 1 exit status
make[2]: *** [gst-xmllaunch] Error 1
make[2]: Leaving directory `/home/app_fd/gstreamer-0.10.22/tools'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/gstreamer-0.10.22'
make: *** [all] Error 2
root@js-desktop:/home/app_fd/gstreamer-0.10.22# ^C

重新compile試試：
./configure --prefix=/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2 --host=mips-linux CC=rsdk-linux-gcc --enable-maintainer-mode --enable-poisioning --disable-gtk-doc --disable-tests CPPFLAGS="-march=5281 -I/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi-3.0.11/include -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include -I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/include/libxml2" LDFLAGS="-lffi -liconv -lxml2 -L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib -L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/lib" GLIB_CFLAGS="-I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/include/glib-2.0 -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/glib-2.0/include" GLIB_LIBS="-pthread -L/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib -lgobject-2.0 -lgthread-2.0 -lgmodule-2.0 -lrt -lglib-2.0" GLIB_ONLY_CFLAGS="-I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/include/glib-2.0 -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/glib-2.0/include" GLIB_ONLY_LIBS="-pthread -L/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib -lgobject-2.0 -lgthread-2.0 -lgmodule-2.0 -lrt -lglib-2.0"
$ make && make install
成功：：…
結論就是降版到 0.10.22 版。


11. build gmediarender-0.0.6
$ ./configure --prefix=/home/app_fd/gmediarender-0.0.6/output_96d_SDKv3.2 CC=rsdk-linux-gcc --host=mips-linux --with-libupnp=/home/app_fd/libupnp-1.6.15/output_96d_SDKv3.2 GST_CFLAGS=/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include GST_LIBS=/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/lib
出現錯誤：
checking upnp.h usability... yes
checking upnp.h presence... yes
checking for upnp.h... yes
checking for UpnpInit in -lupnp... no
configure: error: the upnp library is required to build and run this program

重新configure：
./configure --prefix=/home/app_fd/gmediarender-0.0.6/output_96d_SDKv3.2 CC=rsdk-linux-gcc --host=rsdk-linux CPPFLAGS=-I/home/app_fd/libupnp-1.6.15/output_96d_SDKv3.2/include/upnp/ LDFLAGS="-lupnp -lthreadutil -lixml -L/home/app_fd/libupnp-1.6.15/output_96d_SDKv3.2/lib" GST_CFLAGS=/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include GST_LIBS=/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/lib
原因是找不到-lthreadutil -lixml
$ make clean && make && make install
出現許多錯誤：
main.c:32:18: error: glib.h: No such file or directory
main.c:34:26: error: upnp/ithread.h: No such file or directory
main.c:35:23: error: upnp/upnp.h: No such file or directory
In file included from main.c:38:
output_gstreamer.h:27: error: expected ')' before '*' token
In file included from main.c:39:
upnp.h:87: error: expected specifier-qualifier-list before 'ithread_mutex_t'
upnp.h:106: error: expected specifier-qualifier-list before 'ithread_mutex_t'
In file included from main.c:40:
upnp_device.h:40: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'device_handle'
main.c:43: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'show_version'
main.c:44: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'show_devicedesc'
main.c:45: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'show_connmgr_scpd'
main.c:46: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'show_control_scpd'
main.c:47: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'show_transport_scpd'
main.c:48: error: expected '=', ',', ';', 'asm' or '__attribute__' before '*' token
main.c:49: error: expected '=', ',', ';', 'asm' or '__attribute__' before '*' token
main.c:50: error: expected '=', ',', ';', 'asm' or '__attribute__' before '*' token
main.c:54: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'option_entries'
main.c: In function 'process_cmdline':
main.c:88: error: 'GOptionContext' undeclared (first use in this function)
main.c:88: error: (Each undeclared identifier is reported only once
main.c:88: error: for each function it appears in.)
main.c:88: error: 'ctx' undeclared (first use in this function)
main.c:89: error: 'GError' undeclared (first use in this function)
main.c:89: error: 'err' undeclared (first use in this function)
main.c:92: warning: implicit declaration of function 'g_option_context_new'
main.c:93: warning: implicit declaration of function 'g_option_context_add_main_entries'
main.c:93: error: 'option_entries' undeclared (first use in this function)
main.c:95: warning: implicit declaration of function 'output_gstreamer_add_options'
main.c:100: warning: implicit declaration of function 'g_option_context_parse'
main.c:101: warning: implicit declaration of function 'g_print'
main.c:102: warning: implicit declaration of function 'g_error_free'
main.c: In function 'main':
main.c:120: warning: implicit declaration of function 'g_thread_supported'
main.c:121: warning: implicit declaration of function 'g_thread_init'
main.c:129: error: 'show_version' undeclared (first use in this function)
main.c:133: error: 'show_connmgr_scpd' undeclared (first use in this function)
main.c:137: error: 'show_control_scpd' undeclared (first use in this function)
main.c:141: error: 'show_transport_scpd' undeclared (first use in this function)
main.c:146: error: 'friendly_name' undeclared (first use in this function)
main.c:146: error: 'uuid' undeclared (first use in this function)
main.c:151: error: 'show_devicedesc' undeclared (first use in this function)
main.c:161: error: 'ip_address' undeclared (first use in this function)
make[2]: *** [main.o] Error 1
make[2]: Leaving directory `/home/app_fd/gmediarender-0.0.6/src'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/gmediarender-0.0.6'
make: *** [all] Error 2

重新configure
$ ./configure --prefix=/home/app_fd/gmediarender-0.0.6/output_96d_SDKv3.2 CC=rsdk-linux-gcc --host=rsdk-linux CPPFLAGS="-I/home/app_fd/libupnp-1.6.15/output_96d_SDKv3.2/include -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/include/glib-2.0 -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/glib-2.0/include -I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi-3.0.11/include" LDFLAGS="-lupnp -lthreadutil -lixml -L/home/app_fd/libupnp-1.6.15/output_96d_SDKv3.2/lib -L/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib -L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib" GST_CFLAGS=/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include GST_LIBS=/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/lib
$ make clean && make && make install
出現下列錯誤：
webserver.c: At top level:
webserver.c:272: error: variable 'virtual_dir_callbacks' has initializer but incomplete type
webserver.c:273: warning: excess elements in struct initializer
webserver.c:273: warning: (near initialization for 'virtual_dir_callbacks')
webserver.c:274: warning: excess elements in struct initializer
webserver.c:274: warning: (near initialization for 'virtual_dir_callbacks')
webserver.c:275: warning: excess elements in struct initializer
webserver.c:275: warning: (near initialization for 'virtual_dir_callbacks')
webserver.c:276: warning: excess elements in struct initializer
webserver.c:276: warning: (near initialization for 'virtual_dir_callbacks')
webserver.c:277: warning: excess elements in struct initializer
webserver.c:277: warning: (near initialization for 'virtual_dir_callbacks')
webserver.c:279: warning: excess elements in struct initializer
webserver.c:279: warning: (near initialization for 'virtual_dir_callbacks')
make[2]: *** [webserver.o] Error 1
make[2]: Leaving directory `/home/app_fd/gmediarender-0.0.6/src'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/gmediarender-0.0.6'
make: *** [all] Error 2

降版libupnp到1.6.6
$ ./configure --prefix=/home/app_fd/gmediarender-0.0.6/output_96d_SDKv3.2 CC=rsdk-linux-gcc --host=mips-linux --with-libupnp=/home/app_fd/libupnp-1.6.6/output_96d_SDKv3.2 CPPFLAGS="-I/home/app_fd/libupnp-1.6.6/output_96d_SDKv3.2/include -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/include/glib-2.0 -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/glib-2.0/include -I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi-3.0.11/include" LDFLAGS="-lupnp -lthreadutil -lixml -L/home/app_fd/libupnp-1.6.6/output_96d_SDKv3.2/lib -L/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib -L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib" GST_CFLAGS=/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include GST_LIBS=/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/lib
$ make clean && make && make install
出現下列錯誤：
In file included from output_gstreamer.c:41:
output_gstreamer.h:27: error: expected ')' before '*' token
output_gstreamer.c:43: warning: type defaults to 'int' in declaration of 'GstCaps'
output_gstreamer.c:43: error: expected ';', ',' or ')' before '*' token
output_gstreamer.c:63: error: expected ')' before '*' token
output_gstreamer.c: In function 'scan_mime_list':
output_gstreamer.c:97: error: 'GList' undeclared (first use in this function)
output_gstreamer.c:97: error: (Each undeclared identifier is reported only once
output_gstreamer.c:97: error: for each function it appears in.)
output_gstreamer.c:97: error: 'plugins' undeclared (first use in this function)
output_gstreamer.c:98: error: 'GstRegistry' undeclared (first use in this function)
output_gstreamer.c:98: error: 'registry' undeclared (first use in this function)
output_gstreamer.c:98: warning: implicit declaration of function 'gst_registry_get_default'
output_gstreamer.c:102: warning: implicit declaration of function 'gst_default_registry_get_plugin_list'
output_gstreamer.c:105: error: 'features' undeclared (first use in this function)
output_gstreamer.c:106: error: 'GstPlugin' undeclared (first use in this function)
output_gstreamer.c:106: error: 'plugin' undeclared (first use in this function)
output_gstreamer.c:108: error: expected expression before ')' token
output_gstreamer.c:109: warning: implicit declaration of function 'g_list_next'
output_gstreamer.c:112: warning: implicit declaration of function 'gst_registry_get_feature_list_by_plugin'
output_gstreamer.c:114: warning: implicit declaration of function 'gst_plugin_get_name'
output_gstreamer.c:117: error: 'GstPluginFeature' undeclared (first use in this function)
output_gstreamer.c:117: error: 'feature' undeclared (first use in this function)
output_gstreamer.c:119: warning: implicit declaration of function 'GST_PLUGIN_FEATURE'
output_gstreamer.c:121: warning: implicit declaration of function 'GST_IS_ELEMENT_FACTORY'
output_gstreamer.c:122: error: 'GstElementFactory' undeclared (first use in this function)
output_gstreamer.c:122: error: 'factory' undeclared (first use in this function)
output_gstreamer.c:123: error: 'GstElement' undeclared (first use in this function)
output_gstreamer.c:123: error: 'element' undeclared (first use in this function)
output_gstreamer.c:124: warning: implicit declaration of function 'GST_ELEMENT_FACTORY'
output_gstreamer.c:126: warning: implicit declaration of function 'gst_element_factory_create'
output_gstreamer.c:129: warning: implicit declaration of function 'scan_pad_templates_info'
output_gstreamer.c: At top level:
output_gstreamer.c:142: error: expected '=', ',', ';', 'asm' or '__attribute__' before '*' token
output_gstreamer.c: In function 'output_play':
output_gstreamer.c:161: warning: implicit declaration of function 'gst_element_set_state'
output_gstreamer.c:161: error: 'play' undeclared (first use in this function)
output_gstreamer.c:161: error: 'GST_STATE_READY' undeclared (first use in this function)
output_gstreamer.c:162: error: 'GST_STATE_CHANGE_FAILURE' undeclared (first use in this function)
output_gstreamer.c:166: warning: implicit declaration of function 'g_object_set'
output_gstreamer.c:166: warning: implicit declaration of function 'G_OBJECT'
output_gstreamer.c:167: error: 'GST_STATE_PLAYING' undeclared (first use in this function)
output_gstreamer.c: In function 'output_stop':
output_gstreamer.c:180: error: 'play' undeclared (first use in this function)
output_gstreamer.c:180: error: 'GST_STATE_READY' undeclared (first use in this function)
output_gstreamer.c:181: error: 'GST_STATE_CHANGE_FAILURE' undeclared (first use in this function)
output_gstreamer.c: In function 'output_pause':
output_gstreamer.c:191: error: 'play' undeclared (first use in this function)
output_gstreamer.c:191: error: 'GST_STATE_PAUSED' undeclared (first use in this function)
output_gstreamer.c:192: error: 'GST_STATE_CHANGE_FAILURE' undeclared (first use in this function)
output_gstreamer.c: In function 'output_loop':
output_gstreamer.c:203: error: 'GMainLoop' undeclared (first use in this function)
output_gstreamer.c:203: error: 'loop' undeclared (first use in this function)
output_gstreamer.c:206: warning: implicit declaration of function 'g_main_loop_new'
output_gstreamer.c:206: error: 'FALSE' undeclared (first use in this function)
output_gstreamer.c:208: warning: implicit declaration of function 'g_main_loop_run'
output_gstreamer.c: At top level:
output_gstreamer.c:212: error: expected ')' before 'state'
output_gstreamer.c:230: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'my_bus_callback'
output_gstreamer.c:277: error: expected '=', ',', ';', 'asm' or '__attribute__' before '*' token
output_gstreamer.c:278: error: expected '=', ',', ';', 'asm' or '__attribute__' before '*' token
output_gstreamer.c:281: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'option_entries'
output_gstreamer.c:294: error: expected ')' before '*' token
output_gstreamer.c: In function 'output_gstreamer_init':
output_gstreamer.c:312: error: 'GstBus' undeclared (first use in this function)
output_gstreamer.c:312: error: 'bus' undeclared (first use in this function)
output_gstreamer.c:318: error: 'play' undeclared (first use in this function)
output_gstreamer.c:318: warning: implicit declaration of function 'gst_element_factory_make'
output_gstreamer.c:320: warning: implicit declaration of function 'gst_pipeline_get_bus'
output_gstreamer.c:320: warning: implicit declaration of function 'GST_PIPELINE'
output_gstreamer.c:321: warning: implicit declaration of function 'gst_bus_add_watch'
output_gstreamer.c:321: error: 'my_bus_callback' undeclared (first use in this function)
output_gstreamer.c:322: warning: implicit declaration of function 'gst_object_unref'
output_gstreamer.c:324: error: 'audiosink' undeclared (first use in this function)
output_gstreamer.c:325: error: 'GstElement' undeclared (first use in this function)
output_gstreamer.c:325: error: 'sink' undeclared (first use in this function)
output_gstreamer.c:330: error: 'videosink' undeclared (first use in this function)
output_gstreamer.c:337: error: 'GST_STATE_READY' undeclared (first use in this function)
output_gstreamer.c:338: error: 'GST_STATE_CHANGE_FAILURE' undeclared (first use in this function)
make[2]: *** [output_gstreamer.o] Error 1
make[2]: Leaving directory `/home/app_fd/gmediarender-0.0.6/src'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/gmediarender-0.0.6'
make: *** [all] Error 2

重新configure
./configure --prefix=/home/app_fd/gmediarender-0.0.6/output_96d_SDKv3.2 CC=rsdk-linux-gcc --host=mips-linux --with-libupnp=/home/app_fd/libupnp-1.6.6/output_96d_SDKv3.2 CPPFLAGS="-I/home/app_fd/libupnp-1.6.6/output_96d_SDKv3.2/include -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/include/glib-2.0 -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/glib-2.0/include -I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi-3.0.11/include -I/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/include -I/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10" LDFLAGS="-lupnp -lthreadutil -lixml -lxml2 -L/home/app_fd/libupnp-1.6.6/output_96d_SDKv3.2/lib -L/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib -L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib -L/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/lib -L/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/lib" GST_CFLAGS=/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10 GST_LIBS="-lgstreamer-0.10 -lgstbase-0.10 -lgstnet-0.10 -lgstdataprotocol-0.10 -lgstcontroller-0.10 /home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/lib"
$ make clean && make && make install
出現下列錯誤：
from output_gstreamer.c:35:
/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10/gst/gstmessage.h: In function 'gst_message_ref':
/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10/gst/gstmessage.h:261: warning: cast increases required alignment of target type
In file included from /home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10/gst/gst.h:73,
                 from output_gstreamer.c:35:
/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10/gst/gstxml.h: At top level:
/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10/gst/gstxml.h:57: error: expected specifier-qualifier-list before 'xmlNsPtr'
/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10/gst/gstxml.h:67: error: expected declaration specifiers or '...' before 'xmlNodePtr'
/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10/gst/gstxml.h:68: error: expected declaration specifiers or '...' before 'xmlNodePtr'
/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10/gst/gstxml.h:77: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'gst_xml_write'
/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10/gst/gstxml.h:84: error: expected declaration specifiers or '...' before 'xmlDocPtr'
/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10/gst/gstxml.h:92: error: expected ')' before 'cur'
output_gstreamer.c: In function 'my_bus_callback':
output_gstreamer.c:238: warning: cast increases required alignment of target type
output_gstreamer.c:239: warning: cast increases required alignment of target type
output_gstreamer.c: In function 'output_gstreamer_init':
output_gstreamer.c:320: warning: cast increases required alignment of target type
make[2]: *** [output_gstreamer.o] Error 1
make[2]: Leaving directory `/home/app_fd/gmediarender-0.0.6/src'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/gmediarender-0.0.6'
make: *** [all] Error 2

判斷為找不到libxml2
重新configure
# ./configure --prefix=/home/app_fd/gmediarender-0.0.6/output_96d_SDKv3.2 CC=rsdk-linux-gcc --host=mips-linux --with-libupnp=/home/app_fd/libupnp-1.6.6/output_96d_SDKv3.2 CPPFLAGS="-I/home/app_fd/libupnp-1.6.6/output_96d_SDKv3.2/include -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/include/glib-2.0 -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/glib-2.0/include -I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi-3.0.11/include -I/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/include/libxml2 -I/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10" LDFLAGS="-lupnp -lthreadutil -lixml -lxml2 -L/home/app_fd/libupnp-1.6.6/output_96d_SDKv3.2/lib -L/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib -L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib -L/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/lib -L/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/lib" GST_CFLAGS=/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10 GST_LIBS="-lgstreamer-0.10 -lgstbase-0.10 -lgstnet-0.10 -lgstdataprotocol-0.10 -lgstcontroller-0.10 /home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/lib"
$ make clean && make && make install
/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10/gst/gstevent.h: In function 'gst_event_ref':
/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10/gst/gstevent.h:355: warning: cast increases required alignment of target type
In file included from /home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10/gst/gstbus.h:29,
                 from /home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10/gst/gstelement.h:54,
                 from /home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10/gst/gstbin.h:27,
                 from /home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10/gst/gst.h:34,
                 from output_gstreamer.c:35:
/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10/gst/gstmessage.h: In function 'gst_message_ref':
/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10/gst/gstmessage.h:261: warning: cast increases required alignment of target type
output_gstreamer.c: In function 'my_bus_callback':
output_gstreamer.c:238: warning: cast increases required alignment of target type
output_gstreamer.c:239: warning: cast increases required alignment of target type
output_gstreamer.c: In function 'output_gstreamer_init':
output_gstreamer.c:320: warning: cast increases required alignment of target type
mips-linux-xgcc: /home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10: linker input file unused because linking not done
if rsdk-linux-gcc -DHAVE_CONFIG_H -I. -I. -I..  /home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10 -I/home/app_fd/libupnp-1.6.6/output_96d_SDKv3.2/include/upnp -DPKG_DATADIR=\"/home/app_fd/gmediarender-0.0.6/output_96d_SDKv3.2/share/gmediarender\" -I/home/app_fd/libupnp-1.6.6/output_96d_SDKv3.2/include -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/include/glib-2.0 -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/glib-2.0/include -I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi-3.0.11/include -I/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/include/libxml2 -I/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10  -Wall -Wpointer-arith -Wcast-align -Wmissing-prototypes -Wmissing-declarations -MT xmlescape.o -MD -MP -MF ".deps/xmlescape.Tpo" -c -o xmlescape.o xmlescape.c; \
        then mv -f ".deps/xmlescape.Tpo" ".deps/xmlescape.Po"; else rm -f ".deps/xmlescape.Tpo"; exit 1; fi
mips-linux-xgcc: /home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10: linker input file unused because linking not done
rsdk-linux-gcc  -Wall -Wpointer-arith -Wcast-align -Wmissing-prototypes -Wmissing-declarations -L/home/app_fd/libupnp-1.6.6/output_96d_SDKv3.2/lib -lupnp -lthreadutil -lixml -lxml2 -L/home/app_fd/libupnp-1.6.6/output_96d_SDKv3.2/lib -L/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib -L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib -L/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/lib -L/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/lib -o gmediarender  main.o upnp.o upnp_control.o upnp_connmgr.o upnp_transport.o upnp_device.o upnp_renderer.o webserver.o output_gstreamer.o xmlescape.o -lgstreamer-0.10 -lgstbase-0.10 -lgstnet-0.10 -lgstdataprotocol-0.10 -lgstcontroller-0.10 /home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/lib -lupnp
/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/lib: file not recognized: Is a directory
collect2: ld returned 1 exit status
make[2]: *** [gmediarender] Error 1
make[2]: Leaving directory `/home/app_fd/gmediarender-0.0.6/src'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/gmediarender-0.0.6'
make: *** [all] Error 2

重新configure
# ./configure --prefix=/home/app_fd/gmediarender-0.0.6/output_96d_SDKv3.2 CC=rsdk-linux-gcc --host=mips-linux --with-libupnp=/home/app_fd/libupnp-1.6.6/output_96d_SDKv3.2 CPPFLAGS="-I/home/app_fd/libupnp-1.6.6/output_96d_SDKv3.2/include -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/include/glib-2.0 -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/glib-2.0/include -I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi-3.0.11/include -I/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/include/libxml2 -I/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10" LDFLAGS="-lupnp -lthreadutil -lixml -lxml2 -L/home/app_fd/libupnp-1.6.6/output_96d_SDKv3.2/lib -L/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib -L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib -L/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/lib -L/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/lib" GST_CFLAGS=-I/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10 GST_LIBS=-L/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/lib
$ make clean && make && make install
出現下列錯誤：
main.o: In function `process_cmdline':
main.c:(.text+0x88): undefined reference to `g_option_context_new'
main.c:(.text+0xb0): undefined reference to `g_option_context_add_main_entries'
main.c:(.text+0x104): undefined reference to `g_option_context_parse'
main.c:(.text+0x134): undefined reference to `g_print'
main.c:(.text+0x150): undefined reference to `g_error_free'
main.o: In function `main':
main.c:(.text+0x1c4): undefined reference to `g_threads_got_initialized'
main.c:(.text+0x1d8): undefined reference to `g_thread_init'
output_gstreamer.o: In function `scan_caps':
output_gstreamer.c:(.text+0x40): undefined reference to `g_return_if_fail_warning'
output_gstreamer.c:(.text+0x60): undefined reference to `gst_caps_is_any'
output_gstreamer.c:(.text+0x80): undefined reference to `gst_caps_is_empty'
output_gstreamer.c:(.text+0xb0): undefined reference to `gst_caps_get_structure'
output_gstreamer.c:(.text+0xcc): undefined reference to `gst_structure_get_name'
output_gstreamer.c:(.text+0x108): undefined reference to `gst_caps_get_size'
output_gstreamer.o: In function `scan_mime_list':
output_gstreamer.c:(.text+0x2a4): undefined reference to `gst_registry_get_default'
output_gstreamer.c:(.text+0x2bc): undefined reference to `gst_registry_get_default'
output_gstreamer.c:(.text+0x2d4): undefined reference to `gst_registry_get_plugin_list'
output_gstreamer.c:(.text+0x328): undefined reference to `gst_plugin_get_name'
output_gstreamer.c:(.text+0x344): undefined reference to `gst_registry_get_feature_list_by_plugin'
output_gstreamer.c:(.text+0x370): undefined reference to `gst_plugin_feature_get_type'
output_gstreamer.c:(.text+0x38c): undefined reference to `g_type_check_instance_cast'
output_gstreamer.c:(.text+0x3ac): undefined reference to `gst_element_factory_get_type'
output_gstreamer.c:(.text+0x41c): undefined reference to `g_type_check_instance_is_a'
output_gstreamer.c:(.text+0x444): undefined reference to `gst_element_factory_get_type'
output_gstreamer.c:(.text+0x460): undefined reference to `g_type_check_instance_cast'
output_gstreamer.c:(.text+0x480): undefined reference to `gst_element_factory_create'
output_gstreamer.o: In function `output_play':
output_gstreamer.c:(.text+0x5fc): undefined reference to `gst_element_set_state'
output_gstreamer.c:(.text+0x64c): undefined reference to `g_type_check_instance_cast'
output_gstreamer.c:(.text+0x680): undefined reference to `g_object_set'
output_gstreamer.c:(.text+0x6a4): undefined reference to `gst_element_set_state'
output_gstreamer.o: In function `output_stop':
output_gstreamer.c:(.text+0x730): undefined reference to `gst_element_set_state'
output_gstreamer.o: In function `output_pause':
output_gstreamer.c:(.text+0x7a0): undefined reference to `gst_element_set_state'
output_gstreamer.o: In function `output_loop':
output_gstreamer.c:(.text+0x808): undefined reference to `g_main_loop_new'
output_gstreamer.c:(.text+0x824): undefined reference to `g_main_loop_run'
output_gstreamer.o: In function `my_bus_callback':
output_gstreamer.c:(.text+0x934): undefined reference to `gst_message_get_type'
output_gstreamer.c:(.text+0x950): undefined reference to `g_type_check_instance_cast'
output_gstreamer.c:(.text+0x970): undefined reference to `gst_message_get_type'
output_gstreamer.c:(.text+0x98c): undefined reference to `g_type_check_instance_cast'
output_gstreamer.c:(.text+0x9e8): undefined reference to `g_print'
output_gstreamer.c:(.text+0xa18): undefined reference to `gst_message_parse_error'
output_gstreamer.c:(.text+0xa34): undefined reference to `g_free'
output_gstreamer.c:(.text+0xa60): undefined reference to `g_print'
output_gstreamer.c:(.text+0xa7c): undefined reference to `g_error_free'
output_gstreamer.c:(.text+0xab0): undefined reference to `gst_message_parse_state_changed'
output_gstreamer.c:(.text+0xb20): undefined reference to `g_print'
output_gstreamer.c:(.text+0xb40): undefined reference to `gst_message_type_get_name'
output_gstreamer.c:(.text+0xb68): undefined reference to `g_print'
output_gstreamer.o: In function `output_gstreamer_add_options':
output_gstreamer.c:(.text+0xbe0): undefined reference to `g_option_group_new'
output_gstreamer.c:(.text+0xc04): undefined reference to `g_option_group_add_entries'
output_gstreamer.c:(.text+0xc20): undefined reference to `g_option_context_add_group'
output_gstreamer.c:(.text+0xc34): undefined reference to `gst_init_get_option_group'
output_gstreamer.c:(.text+0xc50): undefined reference to `g_option_context_add_group'
output_gstreamer.o: In function `output_gstreamer_init':
output_gstreamer.c:(.text+0xcbc): undefined reference to `gst_element_factory_make'
output_gstreamer.c:(.text+0xce8): undefined reference to `gst_pipeline_get_type'
output_gstreamer.c:(.text+0xd04): undefined reference to `g_type_check_instance_cast'
output_gstreamer.c:(.text+0xd1c): undefined reference to `gst_pipeline_get_bus'
output_gstreamer.c:(.text+0xd44): undefined reference to `gst_bus_add_watch'
output_gstreamer.c:(.text+0xd5c): undefined reference to `gst_object_unref'
output_gstreamer.c:(.text+0xdc4): undefined reference to `gst_element_factory_make'
output_gstreamer.c:(.text+0xdec): undefined reference to `g_type_check_instance_cast'
output_gstreamer.c:(.text+0xe14): undefined reference to `g_object_set'
output_gstreamer.c:(.text+0xe7c): undefined reference to `gst_element_factory_make'
output_gstreamer.c:(.text+0xea4): undefined reference to `g_type_check_instance_cast'
output_gstreamer.c:(.text+0xecc): undefined reference to `g_object_set'
output_gstreamer.c:(.text+0xef0): undefined reference to `gst_element_set_state'
collect2: ld returned 1 exit status
make[2]: *** [gmediarender] Error 1
make[2]: Leaving directory `/home/app_fd/gmediarender-0.0.6/src'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/app_fd/gmediarender-0.0.6'
make: *** [all] Error 2


重新configure
./configure --prefix=/home/app_fd/gmediarender-0.0.6/output_96d_SDKv3.2 CC=rsdk-linux-gcc STRIP=rsdk-linux-strip LD=rsdk-linux-ld --host=mips-linux --with-libupnp=/home/app_fd/libupnp-1.6.6/output_96d_SDKv3.2 CPPFLAGS="-I/home/app_fd/libupnp-1.6.6/output_96d_SDKv3.2/include -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/include/glib-2.0 -I/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib/glib-2.0/include -I/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/include -I/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib/libffi-3.0.11/include -I/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/include/libxml2 -I/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/include -I/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/include/gstreamer-0.10" LDFLAGS="-lupnp -lthreadutil -lixml -lxml2 -lffi -liconv -lintl -L/home/app_fd/libupnp-1.6.6/output_96d_SDKv3.2/lib -L/home/app_fd/glib-2.30.3/output_96d_SDKv3.2/lib -L/home/app_fd/libiconv-1.14/output_96d_SDKv3.2/lib -L/home/app_fd/libffi-3.0.11/output_96d_SDKv3.2/lib -L/home/app_fd/libxml2-2.7.8/output_96d_SDKv3.2/lib -L/home/app_fd/gettext-0.18.1.1/output_96d_SDKv3.2/lib -L/home/app_fd/gstreamer-0.10.22/output_96d_SDKv3.2/lib"
$ make clean && make && make install
成功：




/******************************************************************************/
// No package 'glib-2.0' found 問題的解決方案 (2011-06-26 16:33)
/******************************************************************************/
分類： Linux內核學習
在安裝一個源碼包時，出現下面一個庫文件沒有找到，其解決方法如下：
checking for GLIB - version >= 2.0.0... no
*** Could not run GLIB test program, checking why...
*** The test program failed to compile or link. See the file config.log for the
*** exact error that occured. This usually means GLIB is incorrectly installed.
checking for GLIB2... configure: error: Package requirements (
    glib-2.0 >= 2.18
) were not met:
No package 'glib-2.0' found
在Ubuntu作業系統中可以使用下面的命令進行安裝：
解決方法   sudo apt-get install libglib2.0-dev

ref: http://blog.csdn.net/absurd/article/details/646993



/******************************************************************************/
// miniupnpc-1.6
/******************************************************************************/
Source code : miniupnpc-1.6.tar.gz
Build step:
1. Compiler
~# make
2. Install
~# make install
這樣就完成了安裝miniupnp client.

接著我們可以用它來查詢目前UPnP Server開了哪些Port：
~# upnpc -l
upnpc : miniupnpc library test client. (c) 2006-2011 Thomas Bernard
Go to http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
for more information.
List of UPNP devices found on the network :
 desc: http://192.168.100.245:80/desc.xml
 st: urn:schemas-upnp-org:device:InternetGatewayDevice:1

Found valid IGD : http://192.168.100.245:80/upnp/control3
Local LAN ip address : 192.168.100.133
Connection Type : IP_Routed
Status : Connected, uptime=4760834s, LastConnectionError : ERROR_NONE
  Time started : Tue Oct  4 13:14:27 2011
MaxBitRateDown : 10 bps   MaxBitRateUp 5000000 bps (5.0 Mbps)
ExternalIPAddress = 0.0.0.0
 0 TCP 12884->192.168.100.80:12884 'MSNLite' '' 0
 1 TCP 38042->192.168.100.30:38042 'Skype TCP at 192.168.100.30:38042 (1789)' '' 0
 2 TCP 37825->192.168.100.171:37825 'Skype TCP at 192.168.100.171:37825 (1792)' '' 0
 3 TCP 29977->192.168.100.127:29977 'Skype TCP at 192.168.100.127:29977 (1792)' '' 0
 4 TCP 17713->192.168.100.107:17713 'Skype TCP at 192.168.100.107:17713 (1737)' '' 0
 5 TCP  2246->192.168.100.186:2246  'Skype TCP at 192.168.100.186:2246 (1739)' '' 0
 6 TCP 44299->192.168.100.199:44299 'Skype TCP at 192.168.100.199:44299 (1792)' '' 0
 7 TCP 16879->192.168.100.170:16879 'MSNLite' '' 0
 8 UDP 43148->192.168.100.37:43148 'FG2_U_43148' '' 0
......

再來我們試著來開port看看，我們開TCP 11131和UDP 11142：
~# upnpc -r 11131 tcp 11142 udp
upnpc : miniupnpc library test client. (c) 2006-2011 Thomas Bernard
Go to http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
for more information.
List of UPNP devices found on the network :
 desc: http://192.168.100.245:80/desc.xml
 st: urn:schemas-upnp-org:device:InternetGatewayDevice:1

Found valid IGD : http://192.168.100.245:80/upnp/control3
Local LAN ip address : 192.168.100.133
ExternalIPAddress = 0.0.0.0
InternalIP:Port = 192.168.100.133:11131
external 0.0.0.0:11131 TCP is redirected to internal 192.168.100.133:11131 (duration=0)
ExternalIPAddress = 0.0.0.0
InternalIP:Port = 192.168.100.133:11142
external 0.0.0.0:11142 UDP is redirected to internal 192.168.100.133:11142 (duration=0)

再來我們試著把port刪掉看看：
~# upnpc -d 11131 tcp 11142 udp
upnpc : miniupnpc library test client. (c) 2006-2011 Thomas Bernard
Go to http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
for more information.
List of UPNP devices found on the network :
 desc: http://192.168.100.245:80/desc.xml
 st: urn:schemas-upnp-org:device:InternetGatewayDevice:1

Found valid IGD : http://192.168.100.245:80/upnp/control3
Local LAN ip address : 192.168.100.133
UPNP_DeletePortMapping() returned : 0
UPNP_DeletePortMapping() returned : 0


/******************************************************************************/
網路相關指令
/******************************************************************************/
1. telnet
如果你要連線到別台 UNIX 主機或是連到 BBS，就使用 telnet 這個指令。例如，要telnet 到 sparc20.cc.ncu.edu.tw 這台機器：
$ telnet sparc20.cc.ncu.edu.tw
如果你在登入時想離開，可以按 CTRL+] 回到自己的主機，再打 quit 離開 telnet。
如果你在 telnet 時想輸入中文的話，必須加入參數 -8：
$ telnet -8 bbs.ba.mgt.ncu.edu.tw

2. ftp
ftp client工具，如果你要連到 ftp.isu.edu.tw 這台機器的話：
$ ftp ftp.isu.edu.tw
允許暱登入的 ftp 主機，帳號只要輸入 anonymous 或 ftp 即可。
進入 ftp 站台後，你可以使用下列指令：
?       列出所有指令。
ls      查看所在目錄的檔案，使用方法和在 FreeBSD 機器中一樣。
cd      進入某一個目錄，如 cd pub。
get <filename>  取回某一個檔案，如 get ve-1.0.tgz。
reget <filename> 續傳某一檔案。
put <filename>  上傳檔案，如 put homework01.zip。
send <filename> 上傳檔案，和 put 一樣。
size <filename> 查看檔案大小。
less <filename> 觀看文字檔內容

3. ping
送出 ICMP 封包，用以查看網路上主機的連線狀況。
$ ping 216.136.204.21
你也可以加入以下的參數：
-c count 只計算 count 次。
-s size 不使用預設的 64 bytes 當作封包大小，而改用新的 size。
$ ping -c 10 -s 108 216.136.204.21

4. nslookup
查詢網路主機資訊。此指令可以用來查詢網路主機的 Domain name，或以 Domain name 反查 IP 位址。
$ nslookup 216.136.204.21
$ nslookup www.freebsd.org
5.6.5 netstat
顯示網路狀況。可以用來看網路的組態及各項服務的情形。
參數：
-a 顯示所有資訊
-n 以 number 方式顯示 IP 位址
-i 顯示網路介面
$ netstat -a
$ netstat -ni

5. traceroute
追蹤網路路徑，用這個指令，你可以知道從你的主機到某一台主機的過程中經過了哪些機器。
使用方法：
$ traceroute www.freebsd.org

6. sockstat
查看主機 internet 或 domain socket。你可以用來查詢有誰連到你的機器中，由哪一個網路服務接收，該網路服務的 PID 是多少等。
還可以查詢本機開放了哪些 port、提供了哪些服務。

7. ifconfig
設定或檢查網路介面，ifconfig 可以用來設定你的網路卡，顯示網路介面的資訊。
參數：
-a 詳細顯示所有介面
-u 顯示目前使用中的裝置
interface 顯示該interface 的資訊，此 interface 為你的網路卡代號或其他代號。
down 停用某一裝置
up 啟用某一裝置
$ ifconfig -a           顯示所有介面的資訊
$ ifconfig vr0          顯示網路卡 vr0 的資訊
$ ifconfig vr0 down     停用網路卡 vr0
$ ifconfig vr0 192.168.0.1netmask 255.255.255.0 設定網路卡 vr0 的 ip
$ ifconfig vr0 up               啟用網路卡 vr0


/******************************************************************************/
讓Linux NAT伺服器支援UPnP       from : http://www.lslnet.com/linux/f/docs1/i59/big5392258.htm
/******************************************************************************/
注意：如果對網路安全要求較高或要求高可控制性的網路，則不要安裝配置UPnP支援，否則會導致網路NAT映射比較混亂，從而引發許多問題。
      建議小型網路或者家庭網路使用UPnP。
最近經常使用一些P2P類型軟體，發現老得在Linux伺服器上手動設置NAT，非常麻煩，而看著許多P2P軟體都支援UPnP就眼饞，如果能讓Linux支援UPnP那就簡單方便多了！
於是在網上搜索了一下有關讓Linux支援UPnP的文章，於是就寫了這篇文章。
一、什麼是UPnP
1. UPnP簡介
UPnP(Universal Plug and Play)技術對即插即用進行了擴展，它簡化了家庭或企業中智慧設備的聯網過程。在結合了UPnP技術的設備以物理形式連接到網路中之後，它們可以
通過網路自動彼此連接在一起，而且連接過程無需用戶的參與UPnP規範基於TCP/IP協定和針對設備彼此間通訊而制訂的其它Internet協定。這就是它之所以被稱作"通用
(Universal)"的原因所在--UPnP技術不依賴於特定的設備驅動程式，而是使用標準的協定。UPnP設備可以自動配置網路地址，宣佈它們在某個網路子網的存在，以及互相交換
對設備和服務的描述。基於Windows XP的電腦可以充當一個UPnP控制點，通過程式界面對設備進行發現和控制。 
如果與以前的即插即用相比，這種技術似乎並不具有什麼革命性的意義。在作業系統中增加即插即用技術使得在單個電腦上安裝、配置和添加外設的工作變得更容易了。但是
UPnP為家庭用戶或者小型辦公環境中的非專業用戶所帶來的是一道更加美味的"大餐"，他們可以利用UPnP玩多人遊戲，進行實時通信（Internet電話，電話會議）以及使用類
似Windows XP的遠端協助這樣的其它技術。 
2. NAT 穿越技術 
NAT穿越技術允許網路應用程式對它們是否位於一個具有UPnP能力的NAT設備之後進行檢測。然後，這些程式將獲得共享的全球可路由IP地址，並且配置連接埠映射以將來自NAT
外部連接埠的數據包轉發到應用程式使用的內部連接埠上--所有這一切都是自動完成的，用戶無需手動映射連接埠或者進行其它工作。NAT穿越技術允許網路設備或者點對點應
用程式通過動態開啟和閉合與外部服務之間的通信連接埠穿過NAT網關與外界通信。

二、在Linux中部署UPnP支援
我們假設該Linux的內核版本是2.4.x，使用撥號上網，外網介面是ppp0，內網介面是eth0，並且已經啟用iptables設定了 NAT。
在Linux中部署UPnP主要使用2個軟體的配合：UPnP SDK for Linux和LinuxIGD。
下載地址：
UPnP SDK for Linux: http://sourceforge.net/projects/upnp/
LinuxIGD: http://linux-igd.sourceforge.net/
注意：要下載upnpsdk-1.0.4.tar.gz，1.0.4以上的版本不能和LinuxIGD很好的協同工作！

A. 安裝：
1. 解包UPnP SDK
# tar xzvf upnpsdk-1.0.4.tar.gz
2. 修改源代碼
為了能夠使Windows MSN Messenger在UPnP下正常通訊，所以必須修改源代碼：
# cd upnpsdk-1.0.4
# vi src/ssdp/ssdplib.c
將第406行的：
SelfAddr.sin_addr.s_addr = inet_addr(SSDP_IP);
改為：
SelfAddr.sin_addr.s_addr = htonl(INADDR_ANY);
3. 編譯安裝UPnP SDK
# make
# make install
4. 解包Linux-IGD
# tar xzvf linuxigd-0.92.tgz
5. 編譯安裝Linux-IGD
# cd linux-igd
# make
# make install
B. 配置
1. 增加多播路由
# route add -net 239.0.0.0 netmask 255.0.0.0 eth0
2. 為iptables建議一個軟鏈接
# cd /usr/sbin
# ln -s /sbin/iptables ./
啟動UPnP
# upnpd ppp0 eth0
診斷UPnP運行狀態
# tail /var/log/messages
如果能夠看到：
Dec 14 16:01:49 doorway -- MARK --
Dec 14 16:02:15 doorway upnpd: The Linux UPnP Internet Gateway Device Ver 0.92 by Dime (dime@gulfsales.com)
Dec 14 16:02:15 doorway upnpd: Special Thanks for Intel's Open Source SDK and original author Genmei Mori's work.
則說明UPnP已經成功啟動。
C. 測試
以支援UPnP的P2P網路電視PPLive為例，在PPLive中打開UPnP支援選項，然後連接一個頻道。
在Linux中執行：
# tail /var/log/debug -f
如果能看到：
Dec 14 16:56:33 doorway upnpd: AddPortMap: RemoteHost: (null) Prot: 17 ExtPort: 3226 Int: 10.0.0.2.3226 
Dec 14 16:56:33 doorway upnpd: AddPortMap: RemoteHost: (null) Prot: 6 ExtPort: 3226 Int: 10.0.0.2.3226 
Dec 14 16:56:33 doorway upnpd: AddPortMap: RemoteHost: (null) Prot: 6 ExtPort: 3156 Int: 10.0.0.2.3156
Dec 14 16:56:33 doorway upnpd: AddPortMap: RemoteHost: (null) Prot: 6 ExtPort: 3156 Int: 10.0.0.2.3156
則說明PPLive已經向UPnP請求進行連接埠映射了。只要看到這樣的字樣，就說明UPnP已經完全工作起來了。


/******************************************************************************/
// Using upnpc:
/******************************************************************************/
1.源碼下載地址http://miniupnp.tuxfamily.org/files/
2. Using upnpc:
You should first list (-l) the services, actions and arguments supported by your IGD device.
Then you can invoke any command following the syntax:
./upnpc -a device:service:action arg1,arg2,arg3
One example would be:
./upnpc -a 0:3:2 80,TCP,1922.168.0.1,80
The actual parameters and values will depend on the device. Using -l you will have a list of the parameters you can use.
I will keep updating this code as i find necessary. Still, as my problem is solved, this code may stall until i require some additional feature, 
or someone submits a patch.
Any question regarding miniupnp, please contact Thomas Bernard at a:http://miniupnp.free.fr:miniupnp.free.fr:a.
3../upnpc-shared
upnpc : miniupnpc library test client. (c) 2006-2009 Thomas Bernard
Go to http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
for more information.
Usage : ./upnpc-shared [options] -a ip port external_port protocol
Add port redirection
./upnpc-shared [options] -d external_port protocol [port2 protocol2]?*[...]
Delete port redirection
./upnpc-shared [options] -s
Get Connection status
./upnpc-shared [options] -l
List redirections
./upnpc-shared [options] -r port1 protocol1 [port2 protocol2] [...]
Add all redirections to the current host
It looks like the "-a" option will do exactly what you want. It will automagically discover your router IP if the router is UPnP compatible.


/******************************************************************************/
UPnP AV Client on Linux
/******************************************************************************/
If you have been messing around with UPnP media servers like mediatomb it is a good idea to have a UPnP Client installed in your Linux box. 
I use djmount for this purpose.
The following methods are tested on Debian Lenny (testing) to install and run djmount and should work with any other Linux distribution with the 
only change of installing FUSE.

1 - Installing FUSE
# aptitude install libfuse-dev
Note: If you are not using Debian or any other Debian base distribution you should compile and install FUSE manually. 
You can find more information on FUSE Project Page
2 - Install djmount
Download djmount from SourceForge.NET and untar, compile and install.
$ tar -zxvf djmount-0.71.tar.gz
$ cd djmount-0.71
$ ./configure
$ make
$ su
# make install
That's it. Now you should have djmount successfully installed on your Linux distribution.
3 - Make the directories
We need to create a separate directory so that djmount will mount the UPnP devices. It is logical to have this directory in /mnt or in /media.
# mkdir /media/upnp
# chmod 777 /media/upnp
4 - Mount the UPnP devices
First of all make sure that FUSE kernel module is loaded.
# modprobe fuse
Now it is time to start djmount,

# djmount -o allow_other /media/upnp
Once djmount is started it will search for any reachable UPnP media servers and mount them in /media/upnp and 
you can access the media files like in any other UPnP client.


/******************************************************************************/
UPnp AV Client on Linux ( FUSE & djmount移植)
/******************************************************************************/
利用fuse & djmount來建構一個UPnp的client
所需軟體：
1. fuse_2.8.1.orig.tar.gz
2. djmount-0.71.tar.gz

一、先行在Ubuntu上頭測試：
1. 安裝fuse-2.8.1
   a. ~# ./configure --prefix=/home/app_fd/fuse-2.8.1/output
   b. ~# make
   c. ~# make install
     此時在home/app_fd/fuse-2.8.1/output下，生成文件
2. 安裝djmount
   a. ~# ./configure --prefix=/home/app_fd/djmount-0.71/output --with-fuse-prefix=/home/app_fd/fuse-2.8.1/output
   b. ~# make
   c. ~# make install
     此時在home/app_fd/djmount-0.71/output/bin下 生成執行檔
3. 創建一個資料夾
   我們需要創建一個資料夾以便於提供給djmount mount UPnP Device。
   ~# mkdir /media/upnp
   ~# chmod 777 /media/upnp
4. Mount Upnp 裝置
   首先，先確定FUSE Kernal module已載入( mknod /dev/fuse c 10 229 )
   ~# modprobe fuse
5. 然後啟動djmount
   ~# ./djmount -o allow_other /media/upnp
[I]   Mount options = allow_other
[I] Charset : successfully initialised charset='UTF-8'
6. 一經djmount啟動後，將會尋找網路上所有的UPnp media servers以及mount到/media/upnp的目錄底下。
   並且可以存取media files。
 觀察出現的upnp media servers
   ~# ls /media/upnp 
 OR 用mount -l來觀察
   ~# mount -l
/dev/sda1 on / type ext4 (rw,errors=remount-ro)
...
djmount on /media/upnp type fuse.djmount (ro,nosuid,nodev,allow_other)

7. 可用MPlayer測試。
   ~# mplayer /media/upnp/"media server name"/"files name"

二、移植到SDK上
1. 安裝fuse-2.8.1
   a. ~# ./configure --prefix=/home/app_fd/fuse-2.8.1/output_rtl
   b. ~# make
   c. ~# make install
     此時在home/app_fd/fuse-2.8.1/output_rtl下，生成文件
   d. 將home/app_fd/fuse-2.8.1/output_rtl/lib下的函式庫copy到sdk board的/lib中
2. 安裝djmount
   a. ~# ./configure --prefix=/home/app_fd/djmount-0.71/output --with-fuse-prefix=/home/app_fd/fuse-2.8.1/output_rtl
   b. ~# make
   c. ~# make install
     此時在home/app_fd/djmount-0.71/output_rtl/bin下 生成執行檔
   d. 將home/app_fd/djmount-0.71/output_rtl/bin下的djmount Cpy到sdk board的/home中
3. 創建一個資料夾
   我們需要創建一個資料夾以便於提供給djmount mount UPnP Device。
   ~# mkdir /tmp/upnp
   ~# chmod 777 /tmp/upnp
4. Mount Upnp 裝置
   先確定FUSE Kernal module已載入
   ~# ls /dev/fuse 發現已有fuse
5. 然後啟動djmount
   ~# ./djmount -o allow_other /tmp/upnp
出現下列錯誤
djmount: can't resolv symbol "sigdelset"
判斷原因為所以要的函式庫不足。最後將toolchain/rsdk-1.3.6-4181-EB-2.6.30-0.9.30/lib底下的.so檔也copy到sdk的/lib中
6. 再測試
   ~# ./djmount -o allow_other /media/upnp
[I]   Mount options = allow_other
[I] Charset : successfully initialised charset='UTF-8'
  看起來是執行了，但
   ~# ls /media/upnp
改用前景執行，藉由前景執行的資訊來觀察。
# ./djmount -f /tmp/upnp
[I] Charset : successfully initialised charset='ASCII'
[I] UPnP Initialized (192.168.100.157:49152)
fuse: device not found, try 'modprobe fuse' first
[E] Error in FUSE main loop = 1
7. 修改linux menuconfig
~# make menuconfig
File systems --->
[*] FUSE (Filesystem in Userspace) support
8. 再測試
   ~# ./djmount -o allow_other /media/upnp
9. 這時就看得到所有在網路中的UPnp Media Servers
   可試著用mplayer播放目錄中的音樂檔。

目前還有一個問題就是看不到中文的目錄。


/******************************************************************************/
madplay命令行查詢
/******************************************************************************/
~#madplay --help
Usage: madplay [OPTIONS] FILE [...]
Decode and play MPEG audio FILE(s).
Verbosity:
  -v, --verbose                show status while decoding（解碼的時候顯示狀態）
  -q, --quiet                  be quiet but show warnings（保持靜音，但顯示警告資訊）
  -Q, --very-quiet             be quiet and do not show warnings（保持靜音，不顯示警告）
      --display-time=MODE      use default verbose time display MODE
                               (remaining, current, overall)（使用默認的詳細時間顯示模式（剩餘電流，整體））

Decoding:
      --downsample             reduce sample rate 2:1（降低取樣率（原來的1/2））
  -i, --ignore-crc             ignore CRC errors（忽略CRC校正）
      --ancillary-output=PATH  write ancillary data to PATH（輔助的數據支援添加進PATH）

Audio output:
  -o, --output=[TYPE:]PATH     write output to PATH with format TYPE (below)（將輸出寫入路徑以格式類型）
  -b, --bit-depth=DEPTH        request DEPTH bits per sample（每個樣本的請求的深度位）
  -R, --sample-rate=HERTZ      request HERTZ samples per second（每秒鐘的取樣數（即取樣率））
  -d, --no-dither              do not dither output PCM samples（不抖動輸出PCM樣本）
      --fade-in[=DURATION]     fade-in songs over DURATION (default 0:05)（淡入超過持續時間的歌曲（默認0:05））
  -a, --attenuate=DECIBELS     attenuate signal by DECIBELS (-)（分貝[音量]衰減的信號）
  -a, --amplify=DECIBELS       amplify signal by DECIBELS (+)（分貝[音量]放大的信號）
  -A, --adjust-volume=DECIBELS override per-file volume adjustments（覆蓋每個文件的音量調整）
  -G, --replay-gain[=PROFILE]  enable Replay Gain volume adjustments using
                                 PROFILE (radio, audiophile)啟用回放增益音量調整使用配置文件（收音機，高保真音響）

Channel selection:
  -1, --left                   output first (left) channel only（只使用第一個（左）聲道輸出）
  -2, --right                  output second (right) channel only（只使用第二個（右）聲道輸出）
  -m, --mono                   mix left and right channels for monaural output（混合左，右聲道為單聲道輸出）
  -S, --stereo                 force stereo output（立體聲輸出）

Playback:
  -s, --start=TIME             skip to begin at TIME (HH:MM:SS.DDD)（跳到從（HH:MM:SS.DDD）開始的時間）
  -t, --time=DURATION          play only for DURATION (HH:MM:SS.DDD)（僅播放(HH:MM:SS.DDD)時間內的streaming）
  -z, --shuffle                randomize file list（隨機播放文件列表）
  -r, --repeat[=MAX]           play files MAX times, or indefinitely（播放文件最大時間，或者無期限）
      --tty-control            enable keyboard controls（允許鍵盤控制）
      --no-tty-control         disable keyboard controls（禁用鍵盤控制）

Miscellaneous:
  -T, --show-tags-only         show ID3/encoder tags only (do not decode)（只顯示 ID3/編碼器 標籤（不解碼））
  -V, --version                display version number and exit（顯示版本號並退出）
      --license                show copyright/license message and exit（顯示版權/許可資訊並退出）
  -h, --help                   display this help and exit（顯示幫助並退出）

Supported output formats:
  cdda    CD audio, 16-bit big-endian 44100 Hz stereo PCM (*.cdr, *.cda)
  aiff    Audio IFF, [16-bit] PCM (*.aif, *.aiff)
  wave    Microsoft RIFF/WAVE, [16-bit] PCM (*.wav)
  snd     Sun/NeXT audio, 8-bit ISDN mu-law (*.au, *.snd)
  raw     binary [16-bit] host-endian linear PCM
  hex     ASCII hexadecimal [24-bit] linear PCM
  null    no output (decode only)


/******************************************************************************/
Mplayer 安裝選項
/******************************************************************************/
安裝路徑:
--prefix=DIR                      安裝路徑 [/usr/local]
--bindir=DIR                      執行程式安裝路徑 [PREFIX/bin]
--datadir=DIR                     相關文件安裝路徑 [PREFIX/share/mplayer]
--mandir=DIR                      使用手冊安裝路徑 [PREFIX/share/man]
--confdir=DIR                     配置文件安裝路徑 [PREFIX/etc/mplayer]
--libdir=DIR                      對像代碼庫文件安裝路徑 [PREFIX/lib]
--codecsdir=DIR                   二進位解碼器安裝路徑 [LIBDIR/codecs]
--win32codecsdir=DIR              Windows DLLs 文件安裝路徑[LIBDIR/codecs]
--xanimcodecsdir=DIR              XAnim 解碼器安裝路徑 [LIBDIR/codecs]
--realcodecsdir=DIR               RealPlayer 解碼器安裝路徑 [LIBDIR/codecs]

可選特性:
--disable-mencoder                不編譯 mencoder(A/V 編碼器) [有效]
--disable-mplayer                 不編譯 mplayer [有效]
--enable-gui                      編譯 gmplayer,使用GTK+ 可視界面 [無效]
--enable-gtk1                     強制使用 GTK 1.2 做為交互界面 [無效]
--enable-largefiles               支援大於 2GB 的文件[disable]
--enable-linux-devfs              默認設備設置到devfs中(設備文件系統)[無效]
--enable-termcap                  關鍵代碼使用 termcap(terminal capabilities)數據庫 [自動檢測]
--enable-termios                   關鍵代碼使用 termios (terminal I/O)[自動檢測]
--disable-iconv                   不使用 iconv 進行編碼轉換 [自動檢測]
--disable-langinfo                不使用 langinfo[自動檢測]
--enable-lirc                     支援 LIRC (遠端控制)[自動檢測]
--enable-lircc                    支援 LIRCC 輸入(LIRC 用戶端守護進程)[自動檢測]
--enable-joystick                 支援控制桿[無效]
--enable-apple-remote             使用 Apple 遠端控制 (Mac OS X only) [自動檢測]
--disable-vm                      不使用 X video 模式擴展[自動檢測]
--disable-xf86keysym              不支援多媒體鍵[自動檢測]
--enable-radio                     廣播介面 [無效]
--enable-radio-capture             廣播捕獲(通過 PCI/line-in) [無效]
--disable-radio-v4l2               不使用 Video4Linux2 廣播借口 [自動檢測]
--disable-radio-bsdbt848           不使用 BSD BT848 廣播借口 [自動檢測]
--disable-tv                       不使用電視介面 (TV/DVB 採集卡) [有效]
--disable-tv-v4l1                  不使用 Video4Linux TV 介面 [自動檢測]
--disable-tv-v4l2                  不使用 Video4Linux2 TV 介面 [自動檢測]
--disable-tv-bsdbt848              不使用 BSD BT848 介面 [自動檢測]
--disable-tv-teletext              不使用 圖文電視(TV teletext) 介面 [自動檢測]
--disable-pvr                      不使用 Video4Linux2 MPEG PVR [自動檢測]
--disable-rtc                      不使用 Linux下的RTC (/dev/rtc)[自動檢測]
--disable-network                  不使用網路 [有效]
--enable-winsock2                  允許 winsock2 [自動檢測]
--enable-smb                       允許 Samba (SMB) 輸入[自動檢測]
--enable-live                      允許 LIVE555 流媒體[自動檢測]
--enable-nemesi                    允許 Nemesi 流媒體 [自動檢測]
--disable-dvdnav                   禁用 libdvdnav [自動檢測]
--disable-dvdread                  禁用 libdvdread [自動檢測]
--disable-dvdread-internal         禁用內部 libdvdread [自動檢測]
--disable-libdvdcss-internal       禁用內部 libdvdcss [自動檢測]
--disable-cdparanoia               禁用 cdparanoia [自動檢測]
--disable-cddb                     禁用 cddb [自動檢測]
--disable-bitmap-font              禁用點陣字體支援 [有效]
--disable-freetype                 禁用 Freetype2 字型呈現[自動檢測]
--disable-fontconfig               禁用 fontconfig 的字體查找 [自動檢測]
--disable-unrarlib                 禁用 Unique RAR 文件庫 [有效]
--enable-menu                      使用 OSD 功能表 (非 DVD 功能表) [無效]
--disable-sortsub                  禁用字幕排序 [有效]
--enable-fribidi                   FriBiDi 庫 [自動檢測]
--disable-enca                     禁用 ENCA 字元集的 oracle 庫[自動檢測]
--disable-macosx                   禁用 Mac OS X 下制定特效 [自動檢測]
--disable-maemo                    禁用 maemo 指定特效 [自動檢測]
--enable-macosx-finder-support     Mac OS X Finder 引用參數解析 [無效]
--enable-macosx-bundle             Mac OS X 捆綁文件位置 [自動檢測]
--disable-inet6                    禁用 IPv6 支援 [自動檢測]
--disable-gethostbyname2           gethostbyname2 C 庫的一部分[自動檢測]
--disable-ftp                      禁用 FTP 支援 [有效]
--disable-vstream                  禁用 TiVo vstream 用戶端支援[自動檢測]
--disable-pthreads                 禁用 Posix 線程支援 [自動檢測]
--disable-w32threads               禁用 Win32 線程支援 [自動檢測]
--disable-ass                      禁用內部 SSA/ASS 字幕支援 [自動檢測]
--enable-rpath                     運行時鏈接器路徑到額外庫 [無效]

解碼器:
--enable-gif                       GIF 支援 [自動檢測]
--enable-png                       PNG 輸入/輸出支援 [自動檢測]
--enable-jpeg                      JPEG 輸入/輸出支援 [自動檢測]
--enable-libcdio                   外部 libcdio [自動檢測]
--enable-liblzo                    外部 liblzo [自動檢測]
--disable-win32dll                 禁用 Win32 DLL 支援 [有效]
--disable-qtx                      禁用 QuickTime 解碼器支援 [有效]
--disable-xanim                    禁用 XAnim 解碼器支援 [有效]
--disable-real                     禁用 RealPlayer 解碼器支援 [有效]
--disable-xvid                     禁用 XviD [自動檢測]
--disable-x264                     禁用 x264 [自動檢測]
--disable-libnut                   禁用 libnut [自動檢測]
--disable-libavutil_a              禁用靜態 libavutil [自動檢測]
--disable-libavcodec_a             禁用靜態 libavcodec [自動檢測]
--disable-libavformat_a            禁用靜態 libavformat [自動檢測]
--disable-libpostproc_a            禁用靜態 libpostproc [自動檢測]
--disable-libavutil_so             禁用共享 libavutil [自動檢測]
--disable-libavcodec_so            禁用共享 libavcodec [自動檢測]
--disable-libavformat_so           禁用共享 libavformat [自動檢測]
--disable-libpostproc_so           禁用共享 libpostproc [自動檢測]
--disable-libavcodec_mpegaudio_hp  禁用 libavcodec 中高精度音頻解碼 [有效]
--disable-tremor-internal          禁用外部 Tremor [有效]
--enable-tremor-low                低精度內部 Tremor [無效]
--enable-tremor-external           外部Tremor [自動檢測]
--disable-libvorbis                禁用 libvorbis 支援 [自動檢測]
--disable-speex                    禁用 Speex 支援 [自動檢測]
--enable-theora                    OggTheora 庫 [自動檢測]
--enable-faad-external             外部 FAAD2 (AAC) [自動檢測]
--disable-faad-internal            禁用內部 FAAD2 (AAC) [自動檢測]
--enable-faad-fixed                內部 FAAD2 使用固定點模式 [無效]
--disable-faac                     禁用對 FAAC (AAC 編碼器) 的支援 [自動檢測]
--disable-ladspa                   禁用 LADSPA 插件支援 [自動檢測]
--disable-libdv                    禁用 libdv 0.9.5 編碼/解碼 支援[自動檢測]
--disable-mad                      禁用 libmad (MPEG 音頻) 支援 [自動檢測]
--disable-toolame                  禁用 Toolame (MPEG layer 2) 編碼 [自動檢測]
--disable-twolame                  禁用 Twolame (MPEG layer 2) 編碼 [自動檢測]
--enable-xmms                      XMMS 輸入插件支援 [無效]
--enable-libdca                    libdca 支援 [自動檢測]
--disable-mp3lib                   禁用內建 mp3lib [有效]
--disable-liba52                   禁用內建 liba52 [有效]
--disable-libmpeg2                 禁用內建 libmpeg2 [有效]
--disable-musepack                 禁用 musepack 支援 [自動檢測]
--disable-libamr_nb                禁用 libamr 窄頻 [自動檢測]
--disable-libamr_wb                禁用 libamr 寬頻 [自動檢測]
--disable-decoder=DECODER          禁用指定 FFmpeg 解碼器
--enable-decoder=DECODER           使用指定 FFmpeg 解碼器
--disable-encoder=ENCODER          禁用指定 FFmpeg 編碼器
--enable-encoder=ENCODER           使用指定 FFmpeg 編碼器
--disable-parser=PARSER            禁用指定 FFmpeg 分析器
--enable-parser=PARSER             使用指定 FFmpeg 分析器

--disable-demuxer=DEMUXER          禁用指定 FFmpeg 分離器 （demuxer）
--enable-demuxer=DEMUXER           使用指定 FFmpeg 分離器
--disable-muxer=MUXER              禁用指定 FFmpeg 合併器 （muxer）

--enable-muxer=MUXER               使用指定 FFmpeg 合併器

視頻輸出:
--disable-vidix-internal           禁用內部 VIDIX [for x86 *nix]
--disable-vidix-external           禁用內部 VIDIX [for x86 *nix]
--with-vidix-drivers[=*]           VIDIX 驅動編譯列表
                                   可用: cyberblade,ivtv,mach64,mga,mga_crtc2,
                                   nvidia,pm2,pm3,radeon,rage128,savage,sis,unichrome
--enable-gl                        OpenGL 視頻輸出[自動檢測]
--enable-dga2                      DGA 2 支援 [自動檢測]
--enable-dga1                      DGA 1 支援 [自動檢測]
--enable-vesa                      VESA 視頻輸出 [自動檢測]
--enable-svga                      SVGAlib 視頻輸出 [自動檢測]
--enable-sdl                       SDL 視頻輸出 [自動檢測]
--enable-aa                        AAlib 視頻輸出 [自動檢測]
--enable-caca                      CACA 視頻輸出 [自動檢測]
--enable-ggi                       GGI 視頻輸出 [自動檢測]
--enable-ggiwmh                    GGI libggiwmh 擴展 [自動檢測]
--enable-directx                   DirectX 視頻輸出 [自動檢測]
--enable-dxr2                      DXR2 視頻輸出 [自動檢測]
--enable-dxr3                      DXR3/H+ 視頻輸出 [自動檢測]
--enable-ivtv                      IVTV TV-Out 視頻輸出 [自動檢測]
--enable-v4l2                      V4L2 Decoder 音頻/視頻輸出 [自動檢測]
--enable-dvb                       DVB 視頻輸出 [自動檢測]
--enable-dvbhead                   DVB 視頻輸出 (HEAD version) [自動檢測]
--enable-mga                       mga_vid 視頻輸出 [自動檢測]
--enable-xmga                      mga_vid X11 視頻輸出 [自動檢測]
--enable-xv                        Xv 視頻輸出 [自動檢測]
--enable-xvmc                      XvMC 加速 [無效]
--enable-vm                        XF86VidMode 支援 [自動檢測]
--enable-xinerama                  Xinerama 支援 [自動檢測]
--enable-x11                       X11 視頻輸出 [自動檢測]
--enable-xshape                    XShape 支援 [自動檢測]
--enable-fbdev                     FBDev 視頻輸出 [自動檢測]
--enable-mlib                      mediaLib 視頻輸出 (Solaris) [無效]
--enable-3dfx                      obsolete /dev/3dfx 視頻輸出 [無效]
--enable-tdfxfb                    tdfxfb 視頻輸出 [無效]
--enable-s3fb                      s3fb (S3 ViRGE) 視頻輸出 [無效]
--enable-directfb                  DirectFB 視頻輸出 [自動檢測]
--enable-zr                        ZR360[56]7/ZR36060 視頻輸出 [自動檢測]
--enable-bl                        Blinkenlights 視頻輸出 [無效]
--enable-tdfxvid                   tdfx_vid 視頻輸出 [disable]
--enable-xvr100                    SUN XVR-100 視頻輸出 [自動檢測]
--disable-tga                      禁用 Targa 視頻輸出 [有效]
--disable-pnm                      禁用 PNM 視頻輸出 [有效]
--disable-md5sum                   禁用 md5sum 視頻輸出 [有效]

音頻輸出:
--disable-alsa                     禁用 ALSA 音頻輸出 [自動檢測]
--disable-ossaudio                 禁用 OSS 音頻輸出 [自動檢測]
--disable-arts                     禁用 aRts 音頻輸出 [自動檢測]
--disable-esd                      禁用 esd 音頻輸出 [自動檢測]
--disable-polyp                    禁用 Polypaudio 音頻輸出 [自動檢測]
--disable-jack                     禁用 JACK 音頻輸出 [自動檢測]
--disable-openal                   禁用 OpenAL 音頻輸出 [自動檢測]
--disable-nas                      禁用 NAS 音頻輸出 [自動檢測]
--disable-sgiaudio                 禁用 SGI 音頻輸出 [自動檢測]
--disable-sunaudio                 禁用 Sun 音頻輸出 [自動檢測]
--disable-win32waveout             禁用 Windows waveout 音頻輸出 [自動檢測]
--disable-select                   在音頻設備中禁用 select() [有效]

雜項:
--enable-runtime-cpudetection      運行時 CPU 檢測 [無效]
--enable-cross-compile             交叉編譯 [自動檢測]
--cc=COMPILER                      生成 MPlayer 的 C 編譯器 [gcc]
--host-cc=COMPILER                 生成 Mplayer 時的必要工具的 C 編譯器 [gcc]
--as=ASSEMBLER                     生成 MPlayer 的彙編 [as]
--ar=AR                            生成 MPlayer 的庫集 [ar]
--ranlib=RANLIB                    生成 MPlayer 的 ranlib [ranlib]
--target=PLATFORM                  目標平台 (i386-linux, arm-linux, etc)
--enable-static                    生成靜態的二進位鏈接
--charset=charset                  將控制台資訊轉化到字元集
--language=list                    空格或者逗號分隔在用戶手冊中使用的語言，第一個將會在資訊和GUI中使用(環境變數 $LINGUAS 也會加入) [en]
                                   (可用: bg cs de dk el en es fr hu it ja ko mk nb nl pl ro ru sk sv tr uk pt_BR zh_CN zh_TW all)
--with-install=PATH                已裝程式路徑
--enable-color-console             彩色控制台輸出(不支援) [無效]

高級選項:
--enable-mmx                       MMX [自動檢測]
--enable-mmxext                    MMX2 (Pentium III, Athlon) [自動檢測]
--enable-3dnow                     3DNow! [自動檢測]
--enable-3dnowext                  擴展 3DNow! [自動檢測]
--enable-sse                       SSE [自動檢測]
--enable-sse2                      SSE2 [自動檢測]
--enable-ssse3                     SSSE3 [自動檢測]
--enable-shm                       shm [自動檢測]
--enable-altivec                   AltiVec (PowerPC) [自動檢測]
--enable-armv5te                   DSP 擴展 (ARM) [自動檢測]
--enable-armv6                     ARMv6 (ARM) [自動檢測]
--enable-iwmmxt                    iWMMXt (ARM) [自動檢測]
--disable-fastmemcpy               禁用 3DNow!/SSE/MMX 優化 memcpy [有效]
--enable-big-endian                強制將位元組按照 Big-endian 規則排放 [自動檢測]
--enable-debug[=1-3]               編譯調試(debugging)資訊 [無效]
--enable-profile                   編譯記錄(profiling)資訊 [無效]
--disable-sighandler               禁用崩潰時 sighandler [有效]
--enable-crash-debug               自動鏈接 gdb 到崩潰位置 [無效]
--enable-dynamic-plugins           動態 A/V 插件 [無效]

危險的選項「不報告任何錯誤！」
--disable-gcc-check                禁用 gcc 版本檢測 [有效]

自動檢測失敗時使用 (用(*)標記的選項之間用 ':' 分割
--extra-libs=FLAGS                 額外鏈接標誌
--extra-libs-mplayer=FLAGS         MPlayer 額外鏈接標誌
--extra-libs-mencoder=FLAGS        MEncoder 額外鏈接標誌
--with-extraincdir=DIR             DIR 中額外頭文件尋找路徑 (*)
--with-extralibdir=DIR             DIR 中額外的鏈接器尋找路徑 (*)
--with-xvmclib=NAME                適配器指定的庫名 (e.g. XvMCNVIDIA)

--with-freetype-config=PATH        freetype-config 路徑
--with-fribidi-config=PATH         fribidi-config 路徑
--with-glib-config=PATH            glib*-config 路徑
--with-gtk-config=PATH             gtk*-config 路徑
--with-sdl-config=PATH             sdl*-config 路徑
--with-dvdnav-config=PATH          dvdnav-config 路徑


/******************************************************************************/
SPI Flash是什麼?
/******************************************************************************/
SPI，是英語Serial Peripheral interface的縮寫，顧名思義就是串行外圍設備介面。
SPI介面主要應用在 EEPROM，FLASH，實時時鐘，AD轉換器，還有數字信號處理器和數字信號解碼器之間。
SPI總線系統是一種同步串行外設介面，可以使MCU與外圍設備以串行方式進行通信。


/******************************************************************************/
uClinux啟動過程
/******************************************************************************/
嵌入式設備上電啟動後，Flash中的程式獲得控制權，Flash中的程式包括bootloader和一個壓縮過的內核(另外還含有一個romfs的文件系統)。
Flash中的程式首先配置記憶體地址，將本身由原來系統默認的地址配置為0x0到0x200000(2MByte)，SDRAM配置為0xl000000(16MByte)到0x2000000(32MByte)，
然後把Flash的內容整體拷貝SDRAM中。
拷貝完後，將SDRAM地址重新配置為0x0到0xl000000，Flash的地址改為0xl000000到0xl200000。
注意，這裡Flash和RAM地址是同時修改的，修改地址後，接下來的指令就將從SDRAM中獲得，
由於SDRAM中的程式和原來Flash中的程式一樣，並且地址也一樣，所以不會影響指令的執行。
這裡要說明一點的是，很多NOMMU的處理器上電後都是從地址0X0讀程式並開始執行的，這是Flash地址，但處理器的中斷向量地址表一般也都會放在0x0地址開始的RAM中，
所以NOMMU的處理器一般都要經過上述的初始化過程，才可以使用自己編寫的中斷程式。而MMU的處理器可以通過MMU將物理地址中的0X0地址換成邏輯的非0X0地址。
完成上面的工作後，SDRAM中的程式就解壓縮內核到0x8000地址，最後跳到該地址執行。
當Bootloader將控制權交給內核的引導程式時，第一個執行的程式就是head.S，它完成了加載內核的大部分工作，初始完硬體相關的系統配置後，
就把內核解壓縮到一具體地址，完成在head-armv.S中設置好系統堆棧等參數後，系統跳轉到解壓縮後的內核地址，將不再返回，
程式實際執行的是uClinux/init/main.c文件中的start_kernel函數，負責內核初始化部分；
misc.c則提供加載內核所需要的子程式，其中解壓內核的子程式是head.S調用的重要程式，
另外內核的加載還須知道系統的硬體資訊，該硬體資訊在hardware.h中定義並被head.S所引用。


/******************************************************************************/
與軟體編譯安裝有關的一些系統環境變數的說明
/******************************************************************************/
Makefile 規則中的編譯命令通常是怎麼寫的。
大多數套裝軟體遵守如下約定俗成的規範：
#1,首先從源代碼生成目標文件(預處理,編譯,彙編)，"-c"選項表示不執行鏈接步驟。
$(CC) $(CPPFLAGS) $(CFLAGS) example.c   -c   -o example.o
#2,然後將目標文件連接為最終的結果(連接)，"-o"選項用於指定輸出文件的名字。
$(CC) $(LDFLAGS) example.o   -o example

#有一些套裝軟體一次完成四個步驟：
$(CC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS) example.c   -o example

當然也有少數套裝軟體不遵守這些約定俗成的規範，比如：
#1,有些在命令行中漏掉應有的Makefile變數(注意：有些遺漏是故意的)
$(CC) $(CFLAGS) example.c    -c   -o example.o
$(CC) $(CPPFLAGS) example.c -c   -o example.o
$(CC) example.o   -o example
$(CC) example.c   -o example
#2,有些在命令行中增加了不必要的Makefile變數
$(CC) $(CFLAGS) $(LDFLAGS) example.o   -o example
$(CC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS) example.c   -c   -o example.o

當然還有極個別套裝軟體完全是"胡來"：亂用變數(增加不必要的又漏掉了應有的)者有之，不用$(CC)者有之，不一而足.....
儘管將源代碼編譯為二進位文件的四個步驟由不同的程式(cpp,gcc/g++,as,ld)完成，但是事實上 cpp, as, ld 都是由 gcc/g++ 進行間接調用的。換句話說，控制了
 gcc/g++ 就等於控制了所有四個步驟。從 Makefile 規則中的編譯命令可以看出，編譯工具的行為全靠 CC/CXX CPPFLAGS CFLAGS/CXXFLAGS LDFLAGS 這幾個變數在控制。
當然理論上控制編譯工具行為的還應當有 AS ASFLAGS ARFLAGS 等變數，但是實踐中基本上沒有套裝軟體使用它們。
那麼我們如何控制這些變數呢？一種簡易的做法是首先設置與這些 Makefile 變數同名的環境變數並將它們 export 為全局，然後運行 configure 腳本，大多數 configure 
腳本會使用這同名的環境變數代替 Makefile 中的值。但是少數 configure 腳本並不這樣做(比如GCC和Binutils的腳本就不傳遞LDFLAGS)，你必須手動編輯生成的 Makefile
文件，在其中尋找這些變數並修改它們的值，許多源碼包在每個子文件夾中都有 Makefile 文件，真是一件很累人的事！
一些與編譯、連接有關的環境變數，當然，這些環境變數是否真正有效取決於軟體如何生成Makefile，如果是硬編碼，那麼這些環境變數可能是無效的，若是軟編碼，則有效。

CC 與 CXX
這是 C 與 C++ 編譯器命令。預設值一般是 "gcc" 與 "g++"。這個變數本來與優化沒有關係，但是有些人因為擔心套裝軟體不遵守那些約定俗成的規範，害怕自己苦心設置的
 CFLAGS/CXXFLAGS/LDFLAGS 之類的變數被忽略了，而索性將原本應當放置在其它變數中的選項一股老兒塞到 CC 或 CXX 中，比如：CC="gcc -march=k8 -O2 -s"。這是一種怪
 異的用法，本文不提倡這種做法，而是提倡按照變數本來的含義使用變數。

CPPFLAGS
這是用於預處理階段的選項。不過能夠用於此變數的選項，看不出有哪個與優化相關。如果你實在想設一個，那就使用下面這兩個吧：
-DNDEBUG
    "NDEBUG"是一個標準的 ANSI 宏，表示不進行調試編譯。 
-D_FILE_OFFSET_BITS=64
    大多數包使用這個來提供大文件(>2G)支援。 

CFLAGS 與 CXXFLAGS
CFLAGS 表示用於 C 編譯器的選項，CXXFLAGS 表示用於 C++ 編譯器的選項。這兩個變數實際上涵蓋了編譯和彙編兩個步驟。
大多數程式和庫在編譯時默認的優化級別是"2"(使用"-O2"選項)並且帶有調試符號來編譯，也就是 CFLAGS="-O2 -g", CXXFLAGS=$CFLAGS 。事實上，"-O2"已經啟用絕大多數
安全的優化選項了。

LDFLAGS
LDFLAGS 是傳遞給連接器的選項。這是一個常被忽視的變數，事實上它對優化的影響也是很明顯的。
除了用來優化，它可以用來指定一些動態庫的路徑。如-L/usr/local/lib

LD_RUN_PATH
用來指定在編譯時到哪些目錄去尋找動態庫，多個目錄以冒號隔開

LD_LIBRARY_PATH
用來指定在運行時到哪些目錄去尋找動態庫，多個目錄以冒號隔開

關於LD_RUN_PATH和LD_LIBRARY_PATH的詳細說明：
http://osr507doc.sco.com/en/tools/ccs_linkedit_dynamic_dirsearch.html
Specifying directories to be searched by the dynamic linker
When you use the -l option, you must point the dynamic linker to the directories of the dynamically linked libraries that are to be linked with your 
program at execution. The environment variable LD_RUN_PATH lets you do that at link time. To set LD_RUN_PATH, list the absolute pathnames of the 
directories you want searched in the order you want them searched. Separate pathnames with a colon, as shown in the following example:
LD_RUN_PATH=/home/mylibs export LD_RUN_PATH
The command:
cc -dy -o prog -L/home/mylibs file1.c file2.c file3.c -lfoo

directs the dynamic linker to search for libfoo.so in /home/mylibs when you execute your program:
prog
The dynamic linker searches the standard place by default, after the directories you have assigned to LD_RUN_PATH. Note that as far as the dynamic 
linker is concerned, the standard place for libraries is /usr/lib. Any executable versions of libraries supplied by the compilation system kept 
in /usr/lib.
The environment variable LD_LIBRARY_PATH lets you do the same thing at run time. Suppose you have moved libfoo.so to /home/sharedobs. 
It is too late to replace /home/mylibs with /home/sharedobs in LD_RUN_PATH, at least without link editing your program again. 
You can, however, assign the new directory to LD_LIBRARY_PATH, as follows:
LD_LIBRARY_PATH=/home/sharedobs export LD_LIBRARY_PATH

Now when you execute your program
prog
the dynamic linker searches for libfoo.so first in /home/mylibs and, not finding it there, in /home/sharedobs. 
The directory assigned to LD_RUN_PATH is searched before the directory assigned to LD_LIBRARY_PATH. 
The important point is that because the pathname of libfoo.so is not hard-coded in prog, you can direct the dynamic linker to search a different 
directory when you execute your program. You can move a dynamically linked library without breaking your application.
You can set LD_LIBRARY_PATH without first having set LD_RUN_PATH. The main difference between them is that once you have used LD_RUN_PATH for an 
application, the dynamic linker searches the specified directories every time the application is executed (unless you have relinked the application 
in a different environment). In contrast, you can assign different directories to LD_LIBRARY_PATH each time you execute the application. 
LD_LIBRARY_PATH directs the dynamic linker to search the assigned directories before it searches the standard place. 
Directories, including those in the optional second list, are searched in the order listed. See the previous section for the syntax.
Note, finally, that when linking a set-user or set-group program, the dynamic linker ignores any directories that are not built into the dynamic linker. 
Currently, the only built-in directory is /usr/lib.


/******************************************************************************/
CFLAGS參數詳解(Desktop cflags)
/******************************************************************************/
相信使用lfs,gentoo的用戶對CFLAGS這個東東會比較瞭解 :) 
不少Linuxer對Gentoo,LFS的印象是速度比其他發行版要快的多!  
而這個CFLAGS就是達到最佳效能的東東。如果你想編譯出的程式更快，運行的更好。
快來挑選出最符合自己的CFLAGS吧！ ^_^

CFLAGS 簡介 
CFLAGS 是決定 Gentoo 系統效能與穩定的關鍵之一。恰當的 CFLAGS 能在效能、編譯時間、與系統穩定度中取得平衡，失敗的 CFLAGS 可能導致編譯失敗，甚至系統損毀。
那麼，在茫茫 CFLAGS 海中，如何才能撈到命中注定那根針呢？ 
此文件的 CFLAGS 針對 x86 與 x86-64 平台上的 GCC 3.4 (GNU Compiler Collections - http://gcc.gnu.org/) 為主，若您使用其它編譯器 (如 icc、compaq c compiler)
或其它平台 (如 PowerPC、Alpha)，本章可能 50% 以上的東西您都用不上。 
各位請先參考筆者從網路上整理出，有關伺服器與工作站需求的資訊。當然，伺服器或桌面的需求絕對不只這些，這裡僅列出跟設計 CFLAGS 比較有關的項目。
以下是整理出的列表： 
1. 伺服器系統： 
* 長時間啟動 (一天 24 小時，一年 365 天，全年無休) 
* 非常穩定 (uptime 在 99.999% [注] 以上) 
* 高安全性 (別懷疑，CFLAGS 跟安全性也有很大的關係) 
* 在長時間啟動的前提下，能自己照顧自己。 
* 效能不是第一考慮 
* 互動反應不用很快，夠用就好。 
2. 桌面、工作站： 
* 啟動時間沒有那麼長 (使用者要用的時候才開機) 
* 可以不用那麼穩定 (多半有使用者直接在處理，uptime 可以降到 99.99% 或更低) 
* 效能也是考慮重點 
* 互動反應快 (如加載一頁網頁，與其讓他在三秒時整面顯示出來，不如讓它每秒顯示一點可是在四秒時才全部顯示完畢。) 
所以，得到了桌面系統的 CFLAGS 設計要點： 
1. 程式啟動時間短 
2. 反應速度快 
3. 效能高 
4. 穩定可以稍差 (容許範圍內) 
減少執行檔的大小，可以同時減少了記憶體用量，也節省了一些磁碟空間。同時，桌面系統最大的效能瓶頸就在磁碟機，減少檔案大小也間接降低了磁碟的存取次數，可以加
速程式的啟動，提升第一次執行的反應速度。 
[編輯] 
CFLAGS 選項 
再來，讓我們看看 gcc 中關鍵的幾個選項。這裡只簡單介紹這些選項的功能，若要詳細說明請參考 man gcc。 
增加選項的數量，同時也增加編譯的時間。所有的選項都會增加編譯時間，有特別說明 "會增加編譯時間" 的選項，表示會增加 "大量的" 編譯時間 (跟其它選項比起來...)。 
[編輯] 
比較安全的選項 
首先是安全的選項： 
* 指令 
o 參數與用法 [注二] 
o 說明 
o 建議 
* -O 
o -O (-O1), -O0, -O2, -O3, -Os 
o 依照後面數字的大小，針對效能最佳化的程度也不同 (穩定度也可能遞減)。其中 -Os 是個比較特殊的等級，針對原始碼大小最佳化。 
o 可使用 -Os，降低程式加載的時間。 
* -fforce-mem 
-fforce-addr 
  o -fforce-mem, -fno-force-mem 
-fforce-addr, -fno-force-addr 
  o 強制在運算前將記憶體中的數值 (mem) 或記憶體位置 (addr) 複製到緩存器中。啟動這兩個選項可以做出較好的程式代碼。
  o 這兩個是好東西，啟動它們！其中 -fforce-mem 已在 -O2, -O3, -Os 中啟動，所以若您有用這三個選項的其中一個，只要 -fforce-addr 就夠了。 
* -fomit-frame-pointer 
  o -fomit-frame-pointer, -fno-omit-frame-pointer
  o 若非必要，不將函式的 frame pointer 放進緩存器中。這將避免您的程式儲存、設定、以及還原 framepointer；也在許多函式中省下一個緩存器。這個選項可能讓某些平台上的除錯工作變成不可能！。若平台支援不使用 frame pointer除錯，這個選項將在 -O, -O2, -O3, -Os 中啟動。
  o 很抱歉，x86 剛好是非這個不可才能除錯的平台之一。但是... 您想對您的桌面進行除錯嗎？若答案為非，您可以放心啟動這個選項。
* -finline-functions 
  o -finline-functions, -fno-inline-functions
  o 將所有簡單的函式整合進呼叫他們的函式中。編譯器會自動試探並決定那些函式值得被整合。於 -O3 時啟動。
  o 雖然這個選項會增加程式大小，但是他卻是個增進效能的好東西。我建議您在這裡啟動它，然後使用下面一個指令指定 inline 條件。
* -finline-limit 
  o -finline-limit=n
  o n 為決定函式是否能被 inline 的偽指令長度。預設的值為 600。
  o 這個數值越小，程式啟動的速度越快，但是運算的速度越慢。作為桌面使用，我建議 -finline-limit=400。
* -fmove-all-movables 
-freduce-all-givs 
  o -fmove-all-movables, -fno-move-all-moveables 
  -freduce-all-givs, -fno-redduse-all-givs 
  o 這兩個是循環最佳化技術，將無關循環內容的運算改在循環外執行。編譯出的執行檔可能更快也可能更慢，結果跟程式的寫法有很大的關係。 
  o 雖然說效能跟程式寫法有關，但是大部份的狀況下這兩個選項會做出比較小與比較快的程式代碼，所以我建議您啟動他們！ 
* -freorder-blocks 
  -freorder-functions 
  o -freorder-blocks, -fno-reorder-blocks 
  -freorder-functions, -fno-reorder-functions 
  o 藉由重新編排程式區塊來增進效能以及減少執行檔大小。


/******************************************************************************/
GCC CFLAGS 參數說明
/******************************************************************************/
參數與用法 [注二] 
-O 
-O0, -O(-O1),-O2, -O3, -Os 
依照後面數字的大小，針對效能最佳化的程度也不同 (穩定度也可能遞減)。其中 -Os 是個比較特殊的等級，針對原始碼大小最佳化。 可使用 -Os，降低程式加載的時間。

-fforce-mem, -fno-force-mem 
-fforce-addr, -fno-force-addr 
強制在運算前將記憶體中的數值 (mem) 或記憶體位置 (addr) 複製到緩存器中。啟動這兩個選項可以做出較好的程式代碼。 
這兩個是好東西，啟動它們！其中 -fforce-mem 已在 -O2, -O3, -Os 中啟動，所以若您有用這三個選項的其中一個，只要 -fforce-addr 就夠了。

-fomit-frame-pointer 
-fomit-frame-pointer, -fno-omit-frame-pointer 
若非必要，不將函式的 frame pointer 放進緩存器中。這將避免您的程式儲存、設定、以及還原 frame pointer；也在許多函式中省下一個緩存器。
這個選項可能讓某些平台上的除錯工作變成不可能！。若平台支援不使用 frame pointer 除錯，這個選項將在 -O, -O2, -O3, -Os 中啟動。

-finline-functions, -fno-inline-functions 
將所有簡單的函式整合進呼叫他們的函式中。編譯器會自動試探並決定那些函式值得被整合。於 -O3 時啟動。 雖然這個選項會增加程式大小，但是他卻是個增進效能的好東西。我建議您在這裡啟動它，然後使用下面一個指令指定 inline 條件。

-finline-limit=n 
n 為決定函式是否能被 inline 的偽指令長度。預設的值為 600。 
這個數值越小，程式啟動的速度越快，但是運算的速度越慢。作為桌面使用，我建議 -finline-limit=400。

-fmove-all-movables, -fno-move-all-moveables 
-freduce-all-givs, -fno-redduse-all-givs 
這兩個是循環最佳化技術，將無關循環內容的運算改在循環外執行。編譯出的執行檔可能更快也可能更慢，結果跟程式的寫法有很大的關係。 
雖然說效能跟程式寫法有關，但是大部份的狀況下這兩個選項會做出比較小與比較快的程式代碼，所以我建議您啟動他們！ 

-freorder-blocks, -fno-reorder-blocks 
-freorder-functions, -fno-reorder-functions 
藉由重新編排程式區塊來增進效能以及減少執行檔大小。 
這兩個也是好東西，所以我建議您啟動它們。缺點是會讓編譯時間變長。


-fexpensive-optimizations, -fno-expensive-optimizations 
執行幾個會加長編譯時間的非主要最佳化程式。於 -O2, -O3, -Os 中預設開啟。 
雖然會增加編譯時間，但是能增加效能也能減少執行檔大小，所以建議啟用。

-falign-functions, -falign-functions=n 
-falign-labels,      -falign-labels=n 
-falign-loops,      -falign-loops=n 
-falign-jumps,     -falign-jumps=n 
依照大於 n 的最小 2 的次方位元組對齊函式 (functions)、標籤 (labels)、循環 (loops)、跳躍 (jumps) 的起頭，跳過至多 n 位元組。 
我知道這很抽像，解釋起來要花很多篇幅，所以請各位使用預設值，亦即指定 -falign-functions, -falign-labels, -falign-loops, -falign-jumps，但是不指定 =n

-frename-registers, -fno-rename-registers 
在作過緩存器定位之後，使用剩下來的緩存器。這個最佳化在有很多緩存器的 CPU 上最明顯 (如 ARM、PowerPC... 等。x86 不屬於他們的一份子)。會增加除錯的困難度。

-fweb, -fno-web 
建立經常使用的緩存器網路。提供更佳的緩存器使用率。不過也會增加除錯的困難度。 
這個是安全選項中比較偏向實驗性質的選項，雖然建議您啟動，但是若啟動之後程式不穩，請將它關閉。 於 -O3 時啟動。

平台相關選項
-march=cpu-type 
-mtune=cpu-type 
依照不同的目標處理器進行最佳化。注意，若您指定了 -march，製作出的執行檔將無法在其它 CPU 上使用。但是若光指定 -mtune，gcc 會避免使用平台專有指令集跟專用排程選項。可用的選項有：...

建議的 CFLAGS 
根據不同的用途，每個系統的 CFLAGS 也不盡相同。以下列出建議的 CFLAGS。其中請將 <cpu-type> 換成您的 CPU，以及根據系統支援程度啟動 [] 裡面的選項： 
* 最安全、什麼都沒有的 CFLAGS。在您回報執行階段的錯誤 (sig 11、當機、運算錯誤) 之前，請先使用此 CFLAGS 編譯一次，若還是發生同樣的錯誤，才向 Gentoo Bugzilla (http://bugs.gentoo.org/) 回報： 
-march=i686 -mtune=i686 -O2 -pipe 

* 稍微比較快的 CFLAGS (建議那些以穩定為訴求的使用者使用)： 
-march=<cpu-type> -mtune=<cpu-type> -O2 -pipe -fomit-frame-pointer 

* 注重執行時期效能使用的 CFLAGS (建議需要快速運算的軟體使用)： 
-march=<cpu-type> -mtune=<cpu-type> -mfpmath=sse,387 [-mmmx -msse -msse2 -msse3 -m3dnow] -minline-all-stringops -pipe -O3 -fomit-frame-pointer -fforce-addr -finline-functions -finline-limit=800 -fmove-all-movables -freduce-all-givs -freorder-blocks -freorder-functions -fexpensive-optimizations -falign-functions -falign-labels -falign-loops -falign-jumps -frename-registers -fweb -funit-at-a-time -funroll-loops -fprefetch-loop-arrays -ffunction-sections -fdata-sections -fbranch-target-load-optimize -fbranch-target-load-optimize2 

* 注重檔案大小與加載速度的 CFLAGS (建議需要常常被啟動的程式使用)： 
-march=<cpu-type> -mtune=<cpu-type> -mfpmath=sse,387 [-mmmx -msse -msse2 -msse3 -m3dnow] -maccumulate-outgoing-args -malign-stringops -pipe -Os -fomit-frame-pointer -fforce-addr -finline-functions -finline-limit=400 -fmove-all-movables -freduce-all-givs -freorder-blocks -freorder-functions -fexpensive-optimizations -frename-registers -fweb -funit-at-a-time -fbranch-target-load-optimize -fbranch-target-load-optimize2 

* 折衷 CFLAGS (從加載速度跟執行效能折衷出來的 CFLAGS，大部份的人可能會想用這個)： 
-march=<cpu-type> -mtune=<cpu-type> -mfpmath=sse,387 [-mmmx -msse -msse2 -msse3 -m3dnow] -pipe -Os -fomit-frame-pointer -fforce-addr -finline-functions -finline-limit=400 -fmove-all-movables -freduce-all-givs -freorder-blocks -freorder-functions -fexpensive-optimizations -falign-functions -falign-labels -falign-loops -falign-jumps -frename-registers -fweb -funit-at-a-time -fbranch-target-load-optimize -fbranch-target-load-optimize2 
請注意，這裡列出的 CFLAGS 並不是最好的，也永遠不會有最好的 CFLAGS。瞭解每個選項的用意與意義，組合最適合您的 CFLAGS 才是本章的要點，提供的 CFLAGS 只是作為參考用的。


/******************************************************************************/
makefile與configure（轉）       from: http://hi.baidu.com/20065562/blog/item/c35c9d020be70b81d53f7c2a.html
/******************************************************************************/
前言
從源代碼安裝過軟體的朋友一定對 ./configure && make && make install 安裝三步曲非常熟悉了。然而究竟這個過程中的每一步幕後都發生了些什麼呢？
本文將帶領你一探究竟。深入理解這個過程將有助於你在LFS的基礎上玩出自己的花樣來。
不過需要說明的是本文對 Makefile 和 make 的講解是相當近視和粗淺的，但是對於理解安裝過程來說足夠了。

概述
用一句話來解釋這個過程就是：
　　根據源碼包中 Makefile.in 文件的指示，configure 腳本檢查當前的系統環境和配置選項，在當前目錄中生成 Makefile 文件(還有其它本文無需關心的文件)，
    然後 make 程式就按照當前目錄中的 Makefile 文件的指示將源代碼編譯為二進位文件，最後將這些二進位文件移動(即安裝)到指定的地方
    (仍然按照 Makefile 文件的指示)。
　　由此可見 Makefile 文件是幕後的核心。要深入理解安裝過程，必須首先對 Makefile 文件有充分的瞭解。
    本文將首先講述 Makefile 與 make ，然後再講述 configure 腳本。並且在講述這兩部分內容時，提供了盡可能詳細的、可以運用於實踐的參考資料。
Makefile 與 make
用一句話來概括Makefile 與 make 的關係就是：
Makefile 包含了所有的規則和目標，而 make 則是為了完成目標而去解釋 Makefile 規則的工具。
make 語法
首先看看 make 的命令行語法：
make [options] [targets] [VAR=VALUE]...
  [options]是命令行選項，可以用 make --help 命令查看全部，[VAR=VALUE]是在命令行上指定環境變數，這兩個大家都很熟悉，將在稍後詳細講解。
  [targets]是什麼呢？字面的意思是" 目標"，也就是希望本次 make 命令所完成的任務。
           憑經驗猜測，這個[targets]大概可以用"ckeck","install"之類(也就是常見的測試和安裝命令)。
           但是它到底是 個啥玩意兒？不帶任何"目標"的 make 命令是什麼意思？為什麼在安裝 LFS 工具鏈中的 Perl-5.8.8 套裝軟體時會出現"make perl utilities"這
           樣怪異的命令？要回答這些問題必須首先理解 Makefile 文件中的"規則"。

Makefile 規則
Makefile 規則包含了文件之間的依賴關係和更新此規則目標所需要的命令。
一個簡單的 Makefile 規則是這樣寫的：
TARGET : PREREQUISITES
COMMAND
TARGET
規則的目標。也就是可以被 make 使用的"目標"。有些目標可以沒有依賴而只有動作(命令行)，比如"clean"，通常僅僅定義一系列刪除中間文件的命令。
同樣，有些目標可以沒有動作而只有依賴，比如"all"，通常僅僅用作"終極目標"。
PREREQUISITES
規則的依賴。通常一個目標依賴於一個或者多個文件。
COMMAND
規則的命令行。一個規則可以有零個或多個命令行。
OK! 現在你明白[targets]是什麼了，原來它們來自於 Makefile 文件中一條條規則的目標(TARGET)。另外，Makefile文件中第一條規則的目標被稱為"終極目標"，也就是你省
略[targets]參數時的目標(通常為"all")。
當你查看一個實際的 Makefile 文件時，你會發現有些規則非常複雜，但是它都符合規則的基本格式。此外，Makefile 文件中通常還包含了除規則以外的其它很多東西，不過
本文只關心其中的變數。
Makefile 變數
Makefile 中的"變數"更像是 C 語言中的宏，代表一個文本字串(變數的值)，可以用於規則的任何部分。變數的定義很簡單：VAR=VALUE；變數的引用也很簡單：$(VAR) 
或者 ${VAR}。變數引用的展開過程是嚴格的文本替換過程，就是說變數值的字串被精確的展開在變數被引用的地方。
比如，若定義：VAR=c，那麼，"$ (VAR) $(VAR)-$(VAR) VAR.$(VAR)"將被展開為"c c-c VAR.c"。
雖然在 Makefile 中可以直接使用系統的環境變數，但是也可以通過在 Makefile 中定義同名變數來"遮蓋"系統的環境變數。另一方面，我們可以在調用 make 時使用 -e 參
數強制使系統中的環境變數覆蓋 Makefile 中的同名變數，除此之外，在調用 make 的命令行上使用 VAR=VALUE 格式指定的環境變數也可以覆蓋 Makefile 中的同名變數。

Makefile 實例
下面看一個簡單的、實際的Makefile文件：
CC=gcc
CPPFLAGS=
CFLAGS=-O2 -pipe
LDFLAGS=-s
PREFIX=/usr
all : prog1 prog2
prog1 : prog1.o
$(CC) $(LDFLAGS) -o prog1 prog1.o
prog1.o : prog1.c
$(CC) -c $(CFLAGS) prog1.c
prog2 : prog2.o
$(CC) $(CFLAGS) $(LDFLAGS) -o prog2 prog2.o
prog2.o : prog2.c
$(CC) -c $(CPPFLAGS) $(CFLAGS) prog2.c
clean :
rm -f *.{o,a} prog{1,2}
install : prog1 prog2
if ( test ! -d $(PREFIX)/bin ) ; then mkdir -p $(PREFIX)/bin ; fi
cp -f prog1 $(PREFIX)/bin/prog1
cp -f prog2 $(PREFIX)/bin/prog2
check test : prog1 prog2
prog1 < sample1.ref > sample1.rz
prog1 < sample2.ref > sample3.rz
cmp sample1.ok sample1.rz
cmp sample2.ok sample2.rz
從中可以看出，make 與 make all 以及 make prog1 prog2 三條命令其實是等價的。而常用的 make check 和 make install 也找到了歸屬。
同時我們也看到了 Makefile 中的各種變數是如何影響編譯的。針對這個特定的 Makefile ，你甚至可以省略安裝三步曲中的 make 命令而直接使用 make install 進行安裝。
同樣，為了使用自定義的編譯參數編譯 prog2 ，我們可以使用 make prog2 CFLAGS="-O3 -march=athlon64" 或 CFLAGS="-O3 -march=athlon64" && make -e prog2 命令達到
此目的。

Makefile 慣例
下面是Makefile中一些約定俗成的目標名稱及其含義：
all
編譯整個套裝軟體，但不重建任何文檔。一般此目標作為默認的終極目標。此目標一般對所有源程式的編譯和連接使用"-g"選項，以使最終的可執行程式中包含調試資訊。可使用 strip 程式去掉這些調試符號。
clean
清除當前目錄下在 make 過程中產生的文件。它不能刪除套裝軟體的配置文件，也不能刪除 build 時創建的那些文件。
distclean
類似於"clean"，但增加刪除當前目錄下的的配置文件、build 過程產生的文件。
info
產生必要的 Info 文檔。
check 或 test
完成所有的自檢功能。在執行檢查之前，應確保所有程式已經被創建(但可以尚未安裝)。為了進行測試，需要實現在程式沒有安裝的情況下被執行的測試命令。
install
完成程式的編譯並將最終的可執行程式、庫文件等拷貝到指定的目錄。此種安裝一般不對可執行程式進行 strip 操作。
install-strip
和"install"類似，但是會對複製到安裝目錄下的可執行文件進行 strip 操作。
uninstall
刪除所有由"install"安裝的文件。
installcheck
執行安裝檢查。在執行安裝檢查之前，需要確保所有程式已經被創建並且被安裝。
installdirs
創建安裝目錄及其子目錄。它不能更改軟體的編譯目錄，而僅僅是創建程式的安裝目錄
下面是 Makefile 中一些約定俗成的變數名稱及其含義：
這些約定俗成的變數分為三類。第一類代表可執行程式的名字，例如 CC 代表編譯器這個可執行程式；第二類代表程式使用的參數(多個參數使用空格分開)，例如 CFLAGS 代表編譯器執行時使用的參數(一種怪異的做法是直接在 CC 中包含參數)；第三類代表安裝目錄，例如 prefix 等等，含義簡單，下面只列出它們的預設值。 
AR 函數庫打包程式，可創建靜態庫.a文檔。默認是"ar"。
AS 彙編程式。默認是"as"。
CC C編譯程式。默認是"cc"。
CXX C++編譯程式。默認是"g++"。
CPP C/C++預處理器。默認是"$(CC) -E"。
FC Fortran編譯器。默認是"f77"。
PC Pascal語言編譯器。默認是"pc"。
YACC Yacc文法分析器。默認是"yacc"。
ARFLAGS 函數庫打包程式的命令行參數。預設值是"rv"。
ASFLAGS 彙編程式的命令行參數。
CFLAGS C編譯程式的命令行參數。
CXXFLAGS C++編譯程式的命令行參數。
CPPFLAGS C/C++預處理器的命令行參數。
FFLAGS Fortran編譯器的命令行參數。
PFLAGS Pascal編譯器的命令行參數。
YFLAGS Yacc文法分析器的命令行參數。
LDFLAGS 鏈接器的命令行參數。
prefix /usr/local
exec_prefix $(prefix)
bindir $(exec_prefix)/bin
sbindir $(exec_prefix)/sbin
libexecdir $(exec_prefix)/libexec
datadir $(prefix)/share
sysconfdir $(prefix)/etc
sharedstatedir $(prefix)/com
localstatedir $(prefix)/var
libdir $(exec_prefix)/lib
infodir $(prefix)/info
includedir $(prefix)/include
oldincludedir $(prefix)/include
mandir $(prefix)/man
srcdir 需要編譯的源文件所在的目錄，無預設值

make 選項
最後說說 make 的命令行選項(以Make-3.81版本為準)：
-B, --always-make
無條件的重建所有規則的目標，而不是根據規則的依賴關係決定是否重建某些目標文件。
-C DIR, --directory=DIR
在做任何動作之前先切換工作目錄到 DIR ，然後再執行 make 程式。
-d
在 make 執行過程中列印出所有的調試資訊。包括：make 認為那些文件需要重建；那些文件需要比較它們的最後修改時間、比較的結果；重建目標所要執行的命令；使用的隱含規則等。使用該選項我們可以看到 make 構造依賴關係鏈、重建目標過程的所有資訊，它等效於"-debug=a"。
--debug=FLAGS
在 make 執行過程中列印出調試資訊。FLAGS 用於控制調試資訊級別：
a
輸出所有類型的調試資訊
b
輸出基本調試資訊。包括：那些目標過期、是否重建成功過期目標文件。
v
除 b 級別以外還包括：解析的 makefile 文件名，不需要重建文件等。
i
除 b 級別以外還包括：所有使用到的隱含規則描述。
j
輸出所有執行命令的子進程，包括命令執行的 PID 等。
m
輸出 make 讀取、更新、執行 makefile 的資訊。
-e, --environment-overrides
使用系統環境變數的定義覆蓋 Makefile 中的同名變數定義。
-f FILE, --file=FILE, --makefile=FILE
將 FILE 指定為 Makefile 文件。
-h, --help
列印幫助資訊。
-i, --ignore-errors
忽略規則命令執行過程中的錯誤。
-I DIR, --include-dir=DIR
指定包含 Makefile 文件的搜索目錄。使用多個"-I"指定目錄時，搜索目錄按照指定順序進行。
-j [N], --jobs[=N]
指定並行執行的命令數目。在沒有指定"-j"參數的情況下，執行的命令數目將是系統允許的最大可能數目。
-k, --keep-going
遇見命令執行錯誤時不終止 make 的執行，也就是盡可能執行所有的命令，直到出現致命錯誤才終止。
-l [N], --load-average[=N], --max-load[=N]
如果系統負荷超過 LOAD(浮點數)，不再啟動新任務。
-L, --check-symlink-times
同時考察符號連接的時間戳和它所指向的目標文件的時間戳，以兩者中較晚的時間戳為準。
-n, --just-print, --dry-run, --recon
只列印出所要執行的命令，但並不實際執行命令。
-o FILE, --old-file=FILE, --assume-old=FILE
即使相對於它的依賴已經過期也不重建 FILE 文件；同時也不重建依賴於此文件任何文件。
-p, --print-data-base 
命令執行之前，列印出 make 讀取的 Makefile 的所有數據（包括規則和變數的值），同時列印出 make 的版本資訊。如果只需要列印這些數據資訊，可以使用 make -qp 命令。查看 make 執行前的預設規則和變數，可使用命令 make –p -f /dev/null 。
-q, --question
"詢問模式"。不運行任何命令，並且無輸出，只是返回一個查詢狀態。返回狀態為 0 表示沒有目標需要重建，1 表示存在需要重建的目標，2 表示有錯誤發生。
-r, --no-builtin-rules
取消所有內嵌的隱含規則，不過你可以在 Makefile 中使用模式規則來定義規則。同時還會取消所有支援後追規則的隱含後綴列表，同樣我們也可以在 Makefile 中使用".SUFFIXES"定義我們自己的後綴規則。此選項不會取消 make 內嵌的隱含變數。
-R, --no-builtin-variables
取消 make 內嵌的隱含變數，不過我們可以在 Makefile 中明確定義某些變數。注意，此選項同時打開了"-r"選項。因為隱含規則是以內嵌的隱含變數為基礎的。
-s, --silent, --quiet
不顯示所執行的命令。
-S, --no-keep-going, --stop
取消"-k"選項。在遞歸的 make 過程中子 make 通過 MAKEFLAGS 變數繼承了上層的命令行選項。我們可以在子 make 中使用"-S"選項取消上層傳遞的"-k"選項，或者取消系統環境變數 MAKEFLAGS 中的"-k"選項。
-t, --touch
更新所有目標文件的時間戳到當前系統時間。防止 make 對所有過時目標文件的重建。
-v, --version
列印版本資訊。
-w, --print-directory
在 make 進入一個目錄之前列印工作目錄。使用"-C"選項時默認打開這個選項。
--no-print-directory
取消"-w"選項。可以是用在遞歸的 make 調用過程中，取消"-C"參數將默認打開"-w"。
-W FILE, --what-if=FILE, --new-file=FILE, --assume-new=FILE
設定 FILE 文件的時間戳為當前時間，但不改變文件實際的最後修改時間。此選項主要是為實現了對所有依賴於 FILE 文件的目標的強制重建。

configure
此階段的主要目的是生成 Makefile 文件，是最關鍵的運籌帷幄階段，基本上所有可以對安裝過程進行的個性化調整都集中在這一步。
configure 腳本能夠對 Makefile 中的哪些內容產生影響呢？基本上可以這麼說：所有內容，包括本文最關心的 Makefile 規則與 Makefile 變數。那麼又是哪些因素影響著最終生成的 Makefile 文件呢？答曰：系統環境和配置選項。
配置選項的影響是顯而易見的。但是"系統環境"的概念卻很寬泛，包含很多方面內容，不過我們這裡只關心環境變數，具體說來就是將來會在 Makefile 中使用到的環境變數以及與 Makefile 中的變數同名的環境變數。
通用 configure 語法
在進一步講述之前，先看看 configure 腳本的語法，一般有兩種：
configure [OPTIONS] [VAR=VALUE]...
configure [OPTIONS] [HOST]
不管是哪種語法，我們都可以用 configure --help 查看所有可用的[OPTIONS]，並且通常在結尾部分還能看到這個腳本所關心的環境變數有哪些。在本文中將對這兩種語法進行合併，使用下面這種簡化的語法：
configure [OPTIONS]
這種語法能夠被所有的 configure 腳本所識別，同時也能通過設置環境變數和使用特定的[OPTIONS]完成上述兩種語法的一切功能。
通用 configure 選項
雖然每個套裝軟體的 configure 腳本千差萬別，但是它們卻都有一些共同的選項，也基本上都遵守相同的選項語法。
腳本自身選項
--help
顯示幫助資訊。
--version
顯示版本資訊。
--cache-file=FILE
在FILE文件中緩存測試結果(默認禁用)。
--no-create
configure腳本運行結束後不輸出結果文件，常用於正式編譯前的測試。
--quiet, --silent
不顯示腳本工作期間輸出的"checking ..."消息。
目錄選項
--srcdir=DIR
源代碼文件所在目錄，默認為configure腳本所在目錄或其父目錄。
--prefix=PREFIX
體系無關文件的頂級安裝目錄PREFIX ，預設值一般是 /usr/local 或 /usr/local/pkgName
--exec-prefix=EPREFIX
體系相關文件的頂級安裝目錄EPREFIX ，預設值一般是 PREFIX
--bindir=DIR
用戶可執行文件的存放目錄DIR ，預設值一般是 EPREFIX/bin
--sbindir=DIR
系統管理員可執行目錄DIR ，預設值一般是 EPREFIX/sbin
--libexecdir=DIR
程式可執行目錄DIR ，預設值一般是 EPREFIX/libexec
--datadir=DIR
通用數據文件的安裝目錄DIR ，預設值一般是 PREFIX/share
--sysconfdir=DIR
只讀的單一機器數據目錄DIR ，預設值一般是 PREFIX/etc
--sharedstatedir=DIR
可寫的體系無關數據目錄DIR ，預設值一般是 PREFIX/com
--localstatedir=DIR
可寫的單一機器數據目錄DIR ，預設值一般是 PREFIX/var
--libdir=DIR
庫文件的安裝目錄DIR ，預設值一般是 EPREFIX/lib
--includedir=DIR
C頭文件目錄DIR ，預設值一般是 PREFIX/include
--oldincludedir=DIR
非gcc的C頭文件目錄DIR ，預設值一般是 /usr/include
--infodir=DIR
Info文檔的安裝目錄DIR ，預設值一般是 PREFIX/info
--mandir=DIR
Man文檔的安裝目錄DIR ，預設值一般是 PREFIX/man 
體系結構選項
玩交叉編譯的朋友對這些選項已經很熟悉了，並且對於通常的交叉編譯情況而言，HOST == BUILD != TARGET 。但是對於不使用交叉編譯的朋友也不必擔心，將它們三個都設為相同即可。
--host=HOST
運行工具鏈的機器，默認是 config.guess 腳本的輸出結果。
--build=BUILD
用來建立工具鏈的機器，預設值是 HOST
--target=TARGET
工具鏈所生成的二進位代碼最終運行的機器，預設值是 HOST
特性選項
--enable-FEATURE
啟用FEATURE特性
--disable-FEATURE
禁用FEATURE特性
--with-PACKAGE[=DIR]
啟用附加套裝軟體PACKAGE，亦可同時指定PACKAGE所在目錄DIR
--without-PACKAGE
禁用附加套裝軟體PACKAGE
通用環境變數
除了上述通用的選項外，下列環境變數影響著最終生成的 Makefile 文件：
CPP
C預處理器命令
CXXCPP
C++預處理器命令
CPPFLAGS
C/C++預處理器命令行參數
CC
C編譯器命令
CFLAGS
C編譯器命令行參數
CXX
C++編譯器命令
CXXFLAGS
C++編譯器命令行參數
LDFLAGS
連接器命令行參數
至於設置這些環境變數的方法，你可以將它們 export 為全局變數在全局範圍內使用，也可以在命令行上使用 [VAR=VALUE]... configure [OPTIONS] 的語法局部使用。此處就不詳細描述了。


/******************************************************************************/
何使用GStreamer 編寫一個簡單的MP3播放器。       出處：http://phinecos.cnblogs.com/　　　　
/******************************************************************************/
1,需要使用mad解碼插件，因此需要先安裝gstreamer0.10-plugins-ugly
2，編寫mp3播放器
下面來看看如何利用GStreamer框架提供的元件，來實現一個簡單的MP3播放器。
數據源元件負責從磁碟上讀取數據，過濾器元件負責對數據進行解碼，而接受器元件則負責將解碼後的數據寫入聲卡。
如果想要在程式中應用GStreamer提供的各種功能，首先必須在主函數中調用gst_init()來完成相應的初始化工作，以便將用戶從命令行輸入的參數傳遞給GStreamer函數庫。

一個典型的GStreamer應用程式的初始化如下所示：
#include <gst/gst.h>
int main (int argc, char *argv[])
{
  gst_init (&argc, &argv);
  /*  */
}
接下去需要創建三個元件並連接成管道，由於所有GStreamer元件都具有相同的基類GstElement，因此能夠採用如下方式進行定義：
  GstElement *pipeline, *filesrc, *decoder, *audiosink;
管道在GStreamer框架中是用來容納和管理元件的，下面的代碼將創建一條名為pipeline的新管道：
  /* 創建用來容納元件的新管道 */
  pipeline = gst_pipeline_new ("pipeline");
數據源元件負責從磁碟文件中讀取數據，它具有名為location的屬性，用來指明文件在磁碟上的位置。使用標準的GObject屬性機制可以為元件設置相應的屬性：
  /* 創建數據源元件 */
  filesrc = gst_element_factory_make ("filesrc", "disk_source");
  g_object_set (G_OBJECT (filesrc), "location", argv[1], NULL);
過濾器元件負責完成對MP3格式的數據進行解碼，最簡單的辦法是安裝mad這一插件，借助它來完成相應的解碼工作：
  /* 創建過濾器元件 */
  decoder = gst_element_factory_make ("mad", "decoder"); 
接收器元件負責將解碼後的數據利用聲卡播放出來：
  /* 創建接收器元件 */
  audiosink = gst_element_factory_make ("audiosink", "play_audio")
已經創建好的三個元件需要全部添加到管道中，並按順序連接起來：
  /* 添加元件到管道中 */
  gst_bin_add_many (GST_BIN (pipeline), filesrc, decoder, audiosink, NULL);
  /* 通過襯墊連接元件 */
  gst_element_link_many (filesrc, decoder, audiosink, NULL); 
所有準備工作都做好之後，就可以通過將管道的狀態切換到PLAYING狀態，來啟動整個管道的數據處理流程：
  /* 啟動管道 */
  gst_element_set_state (pipeline, GST_STATE_PLAYING); 
這裡加入一個消息處理函數bus_call來監視產生的消息
  /* 終止管道 */
  gst_element_set_state (pipeline, GST_STATE_NULL);
  /* 釋放資源 */
  gst_object_unref (GST_OBJECT (pipeline));
3,完整的源代碼如下所示：
#include <gst/gst.h>
#include <glib.h>
//定義消息處理函數,
static gboolean bus_call(GstBus *bus,GstMessage *msg,gpointer data)
{
    GMainLoop *loop = (GMainLoop *) data;//這個是主循環的指針，在接受EOS消息時退出循環
    switch (GST_MESSAGE_TYPE(msg))
    {
        case GST_MESSAGE_EOS:
            g_print("End of stream\n");
            g_main_loop_quit(loop);
            break;
        case GST_MESSAGE_ERROR:
        {
            gchar *debug;
            GError *error;

            gst_message_parse_error(msg,&error,&debug);
            g_free(debug);
            g_printerr("ERROR:%s\n",error->message);
            g_error_free(error);
            g_main_loop_quit(loop);
            break;
        }
        default:
             break;
    }
    return TRUE;
}

int main(int argc,char *argv[])
{
    GMainLoop *loop;
    GstElement *pipeline,*source,*decoder,*sink;//定義元件
    GstBus *bus;

    gst_init(&argc,&argv);
    loop = g_main_loop_new(NULL,FALSE);//創建主循環，在執行 g_main_loop_run後正式開始循環

    if(argc != 2)
    {
        g_printerr("Usage:%s <mp3 filename>\n",argv[0]);
        return -1;
    }
    //創建管道和元件
    pipeline = gst_pipeline_new("audio-player");
    source = gst_element_factory_make("filesrc","file-source");
    decoder = gst_element_factory_make("mad","mad-decoder");
    sink = gst_element_factory_make("autoaudiosink","audio-output");

    if(!pipeline||!source||!decoder||!sink){
        g_printerr("One element could not be created.Exiting.\n");
        return -1;
    }
    //設置 source的location 參數。即 文件地址.
    g_object_set(G_OBJECT(source),"location",argv[1],NULL);
    //得到 管道的消息總線
    bus = gst_pipeline_get_bus(GST_PIPELINE(pipeline));
   //添加消息監視器
    gst_bus_add_watch(bus,bus_call,loop);
    gst_object_unref(bus);
    //把元件添加到管道中.管道是一個特殊的元件，可以更好的讓數據流動
    gst_bin_add_many(GST_BIN(pipeline),source,decoder,sink,NULL);
   //依次連接元件
   gst_element_link_many(source,decoder,sink,NULL);
   //開始播放
    gst_element_set_state(pipeline,GST_STATE_PLAYING);
    g_print("Running\n");
    //開始循環
    g_main_loop_run(loop);
    g_print("Returned,stopping playback\n");
    gst_element_set_state(pipeline,GST_STATE_NULL);
    gst_object_unref(GST_OBJECT(pipeline));
    return 0;
}
4，編譯運行
gcc -Wall $(pkg-config --cflags --libs gstreamer-0.10) -g test2.c -o test2
./test2 /home/phinecos/test.mp3


/******************************************************************************/
建立Ad Hoc 無線連接(Windows XP) ref: http://www.microsoft.com/china/windowsxp/expertzone/columns/bowman/02april08.mspx
/******************************************************************************/
使用Windows XP中的圖形用戶界面建立一個ad hoc 802.11b無線網路只需要幾分鐘。
因為它是由無線零配置驅動的，你根本不需要一根單獨的電線或者尋找一個電源插座。
您只需將Internet連接共享添加到主機上，所有與它連接的電腦將立即實現無線上網。

我們將從一台已經通過有線Ethernet寬帶連接到Internet的獨立電腦開始。然後，我們將按照3個步驟建立ad hoc無線網路：
1. 是在主電腦上安裝802.11b無線網卡，並將其配置為一個電腦到電腦（ad hoc）的無線連接。
2. 是在第二台電腦上安裝一個無線網卡。
3. 要完成網路並提供與Internet的連接，應在主機上激活Internet連接共享（ICS）。


/******************************************************************************/
版本管理工具CVS的使用       ref: http://hi.baidu.com/zhxust/blog/item/22fdca7b4a989ef30bd18765.html
/******************************************************************************/
設置環境變數
$ su
Password:輸入root的密碼
# vi /etc/profile

加入如下程式設定:
export EDITOR=/bin/vi
export CVSROOT=/home/cvsroot

建立存儲庫目錄/home/cvsroot，設定所有人都可以使用的
權限，並結束root的身份。
# export CVSROOT=/home/cvsroot
# mkdir $CVSROOT
# chmod 777 $CVSROOT
# exit

註銷再登錄，使環境變數產生作用。執行初始化指令init,
建立存放控制數據的目錄/home/cvsroot/CVSROOT。
$ cvs init

建立存儲庫的原始版本。
$ cd /home/zh/cfile/area
$ cvs import mycvs v1_0 r1_0

工作版本的建立與操作
$ cd ..
$ cvs checkout mycvs

$ cd mycvs

刪除工作版本的文件
$ rm Makefile
$ cvs remove Makefile

加入文件到工作版本
$ cp main.cpp main1.cpp
$ cvs add main1.cpp

上傳工作版本到存儲庫
$ cvs commit

由存儲庫更新工作版本
$ rm main.cpp
$ vi main1.cpp
$ cvs update

$ cvs update -C

資訊的查詢
$ cvs status main.cpp
$ cvs log main.cpp

清除工作版本與目錄
$ cvs release
$ cd ..
$ rm -r -f mycvs

清除存儲庫
$ su
Password:輸入root的密碼
# vi /etc/profile

刪除
export EDITOR=/bin/vi
export CVSROOT=/home/cvsroot

最後刪除存儲庫
# rm -r -f /home/cvsroot
# exit


/******************************************************************************/
Router ; Switch ; HUB 差異
/******************************************************************************/
Router：
中譯：路由器
功能：交換不同網段的封包、決定封包的傳送方向及路徑
作用層：TCP/IP的第三層及第四層(IP和TCP/UDP Port)
補充：市面上所售的IP分享器，也有人稱做ROUTER
不過功能上面就差很多了....

Switch：
中譯：交換器 或是 橋接器(Bridge)
功能：傳送封包，連接PC
作用層：TCP/IP的第二層(MAC)
補充：市面上有所謂的無網管功能及有網管功能的交換器
無網管功能的交換器有的地方會叫做Switch HUB
跟一般的交換器少了網路管理、VLAN、STP及Multicast管理的功能

HUB：
中譯：集線器
功能：連接多台PC
作用層：TCP/IP的第一層

Layer3 Switch(MultiLayer3 Switch)
中譯：第三層交換器 或是 多層交換器
功能：同Switch，不過多了 Routing(路由) 的功能
作用層：TCP/IP的第二層及第三、四層(MAC、IP及TCP/UDP Port)
補充：雖然Layer3 Switch也跟Router一樣有路由的功能
不過，仍然無法當作Router
因為現在的Layer3 Switch仍然無法做NAT(網路位置轉譯)功能
除非你要用像是Cisco 65XX等級的Layer3 Switch

TIP: 現在需要一個設備來連接ADSL、專線或是FTTx  =====>那所需要的是Router 或是 IP 分享器
     如果是要擴充連接的電腦                    =====>那需要的是Switch and HUB 

路由器ROUTER
又稱GATEWAY ；它雖然常常帶有HUB的功能，但是他絕對不只是HUB
hub本身是透明的，它沒有IP ; hub本身是不處理資料的，除非是高級的switch hub，否則一般的HUB甚至根本不是數位產品。它只是個訊號交換\緩衝放大器。
但路由器最少會有兩組IP，分別在不同的網域中。router一定要處理數位資料流，它讓內網的封包出去，外網的封包進來。它是就是這兩個網域之間的橋樑。
為什麼需要router？全部連在一起就好了嘛！這麼做的話事情就大條了。全世界的4千萬台電腦的資料全部擠在一起，共享100MB的網路，不用玩了。
Router把內網的資料流與外網的資料流隔開，只有跨網域的資料才穿過router交換。
Internet這個術語就是「網網相連」的意思；如果沒有router，就沒有Internet的概念了。
比較好的名稱是路徑選擇器
它主要的功能就是在不同的網路間選擇一條最佳的路徑,都用在比較大型的區域網路架構下,像學校或是企業,而且通常每個單位都會有一台做為自己區域網路對外的連接,像企
業裡的A部門會有一台ROUTER,B部門會有一台ROUTER,而各自的ROUTER下再接數10~百台以上的電腦，而今天有A部門的某台電腦要找G部門某台電腦裡的資料,則找到一條路徑是
從RA(ROUTER A)->RC->RF->RG,但這條路徑不一定是最佳的,可能只要RA->RD->RG,則路由器就會自己做修正,這樣 就可以減少不必要的路徑了,速度也變快了,要有這些功能其實
就不是那麼簡單的事了,要有資料庫要有測試的功能,因此路由器已經可以說是一台特殊的電腦 囉!~價格通常都在20萬上下囉!而路由器的設定也是一門技術喔!

Router既然都已經經手處理資料流了,那就可以把很多功能都包含進來：
(1)Firewall     : 我可以決定什麼資料可以進來，什麼資料可以出去
(2)QoS          : 我可以決定誰的資料先走，誰可以使用比較大的頻寬等等..
(3)負載平衡     : 我可以使用兩條對外的線路，讓資料平均的在兩個線路上傳輸。一條線路發生故障時，所有的資料流自動移轉到另一條線路上。
(4)NAT 網址轉換 : 就是人稱的ip分享器，我可以在內網使用虛擬的IP，這樣可以解決ip不夠的問題，也同時把內網與外網徹底的隔開了。
(5)Voip         : 網路電話的應用
(6)... 太多了，想得到的都有人做。
IP分享器是BASE ON router的,也常帶有簡單的firewall功能，高級的機器會有頻寬管理，做到負載平衡就很少見了。

SWITCH 
就是「交換機」，這個詞眼暗示了「不是共享頻寬，而是直接對接的」，就像我們打電話是透過交換機對接一樣，數十萬人同時在打電話，但是彼此不會干擾，這樣可以讓不
同的兩組電腦之間擁有完整的頻寬可以使用。
HUB 可以做成 SWITCH HUB 
ROUTER 也可以有SWITCH 的能力
SWITCH的話,是屬於第二層交換器(ROUTER是第一層),他又稱為交換式集線器,跟普通HUB不同的事,他不僅僅只有集線器的功能,他還有橋接器的功能,他能記憶哪個位址在哪個
PORT,再決定將封包送往何處因為未受影響的PORT就可以繼續對其他PORT傳送資料,突破了集線器只能有一對PORT在工作的限制,因此對一台高階的N PORT 100Mbps交換器而言,
假如每一個PORT都能以全雙工模式互傳資料的話,那麼理論上最大的傳輸頻寬為100 x N Mbps,而SWITCH的價格比較便宜也比較不用麻煩的設定
IP 把它當成地址
Switch 你可以把它當成同一條路(也可以用來分割路段)
Router 就可以說是路口，就是用來告訴你往南或往北應該是左轉還是右轉或是直走....等資訊(會紀錄在Routeing Table上) 

//--------------------------
Hub（集線器）
n TCP/IP的第一層
1.連接多台PC
2.無IP
3.不處理資料
4.訊號交緩. 緩衝放大器

Repeater（中繼器）
n   TCP/IP的第一層

Bridge（橋接器）
n TCP/IP的第二層(MAC)
1.記憶、學習功能
2.根據封包位址判斷所屬區段..具過濾功能
3.減少Ethernet網路封包碰撞

Switch（交換器）
n TCP/IP的第二層(MAC)
1.多台電腦同一時間互相傳遞資料

Router（路由器）（路徑選擇器）
n TCP/IP的第三層及第四層(IP和TCP/UDP Port)
1.在不同的網路間選擇一條最佳的路徑 (可減低網路廣播風暴)
2.交換不同網段的封包、決定封包的傳送方向及路徑
3.最少兩組IP
4.處理數位資料流
5.兩個網域之間的橋樑

Gateway
n TCP/IP的全七層
1.連接兩個不同的網
1.位址格式的轉換
2.定址和選擇路徑
3.封包格式轉換
4.資料字元格式的轉換
5.網路傳輸的流量控制
6.協定轉換。


/******************************************************************************/
構建l2tpvpn方法         from: http://big5.china.com/gate/big5/kaoshi.china.com/linux/learning/685096-1.htm
/******************************************************************************/
最近幾天一直在配l2tpd，就是支援l2tp 協定的vpn，但目前國內大部分的文章都是講pptpd的配置方法的，在此我把在linux下配置l2tpd的方法介紹一下，希望對大家有用：
伺服器端：redhat 9.0 用戶端： windows 2000
l2tpd是一套為linux 開發的支援l2tp協定的自由軟體，可以到下面的網址查看詳細介紹http://www.l2tpd.org
linux端的配置過程：
1 從http://www.l2tpd.org/download.html上下載l2tpd-0.69.tar.gz套裝軟體
2 將l2tpd-0.69.tar.gz考到你所希望的安裝目錄下（我習慣安裝在/tmp/目錄下，以下我就以在/tmp/目錄下為例）
3 解壓安裝包：
tar -xvzf l2tpd-0.69.tar.gz /*此時會生成一個l2tpd-0.69文件包*/
4 編譯：
make /*當前目錄是在/tmp/ l2tpd-0.69*/
執行完此命令後，將會在在/tmp/ l2tpd-0.69下生成可執行文件l2tpd
5 創建l2tpd的配置文件
mkdir /etc/l2tp
cp /tmp/l2tpd-0.69/ l2tpd.conf.sample /etc/l2tp/l2tpd.conf
cp /tmp/l2tpd-0.69/ l2tp-secrets.sample /etc/l2tp/l2tp-secrets
cp /etc/ppp/options /etc/ppp/options.l2tp
6 各配置文件的內容舉例：
6.1 /etc/l2tp/l2tpd.conf的內容（文件中用的分號是註釋符）：
〔global〕 ； Global parameters：
port = 1701 ； * Bind to port 1701
auth file = /etc/ppp/chap-secrets ； * 用戶帳號的配置文件，在此我們利用PPP的chap認證方法
〔lns vpnserver〕 ； Our fallthrough LNS definition
exclusive = yes ； * Only permit one tunnel per host
ip range = 192.168.254.202-192.168.254.210 ； *要分配給遠端用戶的ip範圍，根據需要修改
lac = 0.0.0.0-255.255.255.255 ；可接入的lac的範圍，這樣寫表示不限制範圍
local ip = 192.168.10.1 ； * 本機的IP地址
length bit = yes ； * Use length bit in payload？
require chap = yes ； * Require CHAP auth. by peer
require authentication = yes ； * Require peer to authenticate
name = vpnserver ； *本機名
ppp debug = yes ； * Turn on PPP debugging
pppoptfile = /etc/ppp/options.l2tp ； * ppp options file
6.2 /etc/ppp/options.l2tp的內容（本文件主要是對ppp伺服器的配置，文件中的參數含義可以使用man pppd查看，這裡不作具體說明）
name JXVPN
lock
auth
debug
dump
logfile /var/log/l2tpd.log
passive
nodetach
noccp
novj
novjccomp
nopcomp
noaccomp
6.3 /etc/ppp/chap-secrets文件是用戶帳號的管理文件，可以通過它添加和管理用戶（文件中舉了兩個例子，用戶：test，密碼：123456；用戶：111，密碼：222）：
# Secrets for authentication using CHAP
# client server secret IP addresses
test * 「123456」 *
111 * 「222」 *
7 運行l2tpd
cd /tmp/l2tpd-0.69/
。/l2tpd -D /*參數D表示讓l2tpd在前臺運行，顯示整個l2tpd的運行資訊，
如果不加D，l2tpd在後臺運行；其他參數請看/tmp/l2tpd-0.69/
目錄下的README*/
windows 2000用戶端的配置：
因為前面的vpn不支援ipsec，所以此處要對windows 2000的註冊表進行修改：
在註冊表中添加一項ProhibitIpSec = 1 「開始」 -》 「運行」 -》 「regedit」 -》 新建一個「雙位元組值」，名稱為「ProhibitIpSec」，值設為1，在以下的位置「HKEY_LOCAL_MACHINE/SYSTEM /CurrentControlSet/Services/RasMan/Parameters」
好了，到此應該可以了。目前我配置的是不支援IPSec的，如果那位想配置支援IPSec的
VPN，可以到這個網站參考一下：
http://www.jacco2.dds.nl/
如果配置成功了，請把配置方法也共用出來，謝謝了^_^
補充一下，如果出現無法訪問鄰居的問題，
可能是iptables的問題，
修改一下iptables的規則就可以了
另外，在文件options.l2tp中需要添加一項
proxyarp


/******************************************************************************/
802.11 名詞與名詞縮寫表         from : http://namiliao.pixnet.net/blog/post/31040933-802.11-%E5%90%8D%E8%A9%9E%E8%88%87%E5%90%8D%E8%A9%9E%E7%B8%AE%E5%AF%AB%E8%A1%A8
/******************************************************************************/
# address pool 位址庫: MAC 就是從這裡分派出去的.
# AKM (Authentication and key management) 身份認證與金鑰管理
# AP (Access Point) 基地台 [具有無線到有線的橋接 (bridging) 功能的設備. 目前分為兩種 thin AP 和 AP controller]
# association 連線 [只 station 加入某個 802.11 網路的程式]
# backbone network 骨幹網路
# BSS (Basic service set) 基本服務組合 [由一群 station 組成, 根據架構又可分為 IBSS 和 infrastructure BSS]
# basic service area 基本服務區域 [簡單來說就是 BSS 的通訊範圍]
# Cryptographic algorithm 加密演算法
# CSMA (Carrier Sense Multiple Access) 載波偵測多重存取 [控制傳輸媒介的存取] 
# CSMA/CD (Carrier Sense Multiple Access network with Collision Detection) 載波偵測多重存取/碰撞偵測
# CTS (Clear to send) 開始傳送 [當接收端收到 RTS 時, 確認頻道是可以用的, 就會送回 CTS 告知對方, 可以開始傳送了. (需搭配 RTS 使用)]
# DCF (distributed coordination function) 分散式協調功能 [為了避免碰撞, 利用 RTS/CTS 淨空頻道. 由於這個機制是由一群分散的 station 所完成的, 所以稱之為 DCF. (可以比較 PCF)]   
# DFS (Dynamic Frequency Selection) 動態頻率選擇 [目的有2: 1) 有些雷達也是在 5GHz 運作, 為了避免雷達運作不正常, 當偵測到雷達波時, 必須要選擇其他頻率使用. 2) 有些管制當局要求"無線區域網路必須能夠均衡 (uniform) 使用 5 GHz 頻段", 以提高整體網路的傳輸效率]
# ESS (extended service set) 延伸式服務組合 [由多個 infrustructure BSS 所組合而成. 同一個 ESS 中的 AP 都會使用相同的 SSID 作為辨認. 俗稱為網路的"名稱"]
# FCS (frame check sequence) 訊框檢查序列 [採用 CRC (cyclic redundacy check) 作為技術, 確保 frame 的資料完整性. 計算範圍包涵 MAC 標頭裡的所有欄位以及訊框主體.]
# frame 訊框:
# HCF (hybrid coordination function) 混合式協調功能 [= DCF+PCF]
# IAPP (inter-access point protocol) 基地台間協定 [在 ESS 中, 如果兩個 BSS 內的 station 要互相溝通, 各個 BSS 的 AP 怎麼知道傳輸, 市面上的很多產品都是利用 IAPP 協定, 完成這個動作.]
# IBSS (Independent BSS) 獨立行基本服務組合 [有時又稱為 Ad-hoc network/ Ad- hoc BSS/ Peer-to-peer network. 由一群 station 所建構而成的網路, station 之間可以直接通訊. (V.S. Infrustructure BSS)]
# Infrustructure BSS (沒有簡稱) 中控行基本服務組合 [必須要有一台 AP, 其他 station 都必須透過 AP 才能將資料傳送到目的地. 所以傳送資料可以分成兩段, station 傳給 AP, AP 在轉送給目的地. AP 除了轉送資料之外, 還必須控管目前使用者個服務的 station. 換句話說, 所有的 station 在連線之前, 都必須先和 AP 作認證, 當 AP 確定你有權限存取網路時, station 才能經由 AP 傳送資料.]
# LAN (local area network) 區域網路
# LLC (Logical Link Control) 邏輯鏈路控制層
# MAC (media access control) 媒介存取控制 [802.11 是使用 48 位元]
# multipath fading 多重路徑衰落 [接收訊號除了原先的發送訊號之外, 還包含了從其他物體反射過來的訊號. 若直線訊號與反射訊號剛好振幅相同而相位相反, 則接收端的所收到的總和就會變為 0, 於是形成所謂的收訊死角 (dead spot). 而因此而造成的訊號衰減稱為多重路徑衰落.  因為這個現象是由 Rayleigh 最早提出的現象, 所以又稱之為 Rayleigh fading.]
# NAV (network allocation vector) 網路配置向量 [搭配 RTS/CTS, 在這個機制裡面, NAV 的功用就是讓 station 可以知道什麼時候開始, 可以再去搶頻寬.]
# OFDM (orthogonal frequency division multiplexing) 正交分頻多工 [802.11 所規範的實體層, 主要以 OFDM 作為基礎]
# Origin authenticity 來源真實性
# PCF (point coordination function) 中樞協調功能 [和 DCF 不一樣, 分配頻寬的角色並不是 station, 而是由一個中央控管的機器來完成. 所以 PCF 通常都是架在 infrastucture BSS 裡. ]
# PLCP (Physical Layer Convergence Procedure) 實體層收斂程式 [實體層的一部分, 將 MAC 訊框對應到傳輸媒介, 在傳給 PMD 傳輸出去]
# PMD (Physical Medium Dependent) 實際搭配媒介 [將 PLCP 對應好的媒介傳送出去]
# pre-RSN [無法 support 802.11i 的 device. 安全性較低 (V.S. RSNAs)]
# Relay detection 重演攻擊偵測 [丟棄太舊的 frame] 
# RF (Radio frequency) 射頻
# RSNAs (robust security network associations) 固安網路連線 [802.11i 已經規範了一組經改良的安全機制, 提供更堅固安全的網路連線. 採用 802.11i 作身份認證與私秘姓協定, 就可以稱為 RSNAs. 無法 support 802.11i 的 device 就稱為 pre-RSN.]
# RTS (Request to Send) 要求傳送 [為了防止碰撞發生, 在傳送封包之前, 先傳送此封包, 把頻寬佔據下來. (需搭配 CTS)]
# SSID (service set identifier) 服務組合識別碼 [同一個 ESS 中的 AP 都會使用相同的 SSID 作為辨認. 俗稱為網路的"名稱"]
# station 工作站 [e.g., NB]
# TPC (Transmit Power Control) 傳輸功率控制 [傳輸功率越大, 傳輸距離越長. 但在現實的 case 中, 並不是傳輸距離越長就是越好的. 他有兩個缺點: 1) 快速消耗的電力. 2) 很容易干擾到其他機器的傳輸. 但是如果傳輸距離太短, 很容易產生 holes, 造成網路不連續. 為了有效傳輸, 控制傳輸功率顯然是有必要的. ]
# vendor prefixe 廠商首碼
# WDS (wireless distribution system) 無線傳輸系統.


/******************************************************************************/
讓MSN的語音能在NAT下工作的方法 
/******************************************************************************/
前幾天, 我發表了一篇在linux firewall下使用語音交談的文章, 當時我使用的是2.2版kernel+ipchains, 怎麼試都不成功, 經過幾番研究之後才發現, 原來linux-igd要搭配
iptables的DNAT才能使用。
以下我為各位示範讓linux firewall下怎麼安裝UPnP SDK+linux-igd:
1. 到http://badboy2001.adsldns.org/~encino/download/下載 upnpsdk-1.0.4.tar.gz及linuxigd-0.92.gz
2. 用tar解開upnpsdk及linuxigd, 先安裝upnpsdk
3. 找到src/ssdp/ssdplib.c後將下這行
      SelfAddr.sin_addr.s_addr = inet_addr(SSDP_IP);
      改成
      SelfAddr.sin_addr.s_addr = htonl(INADDR_ANY);
4. make; make install
5. cd到linux-igd的目錄下, make;make install
6. 把linux-igd/etc下的東西copy到/etc/linux-igd
7. 下route add -net 239.0.0.0 netmask 255.0.0.0 int_if
   注意int_if為內部網路卡的名字(如eth1)
8. 請確定iptables放在/usr/sbin下, 若沒有的話, 自行加一個symbolic link, 例如ln -s /usr/bin/iptables /usr/sbin/iptables
9. 要啟動upnpd時, 請下/usr/bin/upnpd [ext_if] [int_if]
   ext_if為外部網路卡名字, 如ppp0, eth0等等, int_if為內部網路網路卡名字
附註: 要達成此目的, 需要多項條件一起配合
1. 目前有支援UPnP功能的作業系統, 已知有Windows ME及Windows XP, 但是98/98SE 可以利用XP光碟裡頭的ICS軟體來達成此目的, 請確定您的Windows有支援UPnP,
   而且要到控制台中加入此選項, 否則是不能使用的。
2. 新版的MSN已可支援UPnP的功能, 若不能使用的話請先download新版。
3. linux-igd其實就是模擬Windows ICS的功能, 再利用port mapping的方式提供資料轉送的服務, 因此kernel 2.4版+iptables是必要的條件, 當upnpd run起
   來之後, 就能直接在網路上的芳鄰找到linux internet gateway device, 這樣就ok了
我昨天試過已經可正常work, 效果非常的好, 以後就不用花電話費找人了。若您使用的是IP分享器, 有支援UPnP的功能的話也可仿此例讓語音work, 只是差別在不需
要像我在linux下安裝軟體。


/******************************************************************************/
簡介 pkg-config 的功能與用法
/******************************************************************************/
我們在開發 c 程式時常常會用到許多系統已安裝 library 所提供的 function，加速程式的開發。
而我們必須針對所使用到的 function 進行 prototype 宣告，因此，我們必須在程式中將含有這些 library 所提供的 function 的 prototype 宣告的 header file 加到程
式中，並且在編譯程式時加上額外的設定告訴編譯器該去系統中的何處找尋所要使用的 header file 以及所使用的 library file被安裝在何處。而這往往也是一開始讓程式
設計者最頭痛的地方。還好，在 linux 系統上有一個非常好用的工具 pkg-config 可以讓我們查詢 library 的 header file 以及 library 本身所在位置，以及在編譯程式
時該使用的編譯參數為何。

pkg-config 命令是可以用來讀取安裝在 linux 系統上的 library 相關資訊。這個程式主要讀取系統中位於 /usr/lib/pkgconfig 目錄或是環境變數 PKG_CONFIG_PATH 所設
定的路徑中的負檔名為 .pc 的檔案，這些檔案包含系統安裝的 library 的相關資訊，包括：安裝的目錄、程式編譯的參數等等。

使用方法很簡單
pkg-config --cflags library-name-with-version 就可以得到編譯程式時，pre-processing 動作必須加上的參數設定。
例如：我在自己的電腦上下pkg-config --cflags glib-2.0，其結果為-I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include。
pkg-config --libs library-name-with-version就可以得到 linking 時所必須傳給編譯器的參數。
執行 pkg-config --libs glib-2.0 得到-L/lib -lglib-2.0。
另外，我們還可以利用 pkg-config 來簡化 Makefile 的撰寫。
在Makefile中，原來寫在編譯器之後的參數，改成 pkg-config --cflags --libs library-name-with-version 即可。
例如：將Makefile中的這一行
gcc -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include -L/lib -lglib-2.0 program.c
替換成
gcc pkg-config --cflags --libs glib-2.0 program.c


/******************************************************************************/
怎麼源碼安裝 PKG_CONFIG_PATH設置        from: http://kangzai.blog.51cto.com/280080/84298
/******************************************************************************/
如何從源碼包安裝軟體？
從源碼包安裝軟體最重要的就是仔細閱讀README INSTALL等說明文件
它會告訴你怎樣才能成功安裝
通常從源碼包安裝軟體的步驟是：
tar jxvf gtk+-2.4.13.tar.bz2 解開源碼包
cd gtk+-2.4.13/ 進入源碼目錄
./configure 似乎在某些環境下./configure會造成終端退出, 而使用./configure則會正常運行,如果有這個現象，就試試 ./configure
通過configure程式猜測主機資訊，最終建立Makefile,以完成make，所以如果./configure不成功而去make的話,就會出現
"make: *** No targets specified and no makefile found. Stop."
make 當./configure成功結束後，就開始正式編譯程式了.
make install 編譯成功後使用make install安裝
make uninstall 某些軟體支援卸載，可能使用該方法卸載，如果支援的話，通常會在README中寫到(似乎比較少)

configure程式帶有很多參數，可以通過 ./configure --help 查看詳細內容,通常位於前面的是常規configure的參數說明，末尾是該程式的可用參數說明。
./configure --prefix=/usr 指定安裝目錄，通常從源碼包編譯安裝的軟體默認會放在/usr/local下
因為這是FHS(Filesystem Hierarchy Standard)的規定，不知道什麼是FHS？看看這篇文章吧：
[url]http://www.pathname.com/fhs/pub/fhs-2.3.html[/url]相信它會讓你對linux系統結構有更好的理解，很值得讀讀。

再說一下幾個關係到能否成功編譯的東東：/etc/ld.so.conf ldconfig PKG_CONFIG_PATH

首先說下/etc/ld.so.conf:
這個文件記錄了編譯時使用的動態鏈接庫的路徑。默認情況下，編譯器只會使用/lib和/usr/lib這兩個目錄下的庫文件。如果你安裝了某些庫，比如在安裝gtk+-2.4.13時它會
需要glib-2.0 >= 2.4.0,辛苦的安裝好glib後。沒有指定 --prefix=/usr 這樣glib庫就裝到了/usr/local下，而又沒有在/etc/ld.so.conf中添加/usr/local/lib這個搜索路
徑，所以編譯gtk+-2.4.13就會出錯了。對於這種情況有兩種方法解決：
一：在編譯glib-2.4.x時，指定安裝到/usr下，這樣庫文件就會放在/usr/lib中，gtk就不會找不到需要的庫文件了，對於安裝庫文件來說，這是個好辦法，這樣也不用設置
PKG_CONFIG_PATH了 (稍後說明)。
二：將/usr/local/lib加入到/etc/ld.so.conf中，這樣安裝gtk時就會去搜索/usr/local/lib,同樣可以找到需要的庫，將/usr/local/lib加入到/etc/ld.so.conf也是必須的
，這樣以後安裝東東到local下，就不會出現這樣的問題了。
將自己可能存放庫文件的路徑都加入到/etc/ld.so.conf中是明智的選擇 ^_^添加方法也極其簡單，將庫文件的絕對路徑直接寫進去就OK了，一行一個。例如：
/usr/X11R6/lib
/usr/local/lib
/opt/lib

再來看看ldconfig是個什麼東東吧 ：
它是一個程式，通常它位於/sbin下，是root用戶使用的東東。具體作用及用法可以man ldconfig查到，簡單的說，它的作用就是將/etc/ld.so.conf列出的路徑下的庫文件 緩
存到/etc/ld.so.cache 以供使用。因此當安裝完一些庫文件，(例如剛安裝好glib)，或者修改ld.so.conf增加新的庫路徑後，需要運行一下/sbin/ldconfig。使所有的庫文件
都被緩存到ld.so.cache中，如果沒做，即使庫文件明明就在/usr/lib下的，也是不會被使用的，結果編譯過程中報錯，缺少xxx庫，去查看發現明明就在那放著，搞的想大罵
computer蠢豬一個。 ^_^  我曾經編譯KDE時就犯過這個錯誤，(它需要每編譯好一個東東，都要運行一遍)，所以切記改動庫文件後一定要運行一下ldconfig，在任何目錄下運
行都可以。

再來說說 PKG_CONFIG_PATH這個變數吧:
經常在論壇上看到有人問"為什麼我已經安裝了glib-2.4.x，但是編譯gtk+-2.4.x 還是提示glib版本太低阿？為什麼我安裝了glib-2.4.x，還是提示找不到阿？。。。。。。"
都是這個變數搞的鬼。
先來看一個編譯過程中出現的錯誤 (編譯gtk+-2.4.13):
checking for pkg-config... /usr/bin/pkg-config
checking for glib-2.0 >= 2.4.0 atk >= 1.0.1 pango >= 1.4.0... Package glib-2.0 was not found in the pkg-config search path.
Perhaps you should add the directory containing `glib-2.0.pc'
to the PKG_CONFIG_PATH environment variable
No package 'glib-2.0' found
configure: error: Library requirements (glib-2.0 >= 2.4.0 atk >= 1.0.1 pango >= 1.4.0) not met; consider adjusting the PKG_CONFIG_PATH environment variable if your libraries are in a nonstandard prefix so pkg-config can find them.
[root@NEWLFS gtk+-2.4.13]#
很明顯，上面這段說明，沒有找到glib-2.4.x,並且提示應該將glib-2.0.pc加入到PKG_CONFIG_PATH下。
究竟這個pkg-config PKG_CONFIG_PATH glib-2.0.pc 是做什麼的呢？ let me tell you ^_^
先說說它是哪冒出來的，當安裝了pkgconfig-x.x.x這個包後，就多出了pkg-config，它就是需要PKG_CONFIG_PATH的東東。
pkgconfig-x.x.x又是做什麼的？ 來看一段說明：
代碼:
The pkgconfig package contains tools for passing the include path and/or library paths to build tools during the make file execution.
pkg-config is a function that returns meta information for the specified library.
The default setting for PKG_CONFIG_PATH is /usr/lib/pkgconfig because of the prefix we use to install pkgconfig. You may add to PKG_CONFIG_PATH by 
exporting additional paths on your system where pkgconfig files are installed. Note that PKG_CONFIG_PATH is only needed when compiling packages, not 
during run-time.
我想看過這段說明後，你已經大概瞭解了它是做什麼的吧。
其實pkg-config就是向configure程式提供系統資訊的程式，比如軟體的版本啦，庫的版本啦，庫的路徑啦，等等
這些資訊只是在編譯其間使用。你可以 ls /usr/lib/pkgconfig 下，會看到許多的*.pc,用文本編輯器打開
會發現類似下面的資訊：
prefix=/usr
exec_prefix=${prefix}
libdir=${exec_prefix}/lib
includedir=${prefix}/include

glib_genmarshal=glib-genmarshal
gobject_query=gobject-query
glib_mkenums=glib-mkenums

Name: GLib
Description: C Utility Library
Version: 2.4.7
Libs: -L${libdir} -lglib-2.0
Cflags: -I${includedir}/glib-2.0 -I${libdir}/glib-2.0/include
明白了吧，configure就是靠這些資訊判斷你的軟體版本是否符合要求。並且得到這些東東所在的位置，要不去哪裡找呀。
不用我說你也知道為什麼會出現上面那些問題了吧。

解決的辦法很簡單，設定正確的PKG_CONFIG_PATH，假如將glib-2.x.x裝到了/usr/local/下，那麼glib-2.0.pc就會在 /usr/local/lib/pkgconfig下，將這個路徑添加到
PKG_CONFIG_PATH下就可以啦。並且確保configure找到的是正確的glib-2.0.pc,就是將其他的lib/pkgconfig目錄glib-2.0.pc幹掉就是啦。(如果有的話 ^-^)
設定好後可以加入到~/.bashrc中，例如：
PKG_CONFIG_PATH=/opt/kde-3.3.0/lib/pkgconfig:/usr/lib/pkgconfig:/usr/local/pkgconfig:
/usr/X11R6/lib/pkgconfig
[root@NEWLFS ~]#echo $PKG_CONFIG_PATH
/opt/kde-3.3.0/lib/pkgconfig:/usr/lib/pkgconfig:/usr/local/pkgconfig:/usr/X11R6/lib/pkgconfig
從上面可以看出，安裝庫文件時，指定安裝到/usr，是很有好處的，無論是/etc/ld.so.conf還是PKG_CONFIG_PATH, 默認都會去搜索/usr/lib的，可以省下許多麻煩，不過從
源碼包管理上來說，都裝在/usr下，管理是個問題，不如裝在/usr/local下方便管理，其實只要設置好ld.so.conf，PKG_CONFIG_PATH路徑後，就OK啦 ^_^

另外某些軟體因為版本原因(比如emacs-21.3)，在gcc-3.4.x下編譯無法成功,(make 出錯)，使用低版本的gcc就可能編譯通過。
可能是因為gcc-3.3.x和gcc-3.4.x變化很大的緣故吧。
暫時想到了這麼多，先記下這些吧，如果你對源碼包編譯有了一點的瞭解，就不枉我打了這麼半天字啦。 ^_^

另外./configure 通過，make 出錯，遇到這樣的問題比較難辦，只能憑經驗查找原因，比如某個頭文件沒有找到，這時候要順著出錯的位置一行的一行往上找錯，比如顯示
xxxx.h no such file or directory 說明缺少頭文件，然後去google搜。或者找到感覺有價值的錯誤資訊，拿到google去搜，往往會找到解決的辦法。還是開始的那句話，要
仔細看README,INSTALL程式如何安裝，需要什麼依賴文件，等等。
另外對於newbie來說，編譯時，往往不知道是否成功編譯通過，而編譯沒有通過就去make install，必然會出錯，增加了解決問題的複雜性，可以通過下面方法檢查是否編譯
成功：
一：編譯完成後，輸入echo $? 如果返回結果為0,則表示正常結束，否則就出錯了
echo $? 表示 檢查上一條命令的退出狀態，程式正常退出 返回0,錯誤退出返回非0。
二：編譯時，可以用&&連接命令， && 表示"當前一條命令正常結束，後面的命令才會執行"，就是"與"啦。
這個辦法很好，即節省時間，又可防止出錯。例：
./configure --prefix=/usr && make && make install

編譯DOSBOX時出現"cdrom.h:20:23: SDL_sound.h: No such file or directory"

今天忽然想回味下經典DOS遊戲，於是編譯這個DOSBOX模擬器，README中說明需要SDL_SOUND，於是下載，安裝，很順利，沒有指定安裝路徑，於是默認的安裝到了/usr/local/
當編譯DOSBOX make 時，出現如下錯誤：
if g++ -DHAVE_CONFIG_H -I. -I. -I../.. -I../../include -I/usr/include/SDL -D_REENTRANT -march=pentium4 -O3 -pipe -fomit-frame-pointer -MT dos_programs.o -MD -MP -MF ".deps/dos_programs.Tpo" -c -o dos_programs.o dos_programs.cpp; \
then mv -f ".deps/dos_programs.Tpo" ".deps/dos_programs.Po"; else rm -f ".deps/dos_programs.Tpo"; exit 1; fi
In file included from dos_programs.cpp:30:
cdrom.h:20:23: SDL_sound.h: No such file or directory <------錯誤的原因在這裡
In file included from dos_programs.cpp:30:
cdrom.h:137: error: ISO C++ forbids declaration of `Sound_Sample' with no type
cdrom.h:137: error: expected `;' before '*' token
make[3]: *** [dos_programs.o] Error 1
make[3]: Leaving directory `/root/software/dosbox-0.63/src/dos'
make[2]: *** [all-recursive] Error 1
make[2]: Leaving directory `/root/software/dosbox-0.63/src'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/root/software/dosbox-0.63'
make: *** [all] Error 2
[root@NEWLFS dosbox-0.63]#
看來是因為cdrom.h沒有找到SDL_sound.h這個頭文件
所以出現了下面的錯誤，但是我明明已經安裝好了SDL_sound阿？
經過查找，在/usr/local/include/SDL/下找到了SDL_sound.h
看來dosbox沒有去搜尋/usr/local/include/SDL下的頭文件，既然找到了原因，就容易解決啦
[root@NEWLFS dosbox-0.63]#ln -s /usr/local/include/SDL/SDL_sound.h /usr/include
做個鏈接到/usr/include下，這樣DOSBOX就可以找到了，順利編譯成功，回味仙劍ing....^_^
曾經編譯Xorg-6.8.1的時候，也出現找不到freetype.h的問題，原因也是如此。
編譯安裝軟體時，經常遇到類似的情況，都是因為找不到需要的頭文件而出現錯誤，也許是因為沒有安裝相關的頭文件，或者是安裝了但沒有找到，如上例。
找不到的情況：做個鏈接到/usr/include下，就可以了。
沒安裝的情況：去google找什麼東東包括該頭文件，安裝上就應該可以了。
通常錯誤提示也都是"No such file or directory"，所以編譯失敗時要好好找找錯誤資訊哦。
錯誤資訊總是在Error上面不遠的，耐心點 ^_^
不修改/etc/ld.so.conf使用非默認路徑下的庫文件-----LD_LIBRARY_PATH
環境變數LD_LIBRARY_PATH列出了查找共享庫時除了默認路徑之外的其他路徑。如果不想修改或無法修改(無root權限)/etc/ld.so.conf而使用其他路徑下的庫文件。就需要設
置LD_LIBRARY_PATH了，例：export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/lib這樣就可以使用/opt/lib下的庫文件啦。當然還是修改/etc/ld.so.conf方便。


/******************************************************************************/
Gstreamer在Ubuntu上的安裝和MP3的播放
/******************************************************************************/
Gstreamer簡單介紹：
GStreamer 作為流媒體應用框架，採用了基於插件（plugin）和管道（pipeline）的體系結構，框架中的所有的功能模組都被實現成可以插拔的元件（component），並且在需
要的時候能夠很方便地安裝到任意一個管道上，由於所有插件都通過管道機制進行統一的數據，因此很容易利用已有的各種插件「組裝」出一個功能完善的多媒體應用程式。

在Ubuntu上安裝gstreamer：
在安裝之前首先要設置代理
有三個地方：
1 network proxy
2  Synaptic Package Manager裡的settings
3 在命令行裡輸入 gedit  etc/apt/apt.conf
然後在文件裡加入
Acquire::http::proxy 」http://student102:student@10.1.243.240:8080/」;這裡面的賬號和密碼老自動刪除了，如代理有問題在進來看看這

一、去http://gstreamer.freedesktop.org/下載源碼包，一般要安裝gstreamer以下最基本的包，分別下載：
Gstreamer-0.10.35.tar.bz2
gst-plugins-base-0.10.35.tar.bz2
gst-plugins-good-0.10.30.tar.bz2

二、安裝gstreamer：
解壓後，進入目錄直接執行./configure,此時出現如下錯誤：
configure: error: Could not find bison
出現這個錯誤，說明找不到bison，那麼解決方案也很簡單，安裝bison。
解決辦法：
administrator@ubuntu:~/gstreamer-0.10.35$ sudo apt-get install bison
make
make install
cd ..
再次運行./configure，出現如下錯誤：
administrator@ubuntu:~/gstreamer-0.10.35$ ./configure
….
checking for bison… /usr/bin/bison
checking bison version 2.4.1 >= 1.875… Yes
checking for flex… No
configure: error: Could not find flex
解決辦法，同上面安裝bison的過程：
administrator@ubuntu:~/下載/gstreamer-0.10.35$ sudo apt-get install flex
make
make install
cd ..
再次運行./configure，出現如下錯誤：
checking for GLIB… No
configure: No package 』glib-2.0′ found
No package 』gobject-2.0′ found
No package 』gthread-2.0′ found
No package 』gmodule-no-export-2.0′ found
configure: error: This package requires GLib >= 2.22 to compile.
解決辦法：
administrator@ubuntu:~/gstreamer-0.10.35$ sudo apt-get install glib-2.0
make
make install
cd ..
再次運行./configure，出現如下錯誤：
configure: error: *** Working zlib library and headers not found ***
解決辦法：
administrator@ubuntu:~/下載/glib-2.29.4$ sudo apt-get install zlib1g
administrator@ubuntu:~/下載/glib-2.29.4$ ./configure
checking for a BSD-compatible install… /usr/bin/install -c
…
configure: error: Package requirements (libffi >= 3.0.0) were not met:
No package 』libffi』 found
Consider adjusting the PKG_CONFIG_PATH environment variable if you
installed software in a non-standard prefix.
Alternatively, you may set the environment variables LIBFFI_CFLAGS
and LIBFFI_LIBS to avoid the need to call pkg-config.
See the pkg-config man page for more details.

安裝libffi
錯誤解決
administrator@ubuntu:~/下載/glib-2.29.4$ ./configure
…
checking for msgfmt… no
configure: error:
*** You must have either have gettext support in your C library, or use the
*** GNU gettext library. (http://www.gnu.org/software/gettext/gettext.html

安裝gettex
administrator@ubuntu:~/下載/glib-2.29.4$ sudo apt-get install gettex
administrator@ubuntu:~/下載/glib-2.29.4$  ./configure
無錯誤。
administrator@ubuntu:~/下載/glib-2.29.4$  make & sudo make install
administrator@ubuntu:~/下載/gstreamer-0.10.35$ ./configure
。。。。
checking for XML… no
no
configure: error:
Need libxml2 and development headers/files to build GStreamer.

You can do without libxml2 if you pass –disable-loadsave to
configure, but that breaks ABI, so don』t do that unless you
are building for an embedded setup and know what you are doing.

安裝libxml2
administrator@ubuntu:~/下載/gstreamer-0.10.35$ sudo apt-get install libxml2
解壓libxml2-2.7.7.tar.gz
administrator@ubuntu:~/下載/libxml2-2.7.7$ ./configure
出錯：
config.status: executing libtool commands
/bin/rm: cannot remove `libtoolT』: No such file or directory
Done configuring
administrator@ubuntu:~/下載/libxml2-2.7.7$ make & sudo make install
administrator@ubuntu:~/下載/gstreamer-0.10.35$ ./configure
安裝完成
Configuration
Version                    : 0.10.35
Source code location       : .
Prefix                     : /usr/local
Compiler                   : gcc -std=gnu99
Package name               : GStreamer source release
Package origin             : Unknown package origin
Documentation (manuals)    : no
Documentation (API)        : no
Debug Logging              : yes
Pipeline XML load/save     : yes
Command-line parser        : yes
Option parsing in gst_init : yes
Tracing subsystem          : yes
Allocation tracing         : yes
Plugin registry            : yes
Plugin support               : yes
Network support            : yes
Unit testing support       : yes
Debug                      : yes
Profiling                  : no
Building examples          : yes
Building test apps         : yes
Building tests that fail   : no
在安裝完gstreamer後，安裝其他plugins之前要設置PKG_CONFIG_PATH正確。

3.安裝gst-plugins-base：
安裝前要設置環境變數，由於gstreamer是默認安裝，沒有設置–prefix，所以將export
PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH就行了
./configure,提示缺少liboil，去https://launchpad.net/ubuntu/+source/liboil/0.3.14
也可以在 gedit /etc/profile 末尾 加上下面的語句
export PKG_CONFIG_PATH=/usr/lib/pkgconfig:/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH
export
LD_LIBRARY_PATH=/usr/lib:/usr/local/lib:$LD_LIBRARY_PATH
-3下載安裝即可
make
make install
4.安裝gst-plugins-good：
./configure
make
make install
這裡有可能 在 Synaptic Package Manager裡下載G++
到此可以用gst-launch -vm audiotestsrc ! audioconvert ! audioresample ! osssink
測試能在楊聲器裡聽到蜂鳴音
注意：總之，在安裝過程中，缺什麼就apt-get install,找不到就去網上下載安裝。
5.編寫代碼測試,最簡單的mp3播放：
a.需要使用mad解碼插件，因此首先要安裝libid3tag0-dev和libmad0-dev
apt-get install liblid3tag0-dev
apt-get install libmad0-dev
b.接著安裝gstreamer0.10-plugins-ugly才會安裝上mad
這上面三個包得按順序安裝，要不可能出問題

編寫.c
#include <gst/gst.h>
#include <gtk/gtk.h>
#define GTK_WINDOW 0
static GtkWidget *window;

static gboolean delete_event(GtkWidget *widget, GdkEvent *event, gpointer data)
{
    return FALSE;
}

static void destroy(GtkWidget *widget, gpointer data)
{
    gtk_main_quit ();
}

static void window_create(void)
{
    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
    g_signal_connect (G_OBJECT (window), 」delete_event」,
    G_CALLBACK (delete_event), NULL);
    g_signal_connect (G_OBJECT (window), 」destroy」,
    G_CALLBACK (destroy), NULL);
    gtk_widget_show (window);
}

int main(int argc, char *argv[])
{
    GstElement *pipeline, *filesrc, *decoder, *convert, *audiosink;

    #if GTK_WINDOW
    gtk_init(&argc, &argv);
    window_create();
    #endif
    gst_init(&argc, &argv);

    if (argc != 2) {
        g_print("usage: %s <mp3 filename>/n", argv[0]);
        exit (-1);
    }
    pipeline = gst_pipeline_new("pipeline");
    filesrc = gst_element_factory_make("filesrc", "disk_source");
    decoder = gst_element_factory_make("mad", "decoder");
    convert = gst_element_factory_make("audioconvert","a-convert");
    audiosink = gst_element_factory_make("osssink", "play_audio");

    g_object_set(G_OBJECT(filesrc), "location", argv[1], NULL);
    gst_bin_add_many(GST_BIN(pipeline), filesrc, decoder, convert, audiosink, NULL);
    gst_element_link_many(filesrc, decoder, convert, audiosink, NULL);

    gst_element_set_state(pipeline, GST_STATE_PLAYING);

    #if GTK_WINDOW
    gtk_main ();
    #else
    while (gst_bin_iterate_recurse(GST_BIN(pipeline)));
    #endif

    gst_element_set_state(pipeline, GST_STATE_NULL);
    gst_object_unref(GST_OBJECT (pipeline));
    exit (0);
}

編譯：
gcc -Wall $(pkg-config –cflags –libs gstreamer-0.10) hello.c -o hello
../hello 路徑/yourfilename.mp3


/******************************************************************************/
Ubuntu後就,黑畫面,無法進入桌面..
/******************************************************************************/
進去系統之後編輯/etc/default/grub
修改了GRUB_CMDLINE_LINUX_DEFAULT="quiet splash nomodeset"


/******************************************************************************/
讓Ubuntu開機進入文字模式        from : http://alvin17-orz.blogspot.com/2010/07/ubuntu.html
/******************************************************************************/
This tutorial shows how to configure your ubuntu 9.10 and make it directly boot into console/command line instead of X-window.
Step1:Just edit /etc/default/grub with your favourite editor:
    $ sudo gedit /etc/default/grub
    find out this line:
    GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
    change it to:
    GRUB_CMDLINE_LINUX_DEFAULT="quiet splash text"
Step2:
    Do Update grub and done!
    $ sudo update-grub
測試過後在Ubuntu 10.04 desktop版本可用
很適合在VMWare裡面架設Linux來compile，節省圖形介面的資源

在Ubuntu上退出GUI桌面
不過老實說桌面對於Server實在有點多餘，
因此要在Ubuntu上退出桌面的話，可以在指令模式使用以下的指令來控制，：

退出桌面： sudo /etc/init.d/gdm stop
重啟桌面： sudo /etc/init.d/gdm start

進入圖形介面出現下列視窗錯誤：
"The panel encountered a problem while loading "OAFIID:GNOME_FastUserSwitchApplet"
解決方法：
  $ sudo apt-get install indicator-applet-session

/******************************************************************************/
Linux .o a .so .la .lo的區別    from : http://www.eetop.cn/blog/html/40/202640-8862.html
/******************************************************************************/
o: 編譯的目標文件
a: 靜態庫，其實就是把若干o文件打了個包
so: 動態鏈接庫（共享庫）
lo: 使用libtool編譯出的目標文件，其實就是在o文件中添加了一些資訊
la: 使用libtool編譯出的庫文件，其實是個文本文件，記錄同名動態庫和靜態庫的相關資訊
補充：libtool

1 libtool的工作原理 
libtool 是一個通用庫支援腳本，將使用動態庫的複雜性隱藏在統一、可移植的介面中；使用libtool的標準方法，可以在不同平台上創建並調用動態庫。可以認為libtool是
gcc的一個抽像，其包裝了gcc（或者其他的編譯器），用戶無需知道細節，只要告訴libtool需要編譯哪些庫即可，libtool將處理庫的依賴等細節。libtool只與後綴名為lo
、la為的libtool文件打交道。 
libtool主要的一個作用是在編譯大型軟體的過程中解決了庫的依賴問題；將繁重的庫依賴關係的維護工作承擔下來，從而釋放了程式員的人力資源。libtool提供統一的介面
，隱藏了不同平台間庫的名稱的差異等細節，生成一個抽像的後綴名為la高層庫libxx.la（其實是個文本文件），並將該庫對其它庫的依賴關係，都寫在該la的文件中。該文
件中的dependency_libs記錄該庫依賴的所有庫（其中有些是以.la文件的形式加入的）；libdir則指出了庫的安裝位置；library_names記錄了共享庫的名字；old_library記
錄了靜態庫的名字。 
當編譯過程到link階段的時候，如果有下面的命令： 
$libtool --mode=link gcc -o myprog -rpath /usr/lib –L/usr/lib –la 
libtool會到/usr/lib路徑下去尋找liba.la，然後從中讀取實際的共享庫的名字（library_names中記錄了該名字，比如liba.so）和路徑(lib_dir中記錄了，比如
libdir="/usr/lib")，返回諸如/usr/lib/liba.so的參數給激發出的gcc命令行。 
如果liba.so依賴於庫/usr/lib/libb.so，則在liba.la中將會有dependency_libs="-L/usr/lib -lb"或者dependency_libs="/usr/lib/libb.la"的行，如果是前者，其將直接
把「-L/usr/lib –lb」當作參數傳給gcc命令行；如果是後者，libtool將從/usr/lib/libb.la中讀取實際的libb.so的庫名稱和路徑，然後組合成參數「/usr/lib/libb.so」
傳遞給gcc命令行。 

當要生成的文件是諸如libmylib.la的時候，比如： 
$libtool --mode=link gcc -o libmylib.la -rpath /usr/lib –L/usr/lib –la 
其依賴的庫的搜索基本類似，只是在這個時候會根據相應的規則生成相應的共享庫和靜態庫。 
注意：libtool在鏈接的時候只會涉及到後綴名為la的libtool文件；實際的庫文件名稱和庫安裝路徑以及依賴關係是從該文件中讀取的。 

2 為何使用 -Wl,--rpath-link -Wl,DIR？ 
使用libtool解決編譯問題看上去沒什麼問題：庫的名稱、路徑、依賴都得到了很好的解決。但下結論不要那麼著急，一個顯而易見的問題就是：並不是所有的庫都是用
libtool編譯的。 
比如上面那個例子， 
$libtool --mode=link gcc -o myprog -rpath /usr/lib –L/usr/lib –la 
如果liba.so不是使用libtool工具生成的，則libtool此時根本找不到liba.la文件（不存在該文件）。這種情況下，libtool只會把「–L/usr/lib –la」當作參數傳遞給gcc
命令行。 
考慮以下情況：要從myprog.o文件編譯生成myprog，其依賴於庫liba.so（使用libtool生成），liba.so又依賴於libb.so（libb.so的生成不使用libtool），而且由於某種原
因，a對b的依賴並沒有寫入到liba.la中，那麼如果用以下命令編譯： 
$libtool --mode=link gcc -o myprog -rpath /usr/lib –L/usr/lib –la 
激發出的gcc命令行類似於下面： 
              gcc –o myprog /usr/lib/liba.so 
由於liba.so依賴於libb.so（這種依賴可以用readelf讀liba.so的ELF文件看到），而上面的命令行中，並沒有出現libb.so，於是，可能會出現問題。 
說「可能」，是因為如果在本地編譯的情況下，gcc在命令行中找不到一個庫（比如上面的liba.so）依賴的其它庫（比如libb.so），鏈接器會按照某種策略到某些路徑下面去
尋找需要的共享庫： 
1. 所有由'-rpath-link'選項指定的搜索路徑. 
2. 所有由'-rpath'指定的搜索路徑. '-rpath'跟'-rpath_link'的不同之處在於,由'-rpath'指定的路徑被包含在可執行文件中,並在運行時使用, 而'-rpath-link'選項僅僅在
   連接時起作用. 
3. 在一個ELF系統中, 如果'-rpath'和'rpath-link'選項沒有被使用, 會搜索環境變數'LD_RUN_PATH'的內容.它也只對本地連接器起作用. 
4. 在SunOS上, '-rpath'選項不使用, 只搜索所有由'-L'指定的目錄. 
5. 對於一個本地連接器,環境變數'LD_LIBRARY_PATH'的內容被搜索. 
6. 對於一個本地ELF連接器,共享庫中的`DT_RUNPATH'和`DT_RPATH'操作符會被需要它的共享庫搜索. 如果'DT_RUNPATH'存在了, 那'DT_RPATH'就會被忽略. 
7. 缺省目錄, 常規的,如'/lib'和'/usr/lib'. 
8. 對於ELF系統上的本地連接器, 如果文件'/etc/ld.so.conf'存在, 這個文件中有的目錄會被搜索. 
從以上可以看出，在使用本地工具鏈進行本地編譯情況下，只要庫存在於某個位置，gcc總能通過如上策略找到需要的共享庫。但在交叉編譯下，上述八種策略，可以使用的僅
僅有兩個：-rpath-link，-rpath。這兩個選項在上述八種策略當中優先級最高，當指定這兩個選項時，如果鏈接需要的共享庫找不到，鏈接器會優先到這兩個選項指定的路徑
下去搜索需要的共享庫。通過上面的描述可以看到：-rpath指定的路徑將被寫到可執行文件中；-rpath-link則不會；我們當然不希望交叉編譯情況下使用的路徑資訊被寫進最
終的可執行文件，所以我們選擇使用選項-rpath-link。 

gcc的選項「-Wl,--rpath-link –Wl,DIR」會把-rpath-link選項及路徑資訊傳遞給鏈接器。回到上面那個例子，如果命令行中沒有出現libb.so，但gcc指定了
「-Wl,--rpath-link –Wl,DIR」，則鏈接器找不到libb.so的時候，會首先到後面-rpath-link指定的路徑去尋找其依賴的庫。此處我們使用的編譯命令的示例是使用unicore
平台的工具鏈。 
$ unicore32-linux-gcc –o myprog /usr/lib/liba.so \ 
-Wl,--rpath-link -Wl,/home/UNITY_float/install/usr/lib 
這樣，編譯器會首先到「/home/UNITY_float/install/usr/lib」下面去搜索libb.so 
libtool如何把選項「-Wl,--rpath-link –Wl,DIR」傳遞給gcc？libtool中有一個變數「hardcode_libdir_flag_spec」，該變數本來是傳遞「-rpath」選項的，但我們可以修
改它，添加我們需要的路徑，傳遞給unicore32-linux-gcc。 
「hardcode_libdir_flag_spec」原來的定義如下： 
hardcode_libdir_flag_spec="\${wl}--rpath \${wl}\$libdir" 
我們修改後的定義如下： 
hardcode_libdir_flag_spec="\${wl}—rpath-link \${wl}\$libdir \ 
-Wl,--rpath-link -Wl,/home/UNITY_float/install/usr/lib \ 
-Wl,--rpath-link -Wl,/home/UNITY_float/install/usr/X11R6/lib " 
這樣，當libtool在「--mode=link」的模式下，就會把選項「-Wl,--rpath-link –Wl,DIR」傳遞給gcc編譯器了。


/******************************************************************************/
// Using Automake and Autoconf  from: http://jyhshin.pixnet.net/blog/post/26588146-using-automake-and-autoconf
/******************************************************************************/
Abstract
在 Unix 底下，automake 和 autoconf 常被用來管理 C/C++ 的專案。 如果您的專案是根據 GNU 的標準建構出來的，那麼它們能夠幫您節省很多 make 以及 configure 的時
間。然而，萬事起頭難。希望這篇指南能夠為剛入門的程式設計師提供一些有用的資訊。
我不是 Unix 以及 autoconf, automake 的專家，所以我歡迎有建設性的批評與指教。
make and configure
這個 make tool 能夠用來管理多個檔案的專案。make 會用到您專案裡的 Makefile 這個檔案，這個檔案列出了各式的編譯以及連結步驟，目的，以及一些相依關係。多檔的
專案與 GNU 的 make 工具程式是有很大的關係的。
configure 這個 script 被用來協助處理跨平台的編譯工作。一個合適的 configure script 能夠正確的解譯 Makefile.in 然後產生該平台相依的 Makefile。當然。產生
 Makefile 之前必須經過很多測試來決定該平台的特性。
所以我們允許使用者執行 './configure' 然後再執行 'make' 來根據自身的平台而編譯這個專案。

aclocal.m4
很明顯的，大部分寫好的 Makefile 和 configure script 看起來都非常的類似。事實上，GNU 提供了一些關於這些檔案的細部描述。因此，GNU 寫出了 automake 以及 
autoconf 來簡化處理這些過程，並且確保 Makefile 以及 configure script 能夠遵守 GNU 標準。
這裡是這些工具的簡單的介紹。我這裡也提供了範例供您測試使用。
注意：這些工具使用 m4 程式語言。 aclocal 增加 aclocal.m4 這個檔案到您的專案目錄，因為包含了一些需要用到的 m4 巨集。

autoconf
autoconf 會尋找叫做 configure.in 這個檔案，然後會根據他找到的巨集而生出 configure script。
注意要的是 autoscan 可以用來產生一個可能使用的 configure.in。它會測試你的原始檔案，然後放進一些建議值到一個叫做 configure.scan 的檔案。當然您必須改名成 
configure.in。
不管什麼時候，您在 configure.in 加入一個巨集時，然後必須執行 aclocal 和 autoconf，因為 aclocal 會掃瞄 configure.in 然後找出它必須提供的巨集。

Lines which every configure.in should have
每一個 configure.in 應該有底下這幾行：
AC_INIT(hello.cc)
AM_INIT_AUTOMAKE(hello,0.1)
AC_PROG_CC
AC_PROG_CXX
AC_PROG_INSTALL
AC_OUTPUT(Makefile)
AC_INIT
這個巨集以一個原始檔當作參數。它會檢查該檔是否存在，也會檢查目錄是否存在。
AM_INIT_AUTOMAKE
這行增加了幾個標準的檢查。它是以程式名稱以及版本號碼當作參數。
AC_PROG_CC
指出了該原始檔是用 C 寫成的。假如原始檔是用 C++ 寫成的，那麼應該改成 AC_PROG_CXX。
AC_PROG_INSTALL
會產生安裝目的地，好讓使用者打 make install 便能安裝這套軟體。
AC_OUTPUT
指出應該產生的 Makefile 檔案名稱。

Using a Config Header
AM_CONFIG_HEADER(config.h) 這行指出了您將會使用 config.h 檔。autoconf 將會需要 config.h.in ，並將之處理成 config.h。這是你的原始檔案中，透過 #define 定義
的標頭檔，好提供一個方式讓人們為它們的平台自訂 configuration。config.h.in 能夠被 autoheader 這個工具程式自動產生。
然而，在你的專案中，你需要 stamp-h 這個檔案來確保 automake 從 config.h.in 重新產生 config.h。執行 'touch stamp-h' 讓您的專案新增這個檔案。

automake
automake 會尋找 Makefile.am 這個檔案，然後依據它找到的巨集產生 Makefile.in。當然，這個會在稍後的 configure script 用到。

GNU-style projects, or not
因為預設值 automake 會嘗試產生 GNU-style 的專案，因此如果一些該有的檔案不存在，automake 會向您抱怨。所以您可以用以下指令產生需要的空白文件：

touch NEWS README AUTHORS ChangeLog
如果您不需要 GNU-style 的檔案，您可以在您的 Makefile.am 增加以下這行：
AUTOMAKE_OPTIONS = foreign
Telling automake about your source files

使用下面這兩行來命名您的程式名稱，以及列出它的原始程式：
bin_PROGRAMS = hello
hello_SOURCES = hello.h hello.cc main.cc
注意：第二個變數的前置是依據第一個變數的。

The Whole Process
假設您已經概略的編輯完 Makefile.am 和 configure.in (底下有範例)，藉由底下的指令，您應該能夠 build 您專案了：
autoheader
touch NEWS README AUTHORS ChangeLog
touch stamp-h
aclocal
autoconf
automake

./configure
make
當你想完整重新 build 專案，請重複最後五個步驟。
* autoheader - creates config.h.in
* aclocal - adds aclocal.m4 to directory.
* autoconf - creates configure from configure.in
* automake - Creates Makefile.in from Makefile.am
* ./configure - creates Makefile from Makefile.in

Sub Directories
當然，專案的檔案應該被組織化的放在子目錄裡。理想上來說，原始檔和 makefile，configure scripts，以及 README 等等這些檔案，應該都放在專案的 src 這個子資料匣
中。多層式的專案我們把它叫做 Deep 專案。我會列出應該處理的步驟，但是你依然可以看看範例程式。
當使用子目錄的時候，你必須坐下的步驟：
1. 增加 SUBDIRS 這一項到最頂層的 Makefile.am。例如：
SUBDIRS = doc intl po src tests
注意這些資料匣的名稱要以空白區分。
2. 在每一個子目錄中都要新增一個 Makefile.am。但是不需要 configure.in。而且要確定最頂層的 configure.in 中的 AC_OUPUT 巨集要加入檔名以產生 Makefile。
For sub directories containing additional source code
3. 增加 AC_PROG_RANLIB 巨集到您的 configure.in。這允許您在子目錄中 build 的 code 能夠暫時放到某個暫存目錄，以便之後用來和其他 code 作連結之用。
4. 增加一些巨集到 src 下的任何原始檔目錄的 Makefile.am。這將會 build 一個不會安裝的函式庫。你需要給定以 lib 字母為開頭的函式庫名稱，並且指定該函式庫的原始碼以及標頭檔，例如：
noinst_LIBRARIES = libfoo.a
libfoo_a_SOURCES = foo.h foo.cc
INCLUDES = -I@top_srcdir@/src/includes
注意 SOURCES 巨集會使用底線 '_' 來代替函式庫的名稱的點 '.'。而且要使用 top_srcdir 這個變數來參考到專案的最頂端。
5. 在上一層目錄使用 Makefile.am 的 LDADD 這個巨集，來連結任何可能用到這個暫時函式庫的 Code。例如：
LDADD = foofiles/libfoo.a
For sub directories containing non-source files

3. 一個子目錄下的 Makefile.am 應該包含像底下的這行：
EXTRA_DIST = somefile.txt someotherfile.html
這會告訴 automake 您要發佈這些檔案，但是它們不需要編譯。
Example Files
底下就是範例檔了。它是一個使用一個標準函式庫的 C++ 專案。
看看 autoconf 和 automake 的手冊來參閱使用到的一些巨集以及變數。我不要這些範例因為註解而變的難以閱讀。
這個 Deep 專案的架構如下：
helloworld_cc
configure.in
Makefile.am

src
Makefile.am
helloworld.h
helloworld.cc
main.cc

foofiles
Makefile.am
foo.h
foo.cc

configure.in
AC_INIT(src/hello.cc)
AM_INIT_AUTOMAKE(hello,0.1)
AM_CONFIG_HEADER(config.h)
AC_PROG_CC
AC_PROG_CXX
AC_PROG_INSTALL
AC_PROG_RANLIB
AC_OUTPUT(Makefile src/Makefile src/foofiles/Makefile)
Makefile.am

SUBDIRS = src
Makefile.am for the src directory
bin_PROGRAMS = hello
INCLUDES = foofiles
hello_SOURCES = hello.h hello.cc main.cc
SUBDIRS = foofiles
LDADD = foofiles/libfoo.a
Makefile.am for foofiles directory under src

noinst_LIBRARIES = libfoo.a
libfoo_a_SOURCES = foo.h foo.cc
INCLUDES = -I@top_srcdir@/


/******************************************************************************/
Ubuntu 網路設定 - 自動取得 IP 設定 & 固定 IP 設定
/******************************************************************************/
Ubuntu會自動偵測 DHCP 網路並自動取得 IP，最近不知為何，都不會自動取得IP。
利用文字介面修改 Ethernet 網路設定為DHCP：
~$ sudo vi /etc/network/interfaces [Enter]
 1 auto lo
 2 iface lo inet loopback
 3 
 4 auto eth0
 5 iface eth0 inet dhcp
修改完利用以下指令重新啟動網路讀取網路設定。
~$ sudo /etc/init.d/networking restart


修改 Ethernet 網路設定為固定IP
~$ sudo vi /etc/network/interfaces [Enter]
 1 auto lo
 2 iface lo inet loopback
 3 
 4 auto eth0
 5 iface eth0 inet static
 6 address 192.168.xxx.yyy # 固定 IP 位址。
 7 netmask 255.255.255.0   # 網路遮罩。
 8 gateway 192.168.aaa.bbb # 預設閘道。

修改完利用以下指令重新啟動網路讀取網路設定。
~$ sudo /etc/init.d/networking restart


/******************************************************************************/
Linux下清理記憶體和Cache方法 /proc/sys/vm/drop_caches
/******************************************************************************/
Linux下清理記憶體和Cache方法 /proc/sys/vm/drop_caches
頻繁的文件訪問會導致系統的Cache使用量大增
$ free -m
total used free shared buffers cached
Mem: 3955 3926 28 0 55 3459
-/+ buffers/cache: 411 3544
Swap: 5726 0 5726
free記憶體減少到幾十兆，系統運行緩慢

運行sync將dirty的內容寫回硬碟
$sync

通過修改proc系統的drop_caches清理free的cache
$echo 3 > /proc/sys/vm/drop_caches

drop_caches的詳細文檔如下：
Writing to this will cause the kernel to drop clean caches, dentries and inodes from memory, causing that memory to become free.
To free pagecache:
* echo 1 > /proc/sys/vm/drop_caches
To free dentries and inodes:
* echo 2 > /proc/sys/vm/drop_caches
To free pagecache, dentries and inodes:
* echo 3 > /proc/sys/vm/drop_caches
As this is a non-destructive operation, and dirty objects are notfreeable, the user should run "sync" first in order to make sure allcached objects 
are freed.
This tunable was added in 2.6.16.

修改/etc/sysctl.conf 添加如下選項後就不會記憶體持續增加
vm.dirty_ratio = 1
vm.dirty_background_ratio=1
vm.dirty_writeback_centisecs=2
vm.dirty_expire_centisecs=3
vm.drop_caches=3
vm.swappiness =100
vm.vfs_cache_pressure=163
vm.overcommit_memory=2
vm.lowmem_reserve_ratio=32 32 8
kern.maxvnodes=3
上面的設置比較粗暴，使cache的作用基本無法發揮。需要根據機器的狀況進行適當的調節尋找最佳的折衷。


/******************************************************************************/
Using MOC
/******************************************************************************/
Let's switch to the most important part of this article — how to actually use play music with MOC . 
First run the program with mocp command. A window with your file system on the left should appear. The right side is reserved for the playlist. 
Now you can:
ENTER – switch to a folder, start playing the song, etc
"o" – play URL (for instance some Internet radio)
"p" or space bar – pause playing
"s" – stop playing
"l" – switch between one and two-column view
"a" – add current file to the playlist
"A" – add current folder (recursively) to the playlist
"C" – clear the playlist
"q" – turn the console interface off (MOC server is still running and you can come back by entering mocp again)
"Q" – hard power-off MOC
MOC can be also manipulated when the console interface is switched off. Here are some commands that may be useful for that:

"mocp -S" – run the MOC server
"mocp -p" – start playing the playlist
"mocp -f" – switch to the next track on the playlist
"mocp -r" – switch to the previous track on the playlist
"mocp -s" – stop playing
"mocp -P" – pause playing
"mocp -U" – resume playing
"mocp -x" – kill the server
More options can be obviously found in the MOC manual by entering man mocp.


/******************************************************************************/
基本gdb
/******************************************************************************/
gdb是個命令列模式的交談(interactive)除錯器， 跟telnet或其它的unix交談式程式一樣有個提示符號，然後要下命令
(gdb)COMMAND
不要忘了gcc編譯時要加 -g 參數， 基本gdb命令
檔案處理
========
file a.out                 載入可執行檔a.out
path                       告訴gdb obj code在那
directory                  告訴gdb source code在那裡

SHELL
=====
shell ls                   就會執行ls了
cd xxx                     不過用shell的方法跟Makefile一樣喚起sub shell而已
                           要真的cd到目錄要用cd

中斷點(Break point and watch point)處理
=======================================
break                      設定中斷點 
clear                      清除中斷點
delete                     清除中斷點
disable                    暫時使中斷無作用
enable                     使中斷再作用
condition                  進一步設中斷點的條件 如果條件為true則中斷
commands                   如果中斷了則執行commands與end中的一連串gdb命令
.....
end
    
其中 中斷點可以用source code的行數來代表(這些資訊藏在ELF格式 裡的.line這個section裡)，也可以用中斷點的流水號來表示
br                         在目前位置設中斷點
br 100                     在100行中斷
br func1                   在func1中斷
br +100                    目前位置+100行中斷
br *0x08048123             在這位址中斷
br file.c:100              因為如果是多個c檔案時指定file.c
tbreak                     同break的寫法 不過中斷一次後 此中斷點就失效
br 100 if (var == 5)       條件中斷 後面跟著c語法的條件判斷式
br 100                     在第100行中斷並且執行command...end中的gdb命令
commands
  silent
  printf "x is %d\n",x
end
break String::func1        C++ Function Overloading的中斷 String是class

clear 100                  清除中斷點  後面跟著行號或函數名
clear func1
delete 5                   清除5號中斷點  後面是中斷點流水編號
disable 3                  暫時使3號中斷點沒作用  後面是中斷點流水編號
enable 2                   使2號中斷點作用  後面是中斷點流水編號
condition 3 (var > 3)      設3號中斷點的條件 如果條件為true則中斷
condition 3                清除3號中斷點的條件

程式執行
========
set args xxx               給執行程式參數xxx，就是main裡的**argv            
run                        開始跑程式
continue                   中斷後繼續跑
next                       往下跳一步c程式 如果有副程式 執行完整個副程式
step                       往下跳一步c程式 如果有副程式 追進副程式
until                      跳離一個while for迴圈
nexti                      往下一步CPU組語的指令(Instruction)執行完整個副程式
stepi                      往下一步CPU組語的指令(Instruction)追進副程式
until                      執行到source code的行數比目前的大
                           如果目前所在行是loop的最後一行就會跳離loop

程式變數值(data)處理
====================
print var                  看var的值
print &var             印出var的位址(其時這就是C 啦)
print *var                 印出*var值 var是pointer
display var                display會每次step, next時都會印出值來,print只印一次
print (var=value)          設var的值為value
                           其實print 可以只用p代替 很多指令都可以簡寫代替
p/x                        /x表示印hex值
                           /u表示unsigned digit
                           /d    signed digit
                           /t    二進位值
                           /是列印的選項 在Solaris上的adb也有相似形式
x/3uh 0x8048012            印出記憶體
                           其中
                           3表示看3個
                           u      unsigned digit(跟上面p命令一樣意義) 
                           h      halfword就是2bytes(bhwg分別是1248bytes)

GDB內定變數(跟程式變數不一樣喔)
===============================
一些gdb方便的變數(convenience variable)
$_                         用x命令所得到的最後一個位址
$__                        用x命令所得到的最後一個位址的值
$_exitcode                 程式離開的code就是用exit時的code
CPU暫存器(registers)
$pc                        program counter就是目前cpu指到的執行位置啦
$sp                        stack pointer

訊息觀看與設定
==============
info                       得到一些program debug資訊
                           info break
                           info frame
                           info display
                           info program
                           info share
                           info registers
show                       得到一些系統(OS, CPU Arch), GDB資訊
                           show args       (系統傳進來的argv[0],argv[1]...)
                           show os         (OS是什麼)
                           show endian
                           show prompt     (gdb的提示符號)
list                       看原始碼
                           list x  從第x行的source code印出，x不寫從目前行印出
                           list *addr  秀出addr所在source code的行
                                       可以先用info program找出目前PC的值
                                       再用list *addr
                           search REGEXP 在目前source code做RE搜尋
disas                      想看machine code用這個
whatis var                 告訴我var的資料型別是啥 int, char or double
ptype var                  告訴我var的資料型別是啥 這用來看struct用的
set                        設定gdb, 系統的控制變數值(這些變數不是program內的)
                           set listsize xx  設定要看xx行source code
                           set $pc xx       把PC設到 xx
                           set convenience可以自己設變數
help                       可以得到命令HELP

程式與副程式(process and sub-function)
======================================
backtrace(bt)2             程式執行到這裡前的兩個副程式，2不寫則列出全部
frame        2             選擇2號frame跳過去  2不寫就列出現在執行到那裡
up           2             往上走2個副程式
down         3             往下走2個副程式
return       expression    不要玩了,回到上一層呼叫的routine去並return一個值
finish                     繼續玩完一個選擇的stack frame(副程式)
kill                       砍掉child process
signal       procss-id     送signal給process
attach       procss-id     debug一個已經在記憶體跑的process
detach       procss-id     釋放attach的process脫離gdb的控制
其中每次程式呼叫副程式時， 原本的執行的世界的東西(變數值啊等等)必需先保存起來， 然後再跳到新世界(將要執行的副程式)這就是stack， 每叫一個sub routine就等於
進到一個stack frame
(gdb)frame 2 
就是選擇2號frame，而0號frame就是目前在執行的副程式， 1號是呼叫0號的副程式，以此類推， finish搭配frame這個命令來用。所以bt這個命令很重要，可以追回之前叫了
那些function來到目前的地方。 通常在命令列也有類似的追蹤system call的程式，因為system call很重要， 在Solaris上我們可以用。
$ truss prog1
在Linux上
$ strace prog1
來看現在程式到底叫了甚麼system call導致他毀掉。
attach, detach必需在有支援process 的環境， 因為有的沒記憶體保護OS，或embadded system沒有支援， 另外也要有能力送signal給process的環境才行， 這主要可以來
debug deamon或做multiprocess的除錯


/******************************************************************************/
LCD Driver (1)          from: http://dicky-chiang.blogspot.com/search/label/embedded
/******************************************************************************/
第一章理解的都只是初步,未涉及到相關LCD的知識 但為了怕一些細節容易忘記...似懂非懂的 還是記錄下來...
後面的陸續補上,看自己讀code的時間要花多少了 XD
如有錯誤,也請路過的鄉民指點,感激不盡^^
(恩...英文文法有錯的話看看就好,別太在意...意思到就好 !)
==============================
Written by Dicky
SAARB board init code the path is arch/arm/mach-pxa/saarb.c
First,We check the saarb.c code,because this is configure LCD Controller source,can be find pxa950fb_mach_info struct,such as :
static struct pxa950fb_mach_info saarb_lcd_info __initdata = {
.id = "Base",
.modes = video_modes,
.num_modes = ARRAY_SIZE(video_modes),
.pix_fmt_in = PIX_FMTIN_RGB_16,
.pix_fmt_out = PIX_FMTOUT_24_RGB888,
.panel_type = LCD_Controller_Active,
/* .mixer0 = LCD_M2PARALELL_CONVERTER,*/
.mixer0 = LCD_MIXER_DISABLE,
.mixer1 = LCD_M2DSI1,
.active = 1,
.pxa950fb_lcd_power = espon_lcd_power,
.pxa950fb_dsi_reset = tavorpv2_saarb_dsi_reset,
.invert_pixclock = 1,
};
And also find video modes struct,that is important :

static struct fb_videomode video_modes[] = {
[0] = {
.pixclock = 41701,
.refresh = 60,
.xres = 480,
.yres = 800,
.hsync_len = 19,
.left_margin = 40,
.right_margin = 59,
.vsync_len = 9,
.upper_margin = 4,
.lower_margin = 9,
.sync = 0,
},
};

1. How to register platorm device to kernel
Before discuss that,first look at how to initialize & register LCD driver for saarb board :
static void __init saarb_init(void)
{
.......
#if defined(CONFIG_FB_PXA950)
pxa3xx_mfp_config(ARRAY_AND_SIZE(lcd_mfp_cfg));
saarb_init_lcd();
#endif
........
}

saarb_init_lcd function :
static void __init saarb_init_lcd(void)
{
set_pxa950_fb_info(&saarb_lcd_info);
set_pxa950_fb_ovly_info(&saarb_lcd_ovly_info);
}

To call it :
void __init set_pxa950_fb_info(struct pxa950fb_mach_info *info) 
{ 
    pxa_register_device(&pxa950_device_fb, info);
} 
See ? We can be find the platform_device struct :
struct platform_device pxa950_device_fb = {
    .name = "pxa950-fb",
    .id = -1,
    .dev = {
      .dma_mask = &fb_dma_mask,
      .coherent_dma_mask = 0xffffffff,
    },
    .num_resources = ARRAY_SIZE(pxa950fb_resources),
    .resource = pxa950fb_resources,
};
What is Platform ? That like is character,block,net device,for register to kernel,need write data into the platform_device & platform_driver.
Normal define in the arch/arm/mach-xxx/devices.c
There is another important member of the platform_device :
.resource = pxa950fb_resources,

The mean is description the hardware resource occupied by device(as memory address,IRQ number etc,). :
static struct resource pxa950fb_resources[] = {
[0] = {
.start = 0x44100000,
.end = 0x4410ffff,
.flags= IORESOURCE_MEM,
},
[1] = {
.start = IRQ_LCDGLOBAL,
.end = IRQ_LCDGLOBAL,
.flags = IORESOURCE_IRQ,
},
[2] = {
.start= IRQ_LCDPARALLEL,
.end= IRQ_LCDPARALLEL,
.flags= IORESOURCE_IRQ,
},
[3] = {
.start= IRQ_DSI0,
.end = IRQ_DSI0,
.flags = IORESOURCE_IRQ,
}
[4] = {
.start = IRQ_DSI1,
.end = IRQ_DSI1,
.flags = IORESOURCE_IRQ,
},
}; 
Lastly add device to kernel of complete by call function platform_device register :
void __init set_pxa950_fb_info(struct pxa950fb_mach_info *info)
{
    pxa_register_device(&pxa950_device_fb, info);
}

void __init pxa_register_device(struct platform_device *dev, void *data)
{
    int ret;

    dev->dev.platform_data = data;
    ret = platform_device_register(dev);
    if (ret)
    &dev_err(&dev->dev, "unable to register device: %d\n", ret);
}
As you see,the pxa950fb_mach_info has link to member of dev.platform_data.
What is pxa950fb_mach_info ? 
That's main board the LCD controlle register infomation sturct.
Also see the point variable(*dev) will be register to kernel. ( That struct generate by pxa950_device_fb)

2. How to register platform driver to kernel
到目前為止,我們己經完成LCD裝置所需的硬體資源和配置, 現在可以為它寫一支驅動程式來驅動它
一般來說,所有Driver的程式碼都會在kernel/driver的路徑下,如MMC Driver是kernel/driver/mmc
所以LCD的driver就在kernel/driver/video底下了, 各家不同平台的驅動都會放在這,Marvell平台的LCD驅動就叫pxa950fb.c
一樣,直接先來看它如何做初始化驅動的 :

static int __devinit pxa950fb_gfx_init(void)
{
    #ifdef CONFIG_PXA3xx_DVFM
    dvfm_register("pxa950-fb", &dvfm_dev_idx);
    #endif
    return platform_driver_register(&pxa950fb_gfx_driver);
}
DVFM先撇開不談,後續再來討論,因為它只是一種視訊格式而己,
從init function可以發現一個很有趣的結構 :
static struct platform_driver pxa950fb_gfx_driver = {
    .driver = {
        .name = "pxa950-fb",
        .owner = THIS_MODULE,
    },
    .probe = pxa950fb_gfx_probe,
};
這個結構相當重要,前面有提到,一個Platform有兩個最重要的資料結構,分別是platform_device和platform_driver
這兩個結構都可以在kernel/include/linux/platform_deivce.h找到, 在這此結構當中,有兩個成員是必填的,分別是Name和Probe
沒有Name值,Kernel不知道如何把這支驅動對應到哪個裝置, 沒有probe functuion pointer,Kernel不知道如何初始化驅動程式..
所以接下來第二個進入點就是probe function了,不管什麼驅動,probe必存在 !
這個LCD driver在probe function裡面做了很多事....一步一步來探討,先列出一部份:
struct pxa950fb_mach_info *mi;
struct fb_info *info = 0;
struct pxa950fb_info *fbi = 0;
struct resource *res;
struct clk *clk_lcd, *clk_dsi0, *clk_dsi1, *clk_axi;
int irq_ctl, irq_conv[2], ret;
int i;
u32 converter;

mi = pdev->dev.platform_data;
if (mi == NULL) {
    dev_err(&pdev->dev, "no platform data defined\n");
    return -EINVAL;
}
一開始就把pdev->gt;dev.platform_data的Address指向mi,而mi又指向pxa950fb_mach_info.....
也就是說,pxa950fb_mach_info的位址(值)等同於pdev->gt;dev.platform_data...
重點來了 ! pxa950fb_mach_info是什麼呢 !? 前面有提到,它是LCD裝置控制器的結構
可是它幹嘛把pdev->gt;dev.platform_data指向LCD裝置控制器呢 ?
因為在註冊platform_device的時候,就己經把這些LCD控制器的定義都註冊進去了(翻前面的程式碼)
現在驅動需要用到,當然要把它給指過來 ! 不然驅動怎麼知道device到底定義哪些東西,又該如何使用
所以這一步就把下到上的資料結構串起來,驅動程式才可以針對裝置去做其它操作了 !
然後就能看到後面開始去做什麼開啟Clock啦....註冊中斷啦....打開什麼一堆東西啦等等..


/******************************************************************************/
LCD Driver (2)
/******************************************************************************/
3. FrameBuffer 
在把Probe所有的動作搞清楚之前,要開始提及相關LCD的知識了...不然後面的程式會看不懂...，眾所皆知,Linux系統剛起家時並沒有什麼圖形界面,指令就是一切
後面才開始發展出X-window的圖形系統,通過X-server即可操作顯卡硬體.
可是為什麼在開機時,就會有圖形界面出來呢 ? 這時X-windows都還沒運行勒...，靠的就是FrameBuffer(簡稱fb),更簡單來說,它只是一個機制,可以參考下面這段話 :
FrameBuffer不是一個圖形系統，更不是視窗系統。它比X要低級，簡單來說FrameBuffer就是一種機制的實現。這種機制是把螢幕上的每個點對映成一段線性記憶體空間，程式
可以簡單的改變這段記憶體的值來改變螢幕上某一點的色彩。X的高度可攜式性就是來自於這種機制，不管是在那種圖形環境下，只要有這種機制的實現就可以執行X。所以在
幾乎所有的平台上都有相應的X版本的移植。
聽起來很繞口,說白一點就是...FrameBuffer提供了一組ioctl,讓使用者完全不用考慮顯卡硬體就可以使用這組ioctl來操作了 
大致上瞭解FrameBuffer是啥東西了,接著在繼續往下看 :

info = framebuffer_alloc(sizeof(struct pxa950fb_info), &pdev->dev);
if (info == NULL)
return -ENOMEM;

/* Initialize private data */
fbi = info->par;
fbi->fb_info = info;
platform_set_drvdata(pdev, fbi);
fbi->clk_lcd = clk_lcd;
fbi->clk_axi = clk_axi;
fbi->clk_dsi0 = clk_dsi0;
fbi->clk_dsi1 = clk_dsi1;
fbi->dev = &pdev->dev;
fbi->on = 1;
fbi->is_blanked = 0;
fbi->suspend = 0;
fbi->debug = 0;
fbi->pix_fmt_out = mi->pix_fmt_out;
fbi->active = mi->active;
fbi->invert_pixclock = mi->invert_pixclock;
fbi->panel_rbswap = mi->panel_rbswap;
fbi->panel_type = mi->panel_type;
fbi->mixer[0] = mi->mixer0;
fbi->mixer[1] = mi->mixer1;
fbi->power = mi->pxa950fb_lcd_power;
fbi->dsi_reset = mi->pxa950fb_dsi_reset;
fbi->window = 0; /*wge 9 and channel 0 is used for fb0*/
fbi->user_addr = 0;
fbi->eof_intr_en = 1;
fbi->vsync_en = 0;
fbi->eof_handler = NULL;
很明顯看的出來,全是對pxa950fb_info這個結構初始化,在說明之前,先來看一開始create framebuffer這個function :

struct fb_info *framebuffer_alloc(size_t size, struct device *dev)
{
    #define BYTES_PER_LONG (BITS_PER_LONG/8)
    #define PADDING (BYTES_PER_LONG - (sizeof(struct fb_info) % BYTES_PER_LONG))
    int fb_info_size = sizeof(struct fb_info);
    struct fb_info *info;
    char *p;

    if (size)
    fb_info_size += PADDING;

    p = kzalloc(fb_info_size + size, GFP_KERNEL);

    if (!p)
        return NULL;

    info = (struct fb_info *) p;

    if (size)
    info->par = p + fb_info_size;

    info->device = dev;

    #ifdef CONFIG_FB_BACKLIGHT
    mutex_init(&info->bl_curve_mutex);
    #endif

    return info;
    #undef PADDING
    #undef BYTES_PER_LONG
}
EXPORT_SYMBOL(framebuffer_alloc);
除了分配記憶體空間之外,最值得注意的是回傳型態 :
struct fb_info *framebuffer_alloc(size_t size, struct device *dev)
是指向fb_info的sturct,看來它和pxa950fb_info根本是同一夥的 !!
fb_info這個資料結構定義在kernel/include/linux/fb.h,這個結構非常非常之重要,LCD Driver能不能動都看它了.
因為它為FrameBuff定義驅動層的ioctl所在,也就是說,每一個LCD Deivce,基本上都會有相對應的一個專有fb_info資料結構
而pxa950fb_info的結構是存放著LCD的硬體資訊,所以也就可以理解為什麼要這麼寫 :
info = framebuffer_alloc(sizeof(struct pxa950fb_info), &pdev->dev);
if (info == NULL)
return -ENOMEM;

/* Initialize private data */
fbi = info->par;
fbi->fb_info = info;
platform_set_drvdata(pdev, fbi);

此時info的資料型態是(struct fb_info*),別搞錯了,而fbi的資料型態是(struct pxa950fb_info*),所以第一和第二步驟就是讓他們結成連理!!!!
至於第三步驟嘛...把它打回原形就一目瞭然了 :
#define platform_set_drvdata(_dev,data) dev_set_drvdata(&(_dev)->dev, (data))

void dev_set_drvdata(struct device *dev, void *data)
{ 
    int error;

    if (!dev)
    return;
    if (!dev->p) {
        error = device_private_init(dev);
        if (error)
        return;
    }
    dev->p->driver_data = data;
}
EXPORT_SYMBOL(dev_set_drvdata); 
初始化device之後,再把fbi的資料放進該裝置的專有資料裡面 ; 這樣的寫法是很難懂...但Kernel就是靠這樣的做法來保護每個不同裝置所存放的資料
後面的步驟就很簡單了....該需要用到的資料成員一個一個對號入座.再後面還是針對fb_info的每個成員來定義或者初始化,挑幾個重點來說...


/******************************************************************************/
LCD Driver (3)
/******************************************************************************/
剛仔細看了probe的程式...發現LCD Driver在probe所做的事情真的很多...雖然都只是初始化而己
但很多預備工作少不了,而且所需要的相關知職更多....，在上述的fb_info部份成員填進去之後,開始分配記憶體空間了:
/* Map registers.*/
fbi->reg_base = ioremap_nocache(res->start, res->end - res->start);
if (fbi->reg_base == NULL) {
    ret = -ENOMEM;
    goto failed;
}

/* Allocate framebuffer memory.*/
fbi->fb_size = PAGE_ALIGN(DEFAULT_FB_SIZE);
fbi->fb_start = dma_alloc_writecombine(fbi->dev, fbi->fb_size + PAGE_SIZE,
&fbi->fb_start_dma,
GFP_KERNEL);
if (fbi->fb_start == NULL) {
    ret = -ENOMEM;
    goto failed;
}
ioremap_nocache和dma,相信這兩個名詞很多人相當熟悉...鑑於我的腦袋...還是把僅存的己知寫上去 XD
首先講敘ioremap_cache是怎麼回事,它的原型是長這樣 :
static inline void __iomem * ioremap_nocache(unsigned long offset, 
unsigned long size)
{ 
    return ioremap(offset, size);
} 

傳的參數非常簡單,就是取得之前platform的resource的實體io/memory等相關資源之後,再利用ioremap來轉換成核心虛擬記憶體
那為什麼一定要轉成核心虛擬記憶體勒 ? 有個觀念要僅記....任何device的driver,都不可以直接存取實體記憶體 !
分配好對應硬體資源的虛擬記憶體之後,接著就是分配DMA的空間(即顯卡記憶體),其中的DEFAULT_FB_SIZE定義如下 :
/* default fb buffer size VGA-32bits double buffer */
#define DEFAULT_FB_SIZE (640 * 480 * 8 + PAGE_SIZE) 
本來我認為FB的SIZE應該是要跟自身定義的解析度有關,這樣才合理
也就是說,video_mode是定義800*480,應該修改成一樣才對....但結果好像不是...很怪
而且查了之前的案子,發現之前的LCD螢幕使用的是HX8369-A
Datasheet裡面有寫,Frame memory area是480*864*24 , 當然這裡指的是最高支援的解析程度..
但如果是我的話...FB SIZE應該要定義最高的解析程度吧.....這樣才能都適用呀... XD
先來看一個很重要的資料結構,在上面分配完之後,有一個function pointer放進fb_info :
info->fbops = &pxa950fb_gfx_ops;

static struct fb_ops pxa950fb_gfx_ops = { 
    .owner = THIS_MODULE,
    .fb_blank = pxa950fb_gfx_blank,
    .fb_ioctl = pxa950fb_gfx_ioctl,
    .fb_check_var = pxa950fb_check_var,
    .fb_set_par = pxa950fb_set_par,
    .fb_setcolreg = pxa950fb_setcolreg, /* TODO */
    .fb_pan_display = pxa950fb_pan_display,
    .fb_fillrect = cfb_fillrect,
    .fb_copyarea = cfb_copyarea,
    .fb_imageblit = cfb_imageblit,
};
很眼熟吧 ? 它就是LCD驅動提供給上層設備調用的操作函數,至於這誰會調用,等把整個流程理清之後,後面開始說明重要的資料結構和大體架構.
最後,有三個重要的function來結束整個主要驅動註冊和初始化過程 :
pxa950fb_set_par(info);
register_framebuffer(info);
device_create_file(&pdev->dev, &dev_attr_vsync);
pxa950fb_set_par主要是設置BPP(Bit Per Pixel)屬性和計算Line(行)的長度,而register_framebuffer和device_create_file就很簡單理解了
FrameBuffer真的要能工作起來,這個註冊function不能少,屆時另開章節來講LCD架構和資料結構的說明..
在公司的板子和新的Datasheet來之前,要趕快搞清楚這些東西...不然還真不好porting......


/******************************************************************************/
LCD Driver (4)
/******************************************************************************/
從之前的(1)~(3),我都只提到physical layer <-> Kernel space之間而己,並未探討user space該如何運行.
在開始之前,先說明兩個相當重要的code :
kernel/linux/include/fb.h <- 定義許多相關FB的結構,變數和define kernel/driver/video/fbmem.c <- 實現核心層和使用者層之間的ioctl 
瞭解這兩個程式其實對porintg來說幫助並不大,但卻助於理解Linux driver整體架構,也能清楚知道原來應用層一直到實體層是透過怎樣的機制來實現的.
====================
fbmem.c ; 這支程式在/dev創建一個fb0的設備(看有幾個調用register_framebuffer這個function...預設最多創建32個,這個define可以在fb.h看的到)
可以這麼想像,它是介於Kernel與使用者之間的一個橋樑,正確來說,是一個字元(Character)裝置.
使用者可以透過這個字元裝置,利用ioctl方便的直接操控硬體顯示
有寫過字元裝置的driver都知道,一定會有一個major和minor,而且還會有一個裝置節點(node),其中Major(主編號)在程式裡面定義是29,而Minor(次編號)則是隨著count而增加
所以一般來說,你在Linux發行版本上,一定都會看到這個裝置 :
#cat /dev/fb0
如果出現亂碼,表示現在使用的發行版的kernel是有打開FB support
====================
打開fbmem.c,在init中有一個非常熟悉的function : 
if (register_chrdev(FB_MAJOR,"fb",&fb_fops)) 
printk("unable to get major %d for fb devs\n", FB_MAJOR); 
字型裝置的註冊函式,而這裡fb_fops當然就是file_operations囉 !
static const struct file_operations fb_fops = {
    .owner = THIS_MODULE,
    .read = fb_read,
    .write = fb_write,
    .unlocked_ioctl = fb_ioctl,
    #ifdef CONFIG_COMPAT
    .compat_ioctl = fb_compat_ioctl,
    #endif
    .mmap = fb_mmap,
    .open = fb_open,
    .release = fb_release,
    #ifdef HAVE_ARCH_FB_UNMAPPED_AREA
    .get_unmapped_area = get_fb_unmapped_area,
    #endif
    #ifdef CONFIG_FB_DEFERRED_IO
    .fsync = fb_deferred_io_fsync,
    #endif
};
就算FrameBuffer是一塊記憶體,不管是內顯還是外顯,Linux通通都看成是一個設備 !
在這裡,fb_fops提供一系列操作函數給使用者去呼叫,其中有一點要特別注意,調用fb_open的時候,除了探測module是否有被使用之外
它還會利用次設備來匹配不同的裝置 :
int fbidx = iminor(inode);
struct fb_info *info;
if (fbidx >= FB_MAX)
return -ENODEV;
info = registered_fb[fbidx];
以及把fb_info的private data存放進該device :
file->private_data = info;
最最重要的是,它會去呼叫該device的fb_info裡面的成員fbops的操作函數 : fd_open !
if (info->fbops->fb_open) {
    res = info->fbops->fb_open(info,1);
    if (res)
        module_put(info->fbops->owner);
}
從這一刻開始,由上至下,physical laye <-> kernel space <-> user space都銜接了.
而fd.h定義了ioctl的一系列cmd (每個cmd都會對應fbos的function , 除非該功能不需用到硬體資訊):

#define FBIOGET_VSCREENINFO 0x4600
#define FBIOPUT_VSCREENINFO 0x4601
#define FBIOGET_FSCREENINFO 0x4602
#define FBIOGETCMAP 0x4604
#define FBIOPUTCMAP 0x4605
#define FBIOPAN_DISPLAY 0x4606
#define FBIOGET_CON2FBMAP 0x460F
#define FBIOPUT_CON2FBMAP 0x4610
#define FBIO_ALLOC 0x4613
#define FBIO_FREE 0x4614
#define FBIOGET_GLYPH 0x4615
#define FBIOGET_HWCINFO 0x4616
#define FBIOPUT_MODEINFO 0x4617
#define FBIOGET_DISPINFO 0x4618
現在馬上就來測試使用它 ! 先用vim新建一個.c檔 :
#vim testfb.c
接著copy下面我寫的code :
#include 
#include 
#include 
#include 

/* Frame Buffer Test on Ubuntu 10.4 */
int main()
{
    int fp = 0;
    struct fb_var_screeninfo varinfo;
    struct fb_fix_screeninfo fixinfo;

    fp = open("/dev/fb0",O_RDWR);
    printf("fp = %d\n",fp);
    if(!fp)
    {
        printf("Error : Can not open /dev/fb0\n");
        exit(1);
    }
    if (ioctl(fp,FBIOGET_FSCREENINFO,&fixinfo))
    {
        printf("Error reading fixed information\n");
        exit(1);
    }

    if (ioctl(fp,FBIOGET_VSCREENINFO,&varinfo))
    {
        printf("Error reading variable information\n");
        exit(1);
    }

        printf("The mem is :%d\n",fixinfo.smem_len);
        printf("The line_length is :%d\n",fixinfo.line_length);
        printf("The xres is :%d\n",varinfo.xres);
        printf("The yres is :%d\n",varinfo.yres);
        printf("bits_per_pixel is :%d\n",varinfo.bits_per_pixel);
        close (fp);
}
儲存離開後,先別急著編譯,因為要開啟/dev底下的設備是需要root權限,所以先切換成root :
#sudo su -
然後再compile/run它 :
#gcc -o testfb testfb.c
#./testfb
這時就可以看到當前LCD(營幕)的屬性 :
fp = 3
The mem is :65536
The line_length is :80
The xres is :640
The yres is :480
bits_per_pixel is :4
因為我是在VitrualBox底下...所以只有640*480(虛擬顯卡通常都很爛).


/******************************************************************************/
利用upnp 映射到外網 (2012-03-15 18:41)  http://blog.chinaunix.net/uid-20648944-id-3134810.html
/******************************************************************************/
1. Upnp 下載地址 http://miniupnp.free.fr/files/
說明：miniupnpc 為用戶端, miniupnpd 為服務端，這裡下載 miniupnpc-1.6.20120125.tar.gz 

2. 編譯miniupnp：
# tar xf miniupnpc-1.6.20120125.tar.gz
# make
在此目錄下會生成 upnpc-static  upnpc-share

3. 配置路由器 讓其開啟 upnp 功能
登錄路由器後 選擇 轉發規則-->upnp 設置→ 開啟

4. 在用戶端(loongson 1B 開發板)添加upnp 規則 
#  ifconfig  //查看本機IP
eth0     Link encap:Ethernet  HWaddr 00:1e:64:63:ab:fe  
          inet addr:192.168.3.111  Bcast:192.168.3.255  Mask:255.255.255.0Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:163376 errors:0 dropped:0 overruns:0 frame:0
          TX packets:136701 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:170220701 (170.2 MB)  TX bytes:21403783 (21.4 MB)

#  upnpc-static  -a 192.168.3.111 80 8008 TCP   //此處的IP為本機IP
upnpc : miniupnpc library test client. (c) 2006-2011 Thomas Bernard
Go to http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
for more information.
List of UPNP devices found on the network :
 desc: http://192.168.3.1:1900/igd.xml
 st: urn:schemas-upnp-org:device:InternetGatewayDevice:1

Found valid IGD : http://192.168.3.1:1900/ipc
Local LAN ip address : 192.168.3.111
ExternalIPAddress = 192.168.1.12
InternalIP:Port = 192.168.3.111:80
external 192.168.1.12:8008 TCP is redirected to internal 192.168.3.111:80 (duration=0)
說明：80 為內部連接埠, 此連接埠號可隨意設置，只要與 web server的提供的連接埠號相同就可以了。8008 為外連接埠，也就是在外面通過 192.168.1.12:8008 就可以訪
問用戶端的web 頁面了
Upnpc-static 的詳細用法：#  Upnpc-static
upnpc : miniupnpc library test client. (c) 2006-2011 Thomas Bernard
Go to http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
for more information.
Usage :    ./upnpc-static [options] -a ip port external_port protocol [duration]
        Add port redirection
           ./upnpc-static [options] -d external_port protocol [port2 protocol2] [...]
        Delete port redirection
           ./upnpc-static [options] -s
        Get Connection status
           ./upnpc-static [options] -l
        List redirections
           ./upnpc-static [options] -L
        List redirections (using GetListOfPortMappings, IGD v2)
           ./upnpc-static [options] -r port1 protocol1 [port2 protocol2] [...]
        Add all redirections to the current host
           ./upnpc-static [options] -A remote_ip remote_port internal_ip internal_port protocol lease_time
        Add Pinhole (for IGD:2 only)
           ./upnpc-static [options] -U uniqueID new_lease_time
        Update Pinhole (for IGD:2 only)
           ./upnpc-static [options] -C uniqueID
        Check if Pinhole is Working (for IGD:2 only)
           ./upnpc-static [options] -K uniqueID
        Get Number of packets going through the rule (for IGD:2 only)
           ./upnpc-static [options] -D uniqueID
        Delete Pinhole (for IGD:2 only)
           ./upnpc-static [options] -S 
        Get Firewall status (for IGD:2 only)
           ./upnpc-static [options] -w routerip
        set the ip address of the router with upnp server
           ./upnpc-static [options] -G remote_ip remote_port internal_ip internal_port protocol
        Get Outbound Pinhole Timeout (for IGD:2 only)
           ./upnpc-static [options] -P
        Get Presentation url
protocol is UDP or TCP
Options:
  -6 : use ip v6 instead of ip v4.
  -u url : bypass discovery process by providing the XML root description url.
  -m address/interface : provide ip address (ip v4) or interface name (ip v6) to use for sending SSDP multicast packets.
  -p path : use this path for MiniSSDPd socket.
備註：用戶端要和路由器連在一起，因為upnp 只能穿透 1 層網路
這時再次登陸路由器 選擇 轉發規則-->upnp 設置→ 刷新 就可以看到添加了一條 upnp規則
當前UPnP設置列表
ID     應用描述     外部連接埠     協定類型     內部連接埠     IP地址     狀態
1    libminiupnpc    8008    TCP    80    192.168.3.111    已啟用
    
5. 在用戶端開啟web 伺服器(loongson 1B開發板上用 boa 做web server，因為其大小只有 100 KB 多點 )
# cat /etc/boa/boa.conf | grep Port  //查看其連接埠號 看是否與upnp映射的連接埠號相同，不同則改為相同
 #Port: The port Boa runs on.  The default port for http servers is 80.
Port 80
# boa    //板上的web server ，
6. 在電腦上測試
這時找一個電腦在瀏覽器裡輸入： 192.168.1.12:8008 鍵入 enter ，用戶端裡的web頁面就呈現在你的面前了


/******************************************************************************/
Miniupnpd Porting
/******************************************************************************/
Porting
1. 安裝Miniupnpd之前呢需要安裝iptabels請在這個網站上下載
2. cd iptables.x.x.x ;  ./configure ; make ; make install
3.  解壓縮 miniupnpd
tar zxvf miniupnpd.tar.gz 

4. 如果Distination Board 是Linux呢
cp Makefile.linux Makefile

5. vi Makefile
 設定
IPTABLESPATH=/usr/local/src/iptables.x.x.x
make

Setting
1. copy miniupnpd/netfilter/*.sh到版子上的jffs2
2. 修改shell script裡面的EXTIF指到對外的interface
3. 執行shell scrupt   。 sh iptables_init.sh
4. 執行程式./miniupnpd -f /etc/miniupnpd.conf 。
看到Apr  9 09:00:04 miniupnpd[7980]: Listening for NAT-PMP traffic on port 5351
這樣就代表完成了 
5. 可以利用iptables_display.sh顯示所以有的conntrack。

如果看到下面訊息就代表iptables的shell script 沒有執行，MINIUPNPD chain沒有新增到iptables裡
 chain MINIUPNPD not found

Test
在這個網站上可以抓到UPnP的 test tool，點選UPnP裝置並且點選Properties讀取內容。


/******************************************************************************/
打造家用防火牆的需求 by pfSense 
/******************************************************************************/
http:http://www.mobile01.com/topicdetail.php?f=300&t=253487&p=1


/******************************************************************************/
讓Linux NAT伺服器支援UPnP(轉)
/******************************************************************************/
注意：如果對網路安全要求較高或要求高可控制性的網路，則不要安裝配置UPnP支援，否則會導致網路NAT映射比較混亂，從而引發許多問題。建議小型網路或者家庭網路使用
UPnP。
最近經常使用一些P2P類型軟體，發現老得在Linux伺服器上手動設置NAT，非常麻煩，而看著許多P2P軟體都支援UPnP就眼饞，如果能讓Linux支援UPnP那就簡單方便多了！於是
在網上搜索了一下有關讓Linux支援UPnP的文章，於是就寫了這篇文章。
一、什麼是UPnP
1. UPnP簡介
UPnP(Universal Plug and Play)技術對即插即用進行了擴展，它簡化了家庭或企業中智慧設備的聯網過程。在結合了UPnP技術的設備以物理形式連接到網路中之後，它們可以
通過網路自動彼此連接在一起，而且連接過程無需用戶的參與。
UPnP規範基於TCP/IP協定和針對設備彼此間通訊而制訂的其它Internet協定。這就是它之所以被稱作"通用(Universal)"的原因所在--UPnP技術不依賴於特定的設備驅動程式，
而是使用標準的協定。UPnP設備可以自動配置網路地址，宣佈它們在某個網路子網的存在，以及互相交換對設備和服務的描述。基於Windows XP的電腦可以充當一個UPnP控制
點，通過程式界面對設備進行發現和控制。 
如果與以前的即插即用相比，這種技術似乎並不具有什麼革命性的意義。在作業系統中增加即插即用技術使得在單個電腦上安裝、配置和添加外設的工作變得更容易了。但是
UPnP為家庭用戶或者小型辦公環境中的非專業用戶所帶來的是一道更加美味的"大餐"，他們可以利用UPnP玩多人遊戲，進行實時通信（Internet電話，電話會議）以及使用類
似Windows XP的遠端協助這樣的其它技術。 
2. NAT 穿越技術 
NAT穿越技術允許網路應用程式對它們是否位於一個具有UPnP能力的NAT設備之後進行檢測。然後，這些程式將獲得共享的全球可路由IP地址，並且配置連接埠映射以將來自NAT
外部連接埠的數據包轉發到應用程式使用的內部連接埠上--所有這一切都是自動完成的，用戶無需手動映射連接埠或者進行其它工作。NAT穿越技術允許網路設備或者點對點應
用程式通過動態開啟和閉合與外部服務之間的通信連接埠穿過NAT網關與外界通信。
二、在Linux中部署UPnP支援
我們假設該Linux的內核版本是2.4.x，使用撥號上網，外網介面是ppp0，內網介面是eth0，並且已經啟用iptables設定了 NAT。
在Linux中部署UPnP主要使用2個軟體的配合：UPnP SDK for Linux和LinuxIGD。
下載地址：
UPnP SDK for Linux: http://sourceforge.net/projects/upnp/
LinuxIGD: http://linux-igd.sourceforge.net/
注意：要下載upnpsdk-1.0.4.tar.gz，1.0.4以上的版本不能和LinuxIGD很好的協同工作！

A. 安裝：
1. 解包UPnP SDK
# tar xzvf upnpsdk-1.0.4.tar.gz
2. 修改源代碼
為了能夠使Windows MSN Messenger在UPnP下正常通訊，所以必須修改源代碼：
# cd upnpsdk-1.0.4
# vi src/ssdp/ssdplib.c
將第406行的：
SelfAddr.sin_addr.s_addr = inet_addr(SSDP_IP);
改為：
SelfAddr.sin_addr.s_addr = htonl(INADDR_ANY);
3. 編譯安裝UPnP SDK
# make
# make install
4. 解包Linux-IGD
# tar xzvf linuxigd-0.92.tgz
5. 編譯安裝Linux-IGD
# cd linux-igd
# make
# make install

B. 配置
1. 增加多播路由
# route add -net 239.0.0.0 netmask 255.0.0.0 eth0
2. 為iptables建議一個軟鏈接
# cd /usr/sbin
# ln -s /sbin/iptables ./
啟動UPnP
# upnpd ppp0 eth0
診斷UPnP運行狀態
# tail /var/log/messages
如果能夠看到：
Dec 14 16:01:49 doorway -- MARK --
Dec 14 16:02:15 doorway upnpd: The Linux UPnP Internet Gateway Device Ver 0.92 by Dime (dime@gulfsales.com)
Dec 14 16:02:15 doorway upnpd: Special Thanks for Intel's Open Source SDK and original author Genmei Mori's work.
則說明UPnP已經成功啟動。

C. 測試
以支援UPnP的P2P網路電視PPLive為例，在PPLive中打開UPnP支援選項，然後連接一個頻道。
在Linux中執行：
# tail /var/log/debug -f
如果能看到：
Dec 14 16:56:33 doorway upnpd: AddPortMap: RemoteHost: (null) Prot: 17 ExtPort: 3226 Int: 10.0.0.2.3226 
Dec 14 16:56:33 doorway upnpd: AddPortMap: RemoteHost: (null) Prot: 6 ExtPort: 3226 Int: 10.0.0.2.3226 
Dec 14 16:56:33 doorway upnpd: AddPortMap: RemoteHost: (null) Prot: 6 ExtPort: 3156 Int: 10.0.0.2.3156
Dec 14 16:56:33 doorway upnpd: AddPortMap: RemoteHost: (null) Prot: 6 ExtPort: 3156 Int: 10.0.0.2.3156
則說明PPLive已經向UPnP請求進行連接埠映射了。只要看到這樣的字樣，就說明UPnP已經完全工作起來了。


/******************************************************************************/
如何突破防火牆設定      from :http://wadefs.blogspot.com/2008/01/router-1-accept-from-to-2-deny.html
/******************************************************************************/
此篇文章並非小弟原創,原作者已不可考,它是我網管筆記的一部份分享給有需要的人
現在隨著人們的安全意識加強，防火牆一般都被公司企業採用來保障網路的安全，一般的攻擊者在有防火牆的情況下，一般是很難入侵的。
下面談談有防火牆環境下的攻擊和檢測。

一 防火牆基本原理
首先，我們需要瞭解一些基本的防火牆實現原理。防火牆目前主要分包過濾，和狀態檢測的封包過濾，應用層代理防火牆。但是他們的基本實現都是類似的。
│ │---路由器-----網卡│防火牆│網卡│----------內部網路│ │
防火牆一般有兩個以上的網路卡，一個連到外部（router)，另一個是連到內部網路。當打開主機網路轉發功能時，兩個網卡間的網路通訊能直接通過。當有防火牆時，他好比
插在網卡之間，對所有的網路通訊進行控制。
說到訪問控制，這是防火牆的核心了：），防火牆主要通過一個訪問控制表來判斷的，他的形式一般是一連串的如下規則：
1 accept from+ 源位址，埠 to+ 目的地址，埠+ 採取的動作
2 deny ...........（deny就是拒絕。。)
3 nat ............(nat是位址轉換。後面說）
防火牆在網路層（包括以下的煉路層）接受到網路資料包後，就從上面的規則連表一條一條地匹配，如果符合就執行預先安排的動作了！如丟棄包。。。。
但是，不同的防火牆，在判斷攻擊行為時，有實現上的差別。下面結合實現原理說說可能的攻擊。

二 攻擊包過濾防火牆
包過濾防火牆是最簡單的一種了，它在網路層截獲網路資料包，根據防火牆的規則表，來檢測攻擊行為。他根據資料包的源IP位址；目的IP位址；TCP/UDP源埠；TCP/UDP目的
埠來過濾！！很容易受到如下攻擊：
1 ip 欺騙攻擊：
這種攻擊，主要是修改資料包的源，目的地址和埠，模仿一些合法的資料包來騙過防火牆的檢測。如：外部攻擊者，將他的資料報源位址改為內部網路位址，防火牆看到是合
法位址就放行了：）。可是，如果防火牆能結合介面，位址來匹配，這種攻擊就不能成功了：（
2 d.o.s拒絕服務攻擊
簡單的包過濾防火牆不能跟蹤 tcp的狀態，很容易受到拒絕服務攻擊，一旦防火牆受到 d.o.s 攻擊，他可能會忙於處理，而忘記了他自己的過濾功能。：）你就可以饒過了，
不過這樣攻擊還很少的。！
3 分片攻擊
這種攻擊的原理是：在IP的分片包中，所有的分片包用一個分片偏移欄位標誌分片包的順序，但是，只有第一個分片包含有TCP埠號的資訊。當IP分片包通過分組過濾防火牆時
，防火牆只根據第一個分片包的Tcp資訊判斷是否允許通過，而其他後續的分片不作防火牆檢測，直接讓它們通過。
這樣，攻擊者就可以通過先發送第一個合法的IP分片，騙過防火牆的檢測，接著封裝了惡意資料的後續分片包就可以直接穿透防火牆，直接到達內部網路主機，從而威脅網路
和主機的安全。
4 木馬攻擊
對於包過濾防火牆最有效的攻擊就是木馬了，一但你在內部網路安裝了木馬，防火牆基本上是無能為力的。
原因是：包過濾防火牆一般只過濾低埠（1-1024），而高埠他不可能過濾的（因為，一些服務要用到高埠，因此防火牆不能關閉高埠的），所以很多的木馬都在高埠打開等待
，如冰河，subseven等。。。
但是木馬攻擊的前提是必須先上傳，運行木馬，對於簡單的包過濾防火牆來說，是容易做的。這裏不寫這個了。大概就是利用內部網路主機開放的服務漏洞。
早期的防火牆都是這種簡單的包過濾型的，到現在已很少了，不過也有。現在的包過濾採用的是狀態檢測技術，下面談談狀態檢測的包過濾防火牆。

三 攻擊狀態檢測的包過濾
狀態檢測技術最早是checkpoint提出的，在國內的許多防火牆都聲稱實現了狀態檢測技術。
可是：）很多是沒有實現的。到底什麼是狀態檢測？一句話，狀態檢測就是從tcp連接的建立到終止都跟蹤檢測的技術。
原先的包過濾，是拿一個一個單獨的資料包來匹配規則的。可是我們知道，同一個tcp連接，他的資料包是前後關聯的，先是syn包，-》資料包=》fin包。資料包的前後序列號
是相關的。
如果割裂這些關係，單獨的過濾資料包，很容易被精心夠造的攻擊資料包欺騙！！！如nmap的攻擊掃瞄，就有利用syn包，fin包，reset包來探測防火牆後面的網路。！
相反，一個完全的狀態檢測防火牆，他在發起連接就判斷，如果符合規則，就在記憶體登記了這個連接的狀態資訊（位址，port，選項。。）,後續的屬於同一個連接的資料包
，就不需要在檢測了。直接通過。而一些精心夠造的攻擊資料包由於沒有在記憶體登記相應的狀態資訊，都被丟棄了。這樣這些攻擊資料包，就不能饒過防火牆了。
說狀態檢測必須提到動態規則技術。在狀態檢測裏，採用動態規則技術，原先高埠的問題就可以解決了。實現原理是：平時，防火牆可以過濾內部網路的所有埠(1-65535),外
部攻擊者難於發現入侵的切入點，可是為了不影響正常的服務，防火牆一但檢測到服務必須開放高埠時，如（ftp協定，irc等），防火牆在記憶體就可以動態地天加一條規則
打開相關的高埠。等服務完成後，這條規則就又被防火牆刪除。這樣，既保障了安全，又不影響正常服務，速度也快。！
一般來說，完全實現了狀態檢測技術防火牆，智慧性都比較高，一些掃瞄攻擊還能自動的反應，因此，攻擊者要很小心才不會被發現。
但是，也有不少的攻擊手段對付這種防火牆的。
1 協定隧道攻擊
協定隧道的攻擊思想類似與VPN的實現原理，攻擊者將一些惡意的攻擊資料包隱藏在一些協定分組的頭部，從而穿透防火牆系統對內部網路進行攻擊。
例如，許多簡單地允許ICMP回射請求、ICMP回射應答和UDP分組通過的防火牆就容易受到 ICMP 和 UDP 協定隧道的攻擊。Loki和lokid（攻擊的用戶端和服務端）是實施這種攻
擊的有效的工具。在實際攻擊中，攻擊者首先必須設法在內部網路的一個系統上安裝上lokid服務端，而後攻擊者就可以通過loki用戶端將希望遠端執行的攻擊命令（對應IP分
組）嵌入在ICMP或UDP包頭部，再發送給內部網路服務端lokid，由它執行其中的命令，並以同樣的方式返回結果。由於許多防火牆允許ICMP和UDP分組自由出入，因此攻擊者的
惡意資料就能附帶在正常的分組，繞過防火牆的認證，順利地到達攻擊目標主機
下面的命令是用於啟動lokid伺服器程式：
lokid-p-I-vl
loki客戶程式則如下啟動：
loki-d172.29.11.191(攻擊目標主機)-p-I-v1-t3
這樣，lokid和loki就聯合提供了一個穿透防火牆系統訪問目標系統的一個後門。
2 利用FTP-pasv繞過防火牆認證的攻擊FTP-pasv攻擊是針對防火牆實施入侵的重要手段之一。目前很多防火牆不能過濾這種攻擊手段。如CheckPoint的Firewall-1，在監視FTP
伺服器發送給用戶端的包的過程中，它在每個包中尋找"227"這個字串。如果發現這種包，將從中提取目標位址和埠，並對目標位址加以驗證，通過後，將允許建立到該位址的
TCP連接。
攻擊者通過這個特性，可以設法連接受防火牆保護的伺服器和服務。詳細的描述可見
http://www.checkpoint.com/techsupport/alerts/pasvftp.html
3 反彈木馬攻擊
反彈木馬是對付這種防火牆的最有效的方法。攻擊者在內部網路的反彈木馬定時地連接外部攻擊者控制的主機，由於連接是從內部發起的，防火牆（任何的防火牆）都認為是
一個合法的連接，因此基本上防火牆的盲區就是這裏了。防火牆不能區分木馬的連接和合法的連接。
但是這種攻擊的局限是：必須首先安裝這個木馬！！！所有的木馬的第一步都是關鍵！！！！

四 攻擊代理
代理是運行在應用層的防火牆，他實質是啟動兩個連接，一個是客戶到代理，另一個是代理到目的伺服器。
實現上比較簡單，和前面的一樣也是根據規則過濾。由於運行在應用層速度比較慢/1攻擊代理的方法很多。
這裏就以wingate為例，簡單說說了。（太累了）
WinGate是目前應用非常廣泛的一種Windows95/NT代理防火牆軟體，內部用戶可以通過一台安裝有WinGate的主機訪問外部網路，但是它也存在著幾個安全脆弱點。
駭客經常利用這些安全漏洞獲得WinGate的非授權Web、Socks和Telnet的訪問，從而偽裝成WinGate主機的身份對下一個攻擊目標發動攻擊。因此，這種攻擊非常難於被跟蹤和
記錄。
導致WinGate安全漏洞的原因大多數是管理員沒有根據網路的實際情況對WinGate代理防火牆軟體進行合理的設置，只是簡單地從缺省設置安裝完畢後就讓軟體運行，這就給攻
擊者可乘之機。
1 非授權Web訪問
某些WinGate版本（如運行在NT系統下的2.1d版本）在誤配置情況下，允許外部主機完全匿名地訪問網際網路。因此，外部攻擊者就可以利用WinGate主機來對Web伺服器發動各
種Web攻擊（如CGI的漏洞攻擊等），同時由於Web攻擊的所有報文都是從80號Tcp埠穿過的，因此，很難追蹤到攻擊者的來源。
檢測
檢測WinGate主機是否有這種安全漏洞的方法如下：
1) 以一個不會被過濾掉的連接（譬如說撥號連接）連接到網際網路上。
2) 把流覽器的代理伺服器位址指向待測試的WinGate主機。
如果流覽器能訪問到網際網路，則WinGate主機存在著非授權Web訪問漏洞。
2 非授權Socks訪問
在WinGate的缺省配置中，Socks代理（1080號Tcp埠）同樣是存在安全漏洞。與打開的Web代理（80號Tcp埠）一樣，外部攻擊者可以利用Socks代理訪問網際網路。
防範
要防止攻擊WinGate的這個安全脆弱點，管理員可以限制特定服務的捆綁。在多宿主（multihomed）系統上，執行以下步驟以限定如何提供代理服務。
1選擇Socks或WWWProxyServer屬性。
2選擇Bindings標籤。
3按下ConnectionsWillBeAcceptedOnTheFollowingInterfaceOnly按鈕，並指定本WinGate伺服器的內部介面。
非授權Telnet訪問
它是WinGate最具威脅的安全漏洞。通過連接到一個誤配置的WinGate伺服器的Telnet服務，攻擊者可以使用別人的主機隱藏自己的蹤跡，隨意地發動攻擊。
檢測
檢測WinGate主機是否有這種安全漏洞的方法如下：
1使用telnet嘗試連接到一台WinGate伺服器。
[root@happy/tmp]#telnet172.29.11.191
Trying172.29.11.191….
Connectedto172.29.11.191.
Escapecharacteris'^]'.
Wingate>10.50.21.5
2如果接受到如上的回應文本，那就輸入待連接到的網站。
3如果看到了該新系統的登錄提示符，那麼該伺服器是脆弱的。
Connectedtohost10.50.21.5…Connected
SunOS5.6
Login:
對策
防止這種安全脆弱點的方法和防止非授權Socks訪問的方法類似。在WinGate中簡單地限制特定服務的捆綁
就可以解決這個問題。一般來說，在多宿主（multihomed）系統管理員可以通過執行以下步驟來完成：
1選擇TelnetSever屬性。
2選擇Bindings標籤。
3按下ConnectionsWillBeAcceptedOnTheFollowingInterfaceOnly按鈕，並指定本WinGate伺服器的內部介面。


/******************************************************************************/
Bootloader的啟動方式
/******************************************************************************/
Bootloader的啟動
Linux系統是通過Bootloader引導啟動的。一上電，就要執行Bootloader來初始化系統。
系統加電或復位後(即Reset)，所有CPU都會從某個地址開始執行，這是由處理器設計決定的。比如，X86的復位向量在高地址端，ARM處理器在復位時從地址 0x00000000取第一
條指令。嵌入式系統的開發板都要把板上ROM或Flash映射到這個地址。因此，必須把Bootloader程式存儲在相應的 Flash位置。系統加電後，CPU將從這裡開始執行。
主機和目標機之間一般有串口(RS232或是RJ-45)可以連接，Bootloader軟體通常會通過串口來輸入輸出。例如：輸出出錯或者執行結果資訊到串口終端，從串口終端讀取用戶
控制命令等。
Bootloader啟動過程通常是多階段的(Vivi分成兩階段head.S(組合語言寫成)與init/main.c(C語言寫成))，這樣既能提供複雜的功能，又有很好的可移植性。例如：從Flash啟
動的Bootloader多數是兩階段的啟動過程。
大多數Bootloader都包含2種不同的操作模式：本地加載模式和遠端下載模式。這2種操作模式的區別僅對於開發人員才有意義，也就是不同啟動方式的使用。從最終用戶的角
度看，Bootloader的作用就是用來加載作業系統，而並不存在所謂的本地加載模式與遠端下載模式的區別。
因為Bootloader的主要功能是引導作業系統啟動，所以我們詳細討論一下各種啟動方式的特點。
1．網路啟動方式
這種方式開發板不需要配置較大的存儲介質，跟無硬碟的工作站有點類似。但是使用這種啟動方式之前，需要把Bootloader安裝到板上的EPROM或者 Flash中。Bootloader通過
以太網介面遠端下載Linux內核映像或者文件系統。
使用這種方式也有前提條件，就是目標板有串口、以太網介面或者其他連接方式。串口一般可以作為控制台，同時可以用來下載內核影像和RAMDISK文件系統。串口通信(RS232)
傳輸速率過低，不適合用來掛接NFS文件系統。所以以太網介面成為通用的互連設備，一般的開發板都 可以配置10M乙太網介面(RJ-45)。
對於PDA等手持設備來說，以太網的RJ-45介面顯得大了些，而USB介面，特別是USB的迷你介面，尺寸非常小。對於開發的嵌入式系統，可以把USB介面虛擬成以太網介面來通訊
。這種方式在開發主機和開發板兩端都需要驅動程式。
另外，還要在伺服器上配置啟動相關網路服務。Bootloader下載文件一般都使用TFTP網路協定，還可以通過DHCP的方式動態配置IP地址。
2．硬碟啟動方式
傳統的Linux系統運行在桌機或者伺服器上，這些電腦一般都使用BIOS引導，並且使用硬碟作為存儲介質。如果進入BIOS設置功能表，可以探測處理器、記憶體、硬碟等設備，
可以設置BIOS從軟碟片、光碟機或者某顆硬碟啟動。也就是說，BIOS並不直接引導作業系統。那麼在硬碟的主引導區，還需要一個 Bootloader。這個Bootloader可以從硬碟文
件系統中把作業系統引導起來。
Linux傳統上是通過LILO（LInux LOader）引導的，後來又出現了GNU的軟體GRUB（GRand Unified Bootloader）。這2種Bootloader廣泛應用在X86的Linux系統上。你的開發主
機可能就使用了其中一種，熟悉它們有助於配置多種系統引導功能。
LILO軟體工程是由Werner Almesberger創建，專門為引導Linux開發的。現在LILO的維護者是John Coffman，最新版本下載站台：http://lilo.go.dyndns.org。LILO有詳細的
文檔，例如LILO套件中附帶使用手冊和參考手冊。此外，還可以在LDP的「LILO mini-HOWTO」中找到LILO的使用指南。
GRUB 是GNU計劃的主要bootloader。GRUB最初是由Erich Boleyn為GNU Mach作業系統撰寫的引導程式。後來有Gordon Matzigkeit和Okuji Yoshinori接替Erich的工作，繼續維
護和開發GRUB。GRUB的網站http://www.gnu.org/software/grub/上有對套件使用的說明文件，叫作《GRUB manual》。GRUB能夠使用TFTP和BOOTP或者DHCP通過網路啟動，這種
功能對於系統開發過程很有用。
除了傳統的Linux系統上的引導程式以外，還有其他一些引導程式，也可以支援硬碟引導啟動。例如：LoadLin可以從DOS下啟動Linux；還有ROLO、LinuxBIOS，U-Boot也支援這
種功能。
3．Flash啟動方式
大多數嵌入式系統上都使用Flash存儲介質。Flash有很多類型，包括NOR Flash、NAND Flash和其他半導體盤。其中，NOR Flash使用最為普遍。
NOR Flash可以支援隨機訪問，所以程式是可以直接在Flash上執行的。Bootloader一般是存儲在Flash晶片上的。
Bootloader一般放在Flash的底端或者頂端，這要根據處理器的復位向量（Reset）設置。要使Bootloader的入口位於處理器上電執行第一條指令的位置。
接下來分配參數區，這裡可以作為Bootloader的參數保存區域。
再下來內核映像區。Bootloader引導Linux內核，就是要從這個地方把內核映像解壓到RAM中去，然後跳轉到內核映像入口執行。
然後是文件系統區。如果使用Ramdisk文件系統，則需要Bootloader把它解壓到RAM中。
最後還可以分出一些數據區，這要根據實際需要和Flash大小來考慮了。
這些分區是開發者定義的，Bootloader一般直接讀寫對應的偏移地址。到了Linux內核空間，可以配置成MTD設備來訪問Flash分區。
除了NOR Flash，還有NAND Flash、Compact Flash、DiskOnChip等。這些Flash具有晶片價格低，存儲容量大的特點。但是這些晶片一般通過專用控制器的I/O方式來訪問，不
能隨機訪問，因此引導方式跟NOR Flash也不同。在這些晶片上，需要配置專用的引導程式。通常，這種引導程式起始的一段程式就把整個引導程式複製到RAM中運行，從而實
現自行啟動，這跟從硬碟上啟動相似。


/******************************************************************************/
Cross Compiling Python for Embedded Linux       from : http://randomsplat.com/id5-cross-compiling-python-for-embedded-linux.html
/******************************************************************************/
This article details how to cross compile Python for the ARM and PowerPC platforms.  
It should apply equally to other platforms as well, just plug-in the correct cross-compiler.  
The article supports Python versions, 2.6.6 (Thanks to evadeflow), 2.7.2 and 3.1.1, 3.1.2, 3.1.3, 3.2.2.

Firstly, download the Python that you want to use from http://www.python.org/
Unpack the Python package using tar:
$ tar -xvzf Python-2.7.2.tgz

This will create a directory called Python-2.7.2.  Goto the directory:
cd Python-2.7.2
Then run these commands to build the host components:
$ ./configure
$ make python Parser/pgen
$ mv python hostpython
$ mv Parser/pgen Parser/hostpgen
$ make distclean

Download the correct patch for your version of Python:
Python-2.6.6-xcompile.patch
Python-2.7.2-xcompile.patch (With ctypes thanks to Jaux (jaux.net)
Python-3.1.1-xcompile.patch
Python-3.1.2-xcompile.patch
Python-3.1.3-xcompile.patch
Python-3.2.2-xcompile.patch
Then apply the patch:

patch -p1 < Python-2.7.2-xcompile.patch
Then run this (where ~/Python-2.7.2/_install/ is your desired installation path).  Note also that you must replace all instances of the cross compiler 
and the host build system in the lines below.  If you are on an x86_64 machine, then you should use x86_64-linux-gnu as the host.
$ CC=ppc_6xx-gcc CXX=ppc_6xx-g++ AR=ppc_6xx-ar RANLIB=ppc_6xx-ranlib ./configure --host=ppc-linux --build=x86_64-linux-gnu --prefix=/python
$ make HOSTPYTHON=./hostpython HOSTPGEN=./Parser/hostpgen BLDSHARED="ppc_6xx-gcc -shared" CROSS_COMPILE=ppc_6xx- CROSS_COMPILE_TARGET=yes HOSTARCH=ppc-linux BUILDARCH=x86_64-linux-gnu
$ make install HOSTPYTHON=./hostpython BLDSHARED="ppc_6xx-gcc -shared" CROSS_COMPILE=ppc_6xx- CROSS_COMPILE_TARGET=yes prefix=~/Python-2.7.2/_install

This will install all your python binaries and libraries in ~/Python-2.7.2/_install.
Copy the entire _install directory to the device, setup the PATH environment variable to include the path the Python executable and run:
$ python lib/python-2.7/test/test___all__.py
…and hopefully all the tests will run correctly.
To speed up the importing of Python modules on the target, I recommend to zip up the lib directory to make a file called python27.zip.  
This means that we do not have to copy all the Python files to the target, just the one zip file.  This technique might also save space, but that depends 
on your file system.  On the host machine:
$ cd _install/lib/python2.7
zip -r -y python27.zip .
Delete libpythonxxx.a site-packages, lib-dynload, config and anything else you do not need from the python27.zip file.
Copy the _install/bin/python to the /usr/bin directory on the target:
Copy the python27.zip file to the /usr/lib directory on the target:
Create a directory on the target called python2.7 in the /usr/lib directory and copy the following directories to that directory:
./lib/python2.7/config
./lib/python2.7/lib-dynload
./lib/python2.7/site-packages
Your directory structure on the target must be as follows:
/usr/lib # ls
python2.7 python27.zip
/python/lib/python2.7 # ls
config lib-dynload site-packages
Set the PYTHONHOME environment variable to /usr/ and you are ready to run Python on the target.
The above patches are based on Chris Lambacher』s patches for Python 2.5 here:
http://whatschrisdoing.com/blog/2006/10/06/howto-cross-compile-python-25/
Other links and credits:
http://www.ailis.de/~k/archives/19-ARM-cross-compiling-howto.html


/******************************************************************************/
SSDP協定消息    from : http://hi.baidu.com/beisika/blog/item/65a30223f25f525f9822edda.html
/******************************************************************************/
1.1 設備通知消息
在設備加入網路，UPnP發現協定允許設備向控制點廣告它的服務。它使用向一個標準地址和連接埠多址傳送發現消息來實現。控制點在此連接埠上偵聽是否有新服務加入系統
。為了通知所有設備，一個設備為每個其上的嵌入設備和服務發送一系列相應的發現消息。每個消息也包含它表徵設備或服務的特定資訊。
1.1.1 ssdp:alive消息
在設備加入系統時，它採用多播傳送方式發送發現消息，包括告知設備包含的根設備資訊，所有嵌入設備以及它包含的服務。每個發現消息包含四個主要對像：
1. 在NT頭中包含的潛在搜索目標。
2. 在USN頭中包含的復合發現標識
3. 在LOCATION頭中關於設備資訊的URL地址
4. 在CACHE-CONTROL頭中表示的廣告消息的合法存在時間。

對於根設備，存在三種發現消息：
NT                      USN
根設備的UUID            根設備的UUID
設備類型：設備版本      根設備的UUID，設備類型：設備版本
upnp:rootdevice         根設備的UUID，設備類型和upnp:rootdevice

對於根設備，存在兩種發現消息：
NT                      USN
嵌入設備的UUID          嵌入設備的UUID
設備類型：設備版本      嵌入設備的UUID，設備類型和設備版本

對於每個服務：
NT                      USN
服務類型：服務版本      相關設備的UUID，服務類型和服務版本
如果一個根設備有n個嵌入設備，m個嵌入服務，而且包含k個不同的服務類型，這將會發出3 + 2n + k次請求。這些廣告消息像控制點描述了設備的所有資訊。這些消息必須作
為一系列一起發出，發送的順序無關緊要，但是不能對單個消息進行刷新或取消的操作。選擇一個適當的持續期是在最小化網路通訊和最大化設備狀態及時更新之間求得一個
平衡，相對較短的持續時間可以保證控制點在犧牲網路流量的前提下獲得設備的當前狀態；持續期越長可以大大減少設備刷新造成的網路流量。一般而言，設備製造商應該選
擇一個適當的持續時間值。

由於UDP協定是不可信的，設備應該發送多次設備發現消息。而且為了降低控制點無法收到設備或服務廣告消息的可能性，設備應該定期發送它的廣告消息。在設備加入網路時，它必須用NOTIFY方法發送一個多播傳送請求。NOTIFY方法發送的請求沒有回應消息，典型的設備通知消息格式如下：
NOTIFY * HTTP/1.1
HOST: 239.255.255.250:1900CACHE-CONTROL: max-age = seconds until advertisement expires
LOCATION: URL for UPnP description for root device
NT: search target
NTS: ssdp:alive
USN: advertisement UUID

各HTTP協定頭的含義簡介：
HOST            設置為協定保留多播地址和連接埠，必須是239.255.255.250:1900。
CACHE-CONTROL   max-age指定通知消息存活時間，如果超過此時間間隔，控制點可以認為設備不存在
LOCATION        包含根設備描述得URL地址
NT              在此消息中，NT頭必須為服務的服務類型。
NTS             表示通知消息的子類型，必須為ssdp:alive
USN             表示不同服務的統一服務名，它提供了一種標識出相同類型服務的能力。
一個發現響應可以包含0個、1個或者多個服務類型實例。為了做出分辨，每個服務發現響應包括一個USN：根設備的標識。在同樣的設備裡，一個服務類型的多個實例必須用包含USN:ID的服務標識符標識出來。例如，一個燈和電源共用一個開關設備，對於開關服務的查詢可能無法分辨出這是用於燈的。UPNP論壇工作組通過定義適當的設備層次以及設備和服務的類型標識分辨出服務的應用程式場景。這麼做的缺點是需要依賴設備的描述URL。

1.1.2 ssdp:byebye消息
在設備和它的服務將要從網路中卸載時，設備應該對於每個未超期的ssdp:alive消息多播方式傳送ssdp:byebye消息。但如果設備突然從網路卸載，它可能來不及發出這個通知消息。因此，發現消息必須在CACHE-CONTROL包含超時值，如果不重新發出廣告消息，發現消息最後超時並從控制點的緩存中除去。典型的設備卸載消息格式如下：
NOTIFY * HTTP/1.1
HOST: 239.255.255.250:1900NT: search target
NTS: ssdp:byebye
USN: advertisement UUID各HTTP協定頭的含義簡介：
HOST 設置為協定保留多播地址和連接埠，必須是239.255.255.250:1900
NT 在此消息中，NT頭必須為服務的服務類型。
NTS 表示通知消息的子類型，必須為ssdp:alive
USN 表示不同服務的統一服務名，它提供了一種標識出相同類型服務的能力。

1.2 設備查詢消息
當一個控制點加入到網路中時，設備發現過程允許控制點尋找網路上感興趣的設備。發現消息包括設備的一些特定資訊或者某項服務的資訊，例如它的類型、標識符、和指向XML設備描述文檔的指針。從設備獲得響應從本質上說，內容與多址傳送的設備廣播相同，只是採用單址傳送方式。設備查詢通過HTTP協定擴展M-SEARCH方法實現的。典型的設備查詢請求消息格式：
M-SEARCH * HTTP/1.1
HOST: 239.255.255.250:1900
MAN: "ssdp:discover"
MX: seconds to delay response
ST: search target

各HTTP協定頭的含義簡介：
HOST    設置為協定保留多播地址和連接埠，必須是239.255.255.250:1900。
MAN     設置協定查詢的類型，必須是"ssdp:discover"。
MX      設置設備響應最長等待時間，設備響應在0和這個值之間隨機選擇響應延遲的值。這樣可以為控制點響應平衡網路負載。
ST      設置服務查詢的目標，它必須是下面的類型： 
ssdp:all 搜索所有設備和服務 
upnp:rootdevice 僅搜索網路中的根設備 
uuid:device-UUID 查詢UUID標識的設備 
urn:schemas-upnp-org:device:device-Type:version 查詢device-Type字段指定的設備類型，設備類型和版本由UPNP組織定義。 
urn:schemas-upnp-org:service:service-Type:version 查詢service-Type字段指定的服務類型，服務類型和版本由UPNP組織定義。
在設備接收到查詢請求並且查詢類型（ST字段值）與此設備匹配時，設備必須向多播地址239.255.255.250:1900回應響應消息。典型：

HTTP/1.1 200 OK
CACHE-CONTROL: max-age = seconds until advertisement expires
DATE: when reponse was generated
EXT:
LOCATION: URL for UPnP description for root device
SERVER: OS/Version UPNP/1.0 product/version
ST: search target
USN: advertisement UUID

各HTTP協定頭的含義簡介：

CACHE-CONTROL   max-age指定通知消息存活時間，如果超過此時間間隔，控制點可以認為設備不存在
DATE    指定響應生成的時間
EXT     向控制點確認MAN頭域已經被設備理解
LOCATION        包含根設備描述得URL地址
SERVER  飽含作業系統名，版本，產品名和產品版本資訊
ST      內容和意義與查詢請求的相應字段相同
USN     表示不同服務的統一服務名，它提供了一種標識出相同類型服務的能力。
在所有的發現通知中，表示UPnP根設備描述的LOCATION和統一服務名(USN)必須提供。此外，在響應消息中查詢目標頭(ST)必須與LOCATION和統一服務名(USN)一起提供。

專有設備或服務可以不遵循標準的UPNP模版。但如果設備或服務提供UPNP發現、描述、控制和事件過程的所有對象，它的行為就像一個標準的UPNP設備或服務。為了避免命名衝突，使用專有設備命名時除了UPNP域之外必須包含一個前綴"urn:schemas-upnp-org"。在與標準模版相同時，應該使用整數版本號。但如果與標準模版不同，不可以使用設備復用和徽標。

簡單設備發現協定不提供高級的查詢功能，也就是說，不能完成某個具有某種服務的設備這樣的復合查詢。在完成設備或者服務發現之後，控制點可以通過設備或服務描述的URL地址完成更為精確的資訊查詢。

/******************************************************************************/
Upnp Control Point and Device Interaction
/******************************************************************************/
The following diagram shows the sequence of interactions between a control point and device during the UPnP phases described in the previous sections. 
A description of each step follows the diagram. The descriptions indicate the API calls that a control point or device uses and what network packets the 
SDK issues. It should be noted that due to the asynchronous nature of the sequence, the interactions do not necessarily happen in the order shown. The 
control and eventing steps can happen in any order.
                Control point                                                   Device
                                -->     1. M-SEARCH (multicast)         -->
                                <--     2. NOTIFY (UDP unicast)         <--
                                -->     3. HTTP GET description.xml     -->
                                <--     4. 200 OK (XML)                 <--
                                -->     5. SUBSCRIBE                    -->
                                <--     6. 200 OK (SID)                 <--
                                -->     7. HTTP M-POST (SOAP)           -->
                                <--     8. 200 OK (SOAP Response)       <--
                                <--     9. NOTIFY (Event)               <--
1. The control point sends out a search request using the UpnpSearchAsync() API. The SDK for UPnP Devices issues a multicast M-SEARCH SSDP message onto 
the network.
2. If the device matches what the control point is searching for, the SDK issues a unicast UDP NOTIFY response with the URL to the device's description 
document.      The SDK responds automatically from information contained in the device description document registered using UpnpRegisterRootDevice() or 
UpnpRegisterRootDevice2().
3. If the control point wants more information on the device, it calls UpnpDownloadXmlDoc() with the URL with which the device responded. 
UpnpDownloadXmlDoc() downloads the XML description document using a standard HTTP GET request and returns a DOM document representing the device 
description. This step may be repeated to retrieve the service description documents for the device also.
4. The web server contained in the device responds to the request and returns the XML description document.
5. To receive automatic notifications of changes in the device, a control point subscribes to the services in which it is interested. Control points 
subscribe via UpnpSubscribe() or   UpnpSubscribeAsync(). The control point extracts the subscription URL out of the device description document for the 
service or services to which it would like to subscribe, and calls one of the subscribe functions. For each subscribe call, the SDK sends a SUBSCRIBE 
message via HTTP along with a URL to which to send the events.
6. The device acknowledges the subscription request and returns a unique Subscription Identifier (SID).
7. The control point instructs the device to perform some action by changing one of the state variables contained inside the device. The URL to send 
control requests is contained in the device description   document.   The control point calls UpnpSendAction() or UpnpSendActionAsync() to change the 
state. The SDK issues a SOAP action via an HTTP M-POST command.
8. The device changes the state of the internal variable and issues a SOAP response message.
9. The device can notify clients of changes in its state because of either explicit actions, as in step 8, or implicit changes in the device itself. The 
device calls UpnpNotify() or UpnpNotifyExt() to send the updates. The SDK automatically notifies all subscribed control points via a unicast NOTIFY 
message over HTTP.
UPNP只是一組協定


/******************************************************************************/
快速學會vim的方法
/******************************************************************************/
一。游標移動（當然是在普通模式下，不明白？多按幾次Esc就是了。）
左h 右l，上j 下k。（對了就是鍵盤上右手放的基本位置。）
Ctrl+f 向前（下）翻頁（f=forward）
Ctrl+b 向後（上）翻頁（b=backward）
0 是數目字 0 而不是英文字母 o。或是 Home 鍵，移至行首，（含空白字）。
$ 移至行尾，或 End 鍵。要 Shift 鍵。(用不太正確的說法簡單記憶$就是行尾的意思，記住這個 對以後有用)
G 移至檔尾（全文最後一行的第一個非空字元處）(我就假象g=go，大寫g就是go大了，go到最後)
gg 移至檔首（全文第一行之第一個非空白字元處）
:n 移至第 n 行行首。或 nG。(vim裡面可以用數字錶示第幾或者執行幾次命令，大概就這個意思了) n| 移至第 n 個字元(欄)處。注意，要用 Shift 鍵。n 是從頭起算的。
好了，平時最常用的移動命令就這些了。什麼？還不滿足？請立刻離開本文檔，這是給想在5分鐘內快速開始使用vim簡單編輯文檔用的人看的。

二。插入（開始編輯了）
i 在游標所在字元前開始輸入文字(insert)。
a 在游標所在字元後開始輸入文字(append)。
o 在游標所在行下開一新行來輸入文字(open)。
夠了，3個命令已經讓我頭大了。

三。刪除（還是在普通模式下）
x 刪除游標所在處之字元，在中文指一個中文字。
dd 刪除一整行(delete line)。（注意括弧裡的英文單詞，他們可以幫助記憶）
dG 刪至檔尾。（還記得麼G=go大了）
Ok，還是3個命令，其實只要x也能用阿，一直按住試一下：）。

四。取代和還原
r (replace)取代游標所在處之字元。（實驗一下用鍵盤輸入":r !date"）
u 這個太重要了，就是 undo，傳統的 vi 僅支援一次 undo，Vim 及 elvis 就不只了，Vim 幾乎是 沒有限制的。
U 在游標沒離開本行之前，回?退?斜嗉??鰲?br /> Crtl+r 這個也是狠重要，就是 redo 鍵。

五。加上數字
原文狠有意思，摘錄如下：
喔！騷到 Vim 的癢處了，這是 Vim 一個非常騷包的功能，只此一家別無分號（當然同源的 ed，sed 等不在此限）。就是您可以在大部份的指令前加上數目字，代表要處理幾次的意思。以下用實例來說明比較清楚。
5dd 刪除游標所在處（含）起算以下五行內容。妙吧！
5i A 然後按 Ecs，插入五個 A。中文也可以！
5G 游標移至第五行，是從檔首開始起算。和 :5 作用相同。

六。複製（yank）
yy 復?游標所在行整行。或大寫一個 Y。（對照dd）
y$ 復?至行尾。含游標所在處字元。
yG 復?至檔尾。
p (paste)小寫 p 代表貼至游標後（下）。
. 是英文句點.只要是編輯動作（移動游標不算，冒號命令也不算）都可以按英文句點來重複，要重 復幾次都可以。

七。搜尋和替換
/ 在 c-mode 的情形下(按下:就可以了)，按 / 就會在左下方出現一個 /，然後鍵入您要尋找的字 串，按個 Enter 就會開始找。? 和 / 相同，只是 / 是向前（下）找， ? 則是向後（ 上）找。
n 繼續尋找。
N 繼續尋找（反向）。
替換的命令格式為
:[range]s/pattern/string/[c,e,g,i]
range 指的是範圍，1,7 指從第一行至第七行，1,$ 指從第一行至最後一行，也就是整篇文章 ，也可以 % 代表。還記得嗎？ % 是目前編輯的文章，# 是前一次編輯的文章。
pattern 就是要被替換掉的字串，可以用 regexp 來表示。
string 將 pattern 由 string 所取代。
c confirm，每次替換前會詢問。
e 不顯示 error。
g globe，不詢問，整行替換。
i ignore 不分大小寫。
g 大概都是要加的，否則只會替換每一行的第一個符合字串。可以合起來用，如 cgi，表示不分大小 寫，整行替換，替換前要詢問是否替換。
[實例] :%s/Edwin/Edward/g
這樣整篇文章的 Edwin 就會替換成 Edward。
唉這個替換可真麻煩，不過如果你暫時用不著就別管他了。嘿嘿。

八。標記（書籤）功能
這個有用哦。
mx x 代表 26 個小寫英文字母，這樣游標所在處就會被 mark。
`x 回到書?原設定位置。` 是 backward quote，就是 Tab 鍵上面那一個。
1x 回到書?設定行行首。1 是 forward quote，是 Enter 鍵隔壁那一個。
這?舉個簡單的子，請隨便開一個現成的檔案，把游標移到任一個位置，然後按 ma 做個 mark，再按大寫 G 移到檔尾，然後按 1a 看現在什麼地方？
下面移動游標到任意位置，實驗一下y`a,然後換個地方p一下。呵呵如何，不用滑鼠來拖動也可以拷貝粘貼一個塊了吧。
好了就這麼多，5分鐘過去了，最後就是打開文件用:e 。
:q 如本文有修改而沒存檔，會警告，且無法離開。(quit)
:q! ?紋??行薷模?科壤□??br /> :wq 存檔後離開。縱使檔案未曾修改也是會再存一次檔。
:x 也是存檔後離開，但如果檔案沒有修改，則不會做存檔的動作。
ZZ 和 :x 完全一樣，隨您高興用哪一個。
:w 檔名 另存他檔。不加檔名就是寫入原檔。


/******************************************************************************/
使用vim時按了CTRL+S鍵
/******************************************************************************/
在windows下的編輯器使用慣了，用vim編輯好了的文件, 就按了CTRL+S來儲存，結果……vim就停掉了按什麼鍵都不起作用了(杯具)。
以前也碰到這種情況, 解決的辦法是直接關了ssh用戶端軟體, 然後重新連接, 重新打開那個文件.
今天Google了一下, 發現直接按CTRL+Q解決問題.
問題的原因是：CTRL+S表示停止向終端輸出; CTRL+Q恢復向終端輸出。


/******************************************************************************/
MIPS基於DirectFB的GTK+的交叉編譯步驟
/******************************************************************************/
0. 環境變數
export PREFIX=/program/stb225gtkdfb
export LD_LIBRARY_PATH=$PREFIX/lib
export PKG_CONFIG_PATH=$LD_LIBRARY_PATH/pkgconfig
export ARCH=mips
export CROSS_COMPILE=/program/eldk/usr/bin/mips_4KC-
export CC=${CROSS_COMPILE}gcc 
export CXX=${CROSS_COMPILE}g++ 
export AR=${CROSS_COMPILE}ar
export RANLIB=${CROSS_COMPILE}ranlib 
export NM=${CROSS_COMPILE}nm 
export AS=${CROSS_COMPILE}as
export LD=${CROSS_COMPILE}ld
1. libtool-2.2.2
./configure --prefix=$PREFIX --build=i686 --target=mips-linux --host=mips-linux
make
make install
2. libpng-1.2.26 jpeg-6b tiff-3.8.2
./configure --prefix=$PREFIX --build=i686 --target=mips-linux --host=mips-linux
make
make install
(jpeg-6b執行make install-lib)
3. freetype-2.3.4
./configure --prefix=$PREFIX --build=i686 --target=mips-linux --host=mips-linux
make
make install
4. glib-2.16.3(重新開一個終端，不要設置0步驟的環境變數)
echo glib_cv_uscore=no>>mips-linux.cache
echo ac_cv_func_posix_getpwuid_r=yes>>mips-linux.cache
echo ac_cv_func_posix_getgrgid_r=yes>>mips-linux.cache
echo glib_cv_stack_grows=no>>mips-linux.cache
./configure --disable-ccache --cache-file=mips-linux.cache --prefix=/program/stb225gtkdfb --build=i686 \
--target=mips-linux --host=mips-linux --enable-mem-pools
make
make install
5. pkgconfig-0.18
./configure --prefix=$PREFIX --build=i686 --target=mips-linux --host=mips-linux
make
make install
5. libxml2-2.6.32
./configure --prefix=$PREFIX --build=i686 --target=mips-linux --host=mips-linux
make
make install
6. fontconfig-2.5.91
./configure --prefix=$PREFIX --build=i686 --target=mips-linux --host=mips-linux \
--with-arch=mips --enable-libxml2 --with-freetype-config=/program/stb225gtkdfb/bin/freetype-config
make 
make install
7. DirectFB-1.1.1
./configure --prefix=$PREFIX --build=i686 --target=mips-linux --host=mips-linux --disable-x11 --with-gfxdrivers=none "CFLAGS=-I/program/stb225gtkdfb/include"
make
make install
8. atk-1.22.0
./configure --prefix=$PREFIX --build=i686 --target=mips-linux --host=mips-linux --disable-glibtest
make
make install
9. pixman-0.10.0(去掉Makefile的test subdir)
./configure --prefix=$PREFIX --build=i686 --target=mips-linux --host=mips-linux
make
make install
10. cairo-1.6.4 
./configure --prefix=$PREFIX --build=i686 --target=mips-linux --host=mips-linux --enable-directfb --disable-xlib --disable-win32 "LIBS=-L/program/stb225gtkdfb/lib \
-lfontconfig -lfreetype -lxml2"
(須指定LIBS, 否則報錯configure: error: Cairo requires at least one font backend.查看config.log會有詳細出錯資訊)
make
make install
11. pango-1.21.0
./configure --prefix=$PREFIX --build=i686 --target=mips-linux --host=mips-linux --without-x
make
make install
12. gtk+-2.12.9
export CC="/program/eldk/usr/bin/mips_4KC-gcc -I/program/stb225gtkdfb/include"
./configure --prefix=$PREFIX --build=i686 --target=mips-linux --host=mips-linux --with-gdktarget=directfb --without-x \
"LIBS=-L/program/stb225gtkdfb/lib -ljpeg -ltiff -lz -lxml2 -lpixman-1 -lpng12 -ldirect -ldirectfb -lfusion"
make
make install
編譯gtk時，修改configure文件中的參數PANGO_PACKAGES=」pango pangocairo」為PANGO_PACKAGES=」pango pangoft2 pangocairo 」，使得編譯gtk的時候可以鏈接到庫libpangoft2庫。
編譯gtk時，修改configure文件中的參數GLIB_GENMARSHAL=`$PKG_CONFIG variable=glib genmarshal glib-2.0`為GLIB_GENMARSHAL=/usr/bin/glib-genmarshal，和環境變數
export LD_LIBRARY_PATH=/usr/lib:$PREFIX/lib，使得編譯gtk的時候可以運行pc上/usr/bin下的glib-genmarshal而不是交叉編譯下的glib-genmarshal程式。

編譯gtk時，修改文件gtk+-2.12.9/gtk/gtkicontheme.c文件中的builtin_icons為icon_theme_builtin_icons，在函數_gtk_icon_theme_ensure_builtin_cache()中。
export LD_LIBRARY_PATH=$PREFIX/lib
$PREFIX/bin/gtk-demo

/******************************************************************************/
Wireless tools for Linux        ref: http://blog.sina.com.cn/s/blog_73739d500100oz2v.html
/******************************************************************************/
Wireless tools for Linux是一個Linux命令行工具包，用來設置支援Linux Wireless Extension的無線設備。Wireless tools for Linux 和 Linux Wireless Extension 由
 Jean Tourrilhes在維護，由Hewlett-Packard（HP惠普）贊助。
大多數基於Linux內核的作業系統都包含Wireless tools。在許多GNU/Linux 發行版中，都缺省安裝這個工具包，即使是沒有自動安裝，也能很容易地找到其二進位代碼安裝包。
Wireless Extension (WE)是一組通用的API，能在用戶空間對通用Wireless LANs進行配置和統計。它的好處在於僅通過一組單一的工具就能對各種各樣的Wireless LANs進行
管理，不過它們是什麼類型，只要其驅動支援Wireless Extension就行；另一個好處就是不用重啟驅動或Linux就能改變這些參數。
Wireless Tools (WT)就是用來操作Wireless Extensions的工具集，它們使用字元界面，雖然粗糙，但支援所有Wireless Extension。雖然還有很多其他管理
Wireless Extensions的工具，但Wireless Tools是參考實現，它包括以下工具：
        iwconfig：設置基本無線參數
        iwlist：掃瞄、列出頻率，比特率，密鑰等
        iwspy：獲取每個節點鏈接的質量(只能查閱與之相連的節點)
        iwpriv：操作Wireless Extensions 特定驅動
        ifrename： 基於各種靜態標準命名介面
大多數 Linux 發行版本都在其網路初始化腳本中集成Wireless Extension，以便啟動時配置無線介面。他們還將Wireless Tools作為其標準封裝包。
 
iwconfig
iwconfig是Linux Wireless Extensions(LWE)的用戶層配置工具之一。LWE是Linux下對無線網路配置的工具，包括內核的支援、用戶層配置工具和驅動介面的支援三部分。目前很多無線網卡都支援LWE，而且主流的Linux發佈版本，比如Redhat
Linux、Ubuntu Linux都已經帶了這個配置工具。
1、iwconfig
用法: iwconfig interface [essid {NN|on|off}]
[nwid {NN|on|off}]
[mode {managed|ad-hoc|...}
[freq N.NNNN[k|M|G]]
[channel N]
[ap {N|off|auto}]
[sens N]
[nick N]
[rate {N|auto|fixed}]
[rts {N|auto|fixed|off}]
[frag {N|auto|fixed|off}]
[enc {NNNN-NNNN|off}]
[power {period N|timeout N}]
[retry {limit N|lifetime N}]
[txpower N {mW|dBm}]
[commit]
說明：iwconfig是LWE最主要的工具，可以對無線網卡的大部分參數進行配置。
參數：
essid：設置無線網卡的ESSID(Extension Service Set ID)。
通過ESSID來區分不同的無線網路，正常情況下只有相同ESSID的無線站台才可以互相通訊，除非想監聽無線網路。其後的參數為雙引號括起的ESSID字串，或者是any/on/off，如果ESSID字串中包含
any/no/off，則需要在前面加"--"。
示例：
#iwconfig eth0 essid any                   允許任何ESSID，也就是混雜模式
#iwconfig eth0 essid "My Network"          設置ESSID為"My Network"
#iwconfig eth0 essid -- "ANY"              設置ESSID為"ANY"

nwid: Network ID，只用於pre-802.11的無線網卡，802.11網卡利用ESSID和AP的MAC地址來替換nwid，現在基本上不用設置。
示例：
#iwconfig eth0 nwid AB34
#iwconfig eth0 nwid off

nick: Nickname，一些網卡需要設置該參數，但是802.11協定棧、MAC都沒有用到該參數，一般也不用設置。
示例：
#iwconfig eth0 nickname "My Linux Node"

mode：設置無線網卡的工作模式，可以是
Ad-hoc：不帶AP的點對點無線網路
Managed：通過多個AP組成的網路，無線設備可以在這個網路中漫遊
Master：設置該無線網卡為一個AP
Repeater：設置為無線網路中繼設備，可以轉發網路包
Secondary：設置為備份的AP/Repeater
Monitor：監聽模式
Auto：由無線網卡自動選擇工作模式
示例：
#iwconfig eth0 mode Managed
#iwconfig eth0 mode Ad-Hoc

freq/channel：設置無線網卡的工作頻率或者頻道，小於1000的參數被認為是頻道，大於10000的參數被認為是頻率。頻率單位為Hz，可以在數字後面附帶k, M, G來改變數量級，比如 2.4G。頻道從1開始。使用lwlist工具可以查看無線網卡支援的頻率和頻道。參數off/auto指示無線網路自動挑選頻率。
注意：如果是Managed模式，AP會指示無線網卡的工作頻率，因此該設置的參數會被忽略。Ad-hoc模式下只使用該設定的頻率初始無線網路，如果加入已經存在的Ad-hoc網路則會忽略該設置的頻率參數。
示例：
#iwconfig eth0 freq 2422000000
#iwconfig eth0 freq 2.422G
#iwconfig eth0 channel 3
#iwconfig eth0 channel auto

ap：連接到指定的AP或者無線網路，後面的參數可以是AP的MAC地址，也可以是iwlist
scan出來的標識符。如果是Ad-hoc，則連接到一個已經存在的Ad-hoc網路。使用off參數讓無線網卡不改變當前已連接的AP下進入自動模式。any/auto參數，無線網卡自動選擇最好的AP。
注意：如果無線信號低到一定程度，無線網路會進入自動選擇AP模式。
示例：
#iwconfig eth0 ap 00:60:1D:01:23:45
#iwconfig eth0 ap any
#iwconfig eth0 ap off

rate/bit：如果無線網卡支援多速率，則可以通過該命令設置工作的速率。小於1000的參數由具體的無線網卡驅動定義，一般是傳輸速率的索引值，大於1000的為速率，單位bps，可以在數字後面附帶k,
M, G來指定數量級。auto參數讓無線網卡自動選擇速率     fixed參數讓無線網卡不使用自動速率模式。
示例：
#iwconfig eth0 rate 11M
#iwconfig eth0 rate auto
#iwconfig eth0 rate 5.5M auto    //自動選擇5.5M以下的速率

txpower：如果無線網卡支援多發射功率設定，則使用該參數設定發射，單位為dBm，如果指定為W（毫瓦），只轉換公式為：
dBm=30+log(W)。參數on/off可以打開和關閉發射單元，auto和fixed指定無線是否自動選擇發射功率。
示例：
#iwconfig eth0 txpower 15
#iwconfig eth0 txpower 30mW
#iwconfig eth0 txpower auto
#iwconfig eth0 txpower off  

sens：設置接收靈敏度的下限，在該下限之下，無線網卡認為該無線網路信號太差，不同的網卡會採取不同的措施，一些現代的無線網卡會自動選擇新的AP。正的參數為raw
data，直接傳給無線網卡驅動處理，一般認為是百分比。負值表示dBm值。
示例：
#iwconfig eth0 sens -80
#iwconfig eth0 sens 2

retry：設置無線網卡的重傳機制。limit 『value』 指定最大重傳次數；lifetime
『value』指定最長重試時間，單位為秒，可以附帶m和u來指定單位為毫秒和微秒。如果無線網卡支援自動模式，則在limit和lifetime之前還可以附加min和max來指定上下限值。
示例：
#iwconfig eth0 retry 16
#iwconfig eth0 retry lifetime 300m
#iwconfig eth0 retry min limit 8

rts：指定RTS/CTS握手方式，使用RTS/CTS握手會增加額外開銷，但如果無線網路中有隱藏無線節點或者有很多無線節點時可以提高性能。
後面的參數指定一個使用該機制的最小包的大小，如果該值等於最大包大小，則相當於禁止使用該機制。可以使用auto/off/fixed
參數。
示例：
#iwconfig eth0 rts 250
#iwconfig eth0 rts off

frag：設置發送數據包的分片大小。設置分片會增加額外開銷，但在噪聲環境下可以提高數據包的到達率。一般情況下該參數小於最大包大小，有些支援Burst模式的無線網卡可以設置大於最大包大小的值來允許Burst模式。還可以使用auto/fixed/off參數。
示例：
#iwconfig eth0 frag 512
#iwconfig eth0 frag off     

key/enc[ryption]：設置無線網卡使用的加密密鑰，此處為設置WEP模式的加密key，如果要使用WPA，需要wpa_supplicant工具包。密鑰參數可以是 
XXXX-XXXX-XXXX-XXXX 或者 XXXXXXXX
格式的十六進位數值，也可以是s:xxxxxx的ASCII字元。如果在密鑰參數之前加了[index]，則只是設置該索引值對應的密鑰，並不改變當前的密鑰。直接指定[index]值可以設置當前使用哪一個密鑰。指定on/off可以控制是否使用加密模式。open/restricted指定加密模式，取決於不同的無線網卡，大多數無線網卡的open模式不使用加密且允許接收沒有加密的數據包，restricted模式使用加密。可以使用多個key參數，但只有最後一個生效。
WEP密鑰可以是40bit，用10個十六進位數字或者5個ASCII字元表示，也可以是128bit，用26個十六進位數字或者13個ASCII字元表示。
示例：
#iwconfig eth0 key 0123-4567-89
#iwconfig eth0 key [3] 0123-4567-89
#iwconfig eth0 key s:password [2]
#iwconfig eth0 key [2]
#iwconfig eth0 key open
#iwconfig eth0 key off
#iwconfig eth0 key restricted [3] 0123456789
#iwconfig eth0 key 01-23 key 45-67 [4] key [4]

power：設置無線網卡的電源管理模式。period 『value』 指定喚醒的週期，timeout
『value』指定進入休眠的等待時間，這兩個參數之前可以加min和max修飾，這些值的單位為秒，可以附加m和u來指定毫秒和微秒。off/on參數指定是否允許電源管理，all/unicast/multicast
指定允許喚醒的數據包類型。
示例：
#iwconfig eth0 power period 2
#iwconfig eth0 power 500m unicast
#iwconfig eth0 power timeout 300u all
#iwconfig eth0 power off
#iwconfig eth0 power min period 2 power max period 4

commit：提交所有的參數修改給無線網卡驅動。有些無線網卡驅動會先緩存無線網卡參數修，使用這個命令來讓無線網卡的參數修改生效。不過一般不需要使用該命令，因為無線網卡驅動最終都會是參數的修改生效，一般在debug時會用到。
為了方便配置，可以把配置寫到 /etc/network/interfaces中，這樣以後就不用反覆配置了。
auto lo
iface lo inet loopback
auto eth1
iface eth1 inet static
address 192.168.1.3
netmask 255.255.255.0
gateway 192.168.1.1
echo nameserver 192.168.1.1>/etc/resolv.conf
pre-up /sbin/iwconfig eth1 essid "LW HOME LINK"
pre-up /sbin/iwconfig eth1 key s:liwei
auto usb0
iface usb0 inet static
address 192.168.0.200
netmask 255.255.255.0
auto dsl-provider
iface dsl-provider inet ppp
pre-up /sbin/ifconfig eth0 up # line maintained by pppoeconf
provider dsl-provider
auto eth0
iface eth0 inet manual

ifconfig
ifconfig 是一個用來查看、配置、啟用或禁用網路介面的工具，這個工具極為常用的。可以用這個工具來臨時性的配置網卡的IP地址、掩碼、廣播地址、網關等。也可以把它寫入一個文件中（比如/etc/rc.d/rc.local)，這樣系統引導後，會讀取這個文件，為網卡設置IP地址
1.ifconfig 查看網路介面狀態
ifconfig 如果不接任何參數，就會輸出當前網路介面的情況；
[root@linuxchao ~]# ifconfig
eth0 Link encap:Ethernet HWaddr 00:03:0D:27:86:41
inet addr:192.168.1.86 Bcast:192.168.1.255 Mask:255.255.255.0
inet6 addr: fe80::203:dff:fe27:8641/64 Scope:Link
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
RX packets:618 errors:0 dropped:0 overruns:0 frame:0
TX packets:676 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:1000
RX bytes:491238 (479.7 KiB) TX bytes:86286 (84.2 KiB)
Interrupt:5 Base address:0x8c00

lo Link encap:Local Loopback
inet addr:127.0.0.1 Mask:255.0.0.0
inet6 addr: ::1/128 Scope:Host
UP LOOPBACK RUNNING MTU:16436 Metric:1
RX packets:1692 errors:0 dropped:0 overruns:0 frame:0
TX packets:1692 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:3174550 (3.0 MiB) TX bytes:3174550 (3.0 MiB)
解說：
eth0 表示第一塊網卡， 其中 HWaddr 表示網卡的物理地址，可以看到目前這個網卡的物理地址(MAC地址）是 00:03:0D:27:86:41; inet addr 用來表示網卡的IP地址，此網卡的 IP地址是 192.168.1.86，廣播地址， Bcast:192.168.1.255，掩碼地址Mask:255.255.255.0
lo 是表示主機的回壞地址，這個一般是用來測試一個網路程式，但又不想讓局域網或外網的用戶能夠查看，只能在此台主機上運行和查看所用的網路介面。比如把 HTTPD伺服器的指定到回壞地址，在瀏覽器輸入 127.0.0.1 就能看到你所架WEB網站了。但只是您能看得到，局域網的其它主機或用戶無從知道；
如果想知道主機所有網路介面的情況，請用下面的命令；
[root@linuxchao ~]#ifconfig -a
如果想查看某個連接埠，比如查看eth0 的狀態，就可以用下面的方法；
[root@linuxchao ~]#ifconfig eth0

2.ifconfig 配置網路介面
ifconfig 可以用來配置網路介面的IP地址、掩碼、網關、物理地址等；值得一說的是用ifconfig 為網卡指定IP地址，這只是用來調試網路用的，並不會更改系統關於網卡的配置文件。如果您想把網路介面的IP地址固定下來，目前有三個方法：一是通過各個發行和版本專用的工具來修改IP地址；二是直接修改網路介面的配置文件；三是修改特定的文件，加入ifconfig 指令來指定網卡的IP地址，比如在redhat或Fedora中，把ifconfig 的語名寫入/etc/rc.d/rc.local文件中；
ifconfig 配置網路連接埠的方法：
ifconfig 工具配置網路介面的方法是通過指令的參數來達到目的的，我們只說最常用的參數；
ifconfig 網路連接埠 IP地址 hw MAC地址 netmask 掩碼地址 broadcast 廣播地址 [up/down]
＊ 實例一：
比如我們用ifconfig 來調試 eth0網卡的地址
[root@linuxchao ~]#ifconfig eth0 down
[root@linuxchao ~]#ifconfig eth0 192.168.1.99 broadcast 192.168.1.255 netmask 255.255.255.0
[root@linuxchao ~]#ifconfig eth0 up
[root@linuxchao ~]#ifconfig eth0
eth0 Link encap:Ethernet HWaddr 00:03:0D:27:86:41
inet addr:192.168.1.99 Bcast:192.168.1.255 Mask:255.255.255.0
inet6 addr: fe80::203:dff:fe27:8641/64 Scope:Link
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
RX packets:618 errors:0 dropped:0 overruns:0 frame:0
TX packets:676 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:1000
RX bytes:491238 (479.7 KiB) TX bytes:86286 (84.2 KiB)
Interrupt:5 Base address:0x8c00
註解： 上面的例子我們解說一下；
第一行：ifconfig eth0 down 表示如果eth0是激活的，就把它DOWN掉。此命令等同於 ifdown eth0；
第二行：用ifconfig 來配置 eth0的IP地址、廣播地址和網路掩碼；
第三行：用ifconfig eth0 up 來激活eth0 ； 此命令等同於 ifup eth0
第四行：用 ifconfig eth0 來查看 eth0的狀態；
當然您也可以用直接在指令IP地址、網路掩碼、廣播地址的同時，激活網卡；要加up參數；比如下面的例子；
[root@linuxchao ~]#ifconfig eth0 192.168.1.99 broadcast 192.168.1.255 netmask 255.255.255.0 up

＊ 實例二：在這個例子中，我們要學會設置網路IP地址的同時，學會設置網卡的物理地址（MAC地址）；
比如我們設置網卡eth1的IP地址、網路掩碼、廣播地址，物理地址並且激活它；
[root@linuxchao ~]#ifconfig eth1 192.168.1.252 hw ether 04:64:03:00:12:51 netmask 255.255.255.0 broadcast 192.168.1.255 up
或
[root@linuxchao ~]#ifconfig eth1 hw ether 04:64:03:00:12:51
[root@linuxchao ~]#ifconfig eth1 192.168.1.252 netmask 255.255.255.0 broadcast 192.168.1.255 up
其中 hw 後面所接的是網路介面類型， ether表示乙太網， 同時也支援 ax25 、ARCnet、netrom等，詳情請查看 man ifconfig ；

3.如何用ifconfig 來配置虛擬網路介面
有時我們為了滿足不同的需要還需要配置虛擬網路介面，比如我們用不同的IP地址來架運行多個HTTPD伺服器，就要用到虛擬地址；這樣就省卻了同一個IP地址，如果開設兩個的HTTPD伺服器時，要指定連接埠號。
虛擬網路介面指的是為一個網路介面指定多個IP地址，虛擬介面是這樣的 eth0:0 、 eth0:1、eth0:2 ... .. eth1N。當然您為eth1 指定多個IP地址，也就是 eth1:0、eth1:1、eth1:2 ... ...以此類推；
其實用ifconfig 為一個網卡配置多個IP地址，就用前面我們所說的ifconfig的用法，這個比較簡單；看下面的例子；
[root@linuxchao ~]#ifconfig eth1:0 192.168.1.251 hw ether 04:64:03:00:12:51 netmask 255.255.255.0 broadcast 192.168.1.255 up
或
[root@linuxchao ~]#ifconfig eth1 hw ether 04:64:03:00:12:51
[root@linuxchao ~]#ifconfig eth1 192.168.1.251 netmask 255.255.255.0 broadcast 192.168.1.255 up
注意：指定時，要為每個虛擬網卡指定不同的物理地址；
在 Redhat/Fedora 或與Redhat/Fedora類似的系統，您可以把配置網路IP地址、廣播地址、掩碼地址、物理地址以及激活網路介面同時放在一個句子中，寫入/etc/rc.d/rc.local中。比如下面的例子；
ifconfig eth1:0 192.168.1.250 hw ether 00:11:00:33:11:44 netmask 255.255.255.0 broadcast 192.168.1.255 up
ifconfig eth1:1 192.168.1.249 hw ether 00:11:00:33:11:55 netmask 255.255.255.0 broadcast 192.168.1.255 up
解說：上面是為eth1的網路介面，設置了兩個虛擬介面；每個介面都有自己的物理地址、IP地址... ...

4.如何用ifconfig 來激活和終止網路介面的連接
激活和終止網路介面的用 ifconfig 命令，後面接網路介面，然後加上 down或up參數，就可以禁止或激活相應的網路介面了。當然也可以用專用工具ifup和ifdown 工具；
[root@linuxchao ~]#ifconfig eth0 down
[root@linuxchao ~]#ifconfig eth0 up
[root@linuxchao ~]#ifup eth0
[root@linuxchao ~]#ifdown eth0
對於激活其它類型的網路介面也是如此，比如 ppp0，wlan0等；不過只是對指定IP的網卡有效。
注意：對DHCP自動分配的IP，還得由各個發行版自帶的網路工具來激活；當然得安裝dhcp用戶端；這個您我們應該明白；
比如Redhat/Fedora
[root@linuxchao ~]#/etc/init.d/network start
Slackware 發行版；
[root@linuxchao ~]#/etc/rc.d/rc.inet1

iwlist
iwlist主要用來顯示無線網卡的一些附加資訊,
useage: iwlist [interface] options
scanning 掃瞄一定範圍內的無線接入點和Ad-Hoc單元資訊，包括ESSID，信號質量，頻段以及無線模式等
frequency 頻率
channel顯示設備支援的頻道及當前所在的頻道
rate/bitrate 設備支援的速率
encryption 加密
key 密鑰
power 電源
txpower 發送功率
retry 重傳機制
ap 本地無線接入點及信號質量
peers 直連
event 設備支援的無線事件
auth 當前設置的WPA認證參數
wpa 羅列設備上設置的所有WPA加密密鑰
modu 羅列設備支援的調製模式及當前開啟的調製模式

iwpriv
iwpriv：操作Wireless Extensions 特定驅動。通過iwpriv，我們可以得到AP的一些參數設置，也可以設置自己的WIFI參數。
[root@root- /]#iwpriv
    mlan0     Available private ioctls :
          extscan          (8BFA) : set   0 int   & get   2 char
          hostcmd          (8BE4) : set 2047 byte  & get 2047 byte
          arpfilter        (8BE6) : set 2047 byte  & get 2047 byte
          regrdwr          (8BE3) : set 256 char  & get 256 char
          sdcmd52rw        (8BFE) : set   7 byte  & get   7 byte
          sdcmd53rw        (8BFF) : set   0 char  & get   0 char
          setgetconf       (8BEA) : set 2000 byte  & get 2000 byte
          getcis           (8BE1) : set   0       & get 512 byte
          scantype         (8BEB) : set   8 char  & get   8 char
          deauth           (0001) : set   1 addr  & get   0
          getNF            (0001) : set   1 int   & get   1 int
          getRSSI          (0002) : set   1 int   & get   1 int
          bgscan           (0004) : set   1 int   & get   1 int
          enable11d        (0005) : set   1 int   & get   1 int
          adhocgrate       (0006) : set   1 int   & get   1 int
          sdioclock        (0007) : set   1 int   & get   1 int
          wmm              (0008) : set   1 int   & get   1 int
          uapsdnullgen     (000A) : set   1 int   & get   1 int
          setcoalescing    (000B) : set   1 int   & get   1 int
          adhocgprot       (000C) : set   1 int   & get   1 int
          disable_chsw     (000F) : set   1 int   & get   1 int
          setpowercons     (0001) : set   1 int   & get   1 int
          wmm_qosinfo      (0002) : set   1 int   & get   1 int
          lolisteninter    (0003) : set   1 int   & get   1 int
          psnullinterval   (0005) : set   1 int   & get   1 int
          bcnmisto         (0006) : set   1 int   & get   1 int
          ldocfg           (0008) : set   1 int   & get   1 int
          rtsctsctrl       (000F) : set   1 int   & get   1 int
          moduletype       (000B) : set   1 int   & get   1 int
          autodeepsleep    (000C) : set   1 int   & get   1 int
          enhanceps        (000D) : set   1 int   & get   1 int
          wakeupmt         (000E) : set   1 int   & get   1 int
          setrxant         (0001) : set   1 int   & get   0
          settxant         (0002) : set   1 int   & get   0
          authalgs         (0004) : set   1 int   & get   0
          encryptionmode   (0005) : set   1 int   & get   0
          setregioncode    (0006) : set   1 int   & get   0
          setlisteninter   (0007) : set   1 int   & get   0
          setmultipledtim  (0008) : set   1 int   & get   0
          setbcnavg        (0009) : set   1 int   & get   0
          setdataavg       (000A) : set   1 int   & get   0
          associate        (000B) : set   1 int   & get   0
          getregioncode    (0001) : set   0       & get   1 int
          getlisteninter   (0002) : set   0       & get   1 int
          getmultipledtim  (0003) : set   0       & get   1 int
          gettxrate        (0004) : set   0       & get   1 int
          getbcnavg        (0005) : set   0       & get   1 int
          getdataavg       (0006) : set   0       & get   1 int
          getauthtype      (0007) : set   0       & get   1 int
          getrsnmode       (0008) : set   0       & get   1 int
          act_paircipher   (0009) : set   0       & get   1 int
          act_groupcipher  (000A) : set   0       & get   1 int
          getdtim          (000B) : set   0       & get   1 int
          getrxant         (0001) : set   0       & get  12 char
          gettxant         (0002) : set   0       & get  12 char
          gettsf           (0003) : set   0       & get  12 char
          wpssession       (0004) : set   0       & get  12 char
          deepsleep        (8BFB) : set   1 char  & get   6 char
          adhocstop        (0004) : set   0       & get   0
          radioon          (0001) : set   0       & get   0
          radiooff         (0002) : set   0       & get   0
          rmaeskey         (0003) : set   0       & get   0
          crypto_test      (0006) : set   0       & get   0
          reasso-on        (0007) : set   0       & get   0
          reasso-off       (0008) : set   0       & get   0
          wlanidle-on      (0009) : set   0       & get   0
          wlanidle-off     (000A) : set   0       & get   0
          softreset        (000C) : set   0       & get   0
          sleepparams      (0002) : set  64 char  & get  64 char
          requesttpc       (0004) : set  64 char  & get  64 char
          powercap         (0005) : set  64 char  & get  64 char
          measreq          (000C) : set  64 char  & get  64 char
          bca-ts           (0003) : set  64 char  & get  64 char
          scanmode         (0006) : set  64 char  & get  64 char
          getadhocstatus   (0009) : set  64 char  & get  64 char
          setgenie         (000A) : set  64 char  & get  64 char
          getgenie         (000B) : set  64 char  & get  64 char
          qstatus          (000D) : set  64 char  & get  64 char
          ts_status        (000E) : set  64 char  & get  64 char
          setaeskey        (0001) : set  32 char  & get   0
          getaeskey        (0001) : set   1 int   & get 128 char
          version          (0002) : set   1 int   & get 128 char
          verext           (0003) : set   1 int   & get 128 char
          setwpaie         (8BE0) : set  24 char  & get   0
          setband          (0001) : set  10 char  & get   0
          setadhocch       (0002) : set  10 char  & get   0
          chanswann        (0003) : set  10 char  & get   0
          getband          (0001) : set   0       & get  10 char
          getadhocch       (0002) : set   0       & get  10 char
          getlog           (8BE9) : set   0       & get 512 char
          tpccfg           (0001) : set  16 int   & get  16 int
          scanprobes       (0006) : set  16 int   & get  16 int
          ledgpio          (0005) : set  16 int   & get  16 int
          sleeppd          (0007) : set  16 int   & get  16 int
          rateadapt        (0008) : set  16 int   & get  16 int
          getSNR           (0009) : set  16 int   & get  16 int
          getrate          (000A) : set  16 int   & get  16 int
          getrxinfo        (000B) : set  16 int   & get  16 int
          atimwindow       (000C) : set  16 int   & get  16 int
          bcninterval      (000D) : set  16 int   & get  16 int
          sdiopullctrl     (000E) : set  16 int   & get  16 int
          scantime         (000F) : set  16 int   & get  16 int
          sysclock         (0010) : set  16 int   & get  16 int
          txcontrol        (0012) : set  16 int   & get  16 int
          hscfg            (0014) : set  16 int   & get  16 int
          hssetpara        (0015) : set  16 int   & get  16 int
          inactoext        (0016) : set  16 int   & get  16 int
          dbgscfg          (0017) : set  16 int   & get  16 int
          drvdbg           (0018) : set  16 int   & get  16 int
          drvdelaymax      (001A) : set  16 int   & get  16 int
          intfctrl         (001B) : set  16 int   & get  16 int
          setquietie       (001C) : set  16 int   & get  16 int
          ctspowerctrl     (001E) : set  16 int   & get  16 int
          psmode           (001F) : set  16 int   & get  16 int
          setuserscan      (0001) : set 2000 byte  & get 2000 byte
          getscantable     (0002) : set 2000 byte  & get 2000 byte
          setmrvltlv       (0003) : set 2000 byte  & get 2000 byte
          getassocrsp      (0004) : set 2000 byte  & get 2000 byte
          addts            (0005) : set 2000 byte  & get 2000 byte
          delts            (0006) : set 2000 byte  & get 2000 byte
          qconfig          (0007) : set 2000 byte  & get 2000 byte
          qstats           (0008) : set 2000 byte  & get 2000 byte
          txpktstats       (000C) : set 2000 byte  & get 2000 byte
          getcfptable      (0009) : set 2000 byte  & get 2000 byte
          mefcfg           (000A) : set 2000 byte  & get 2000 byte
          getmem           (000B) : set 2000 byte  & get 2000 byte
       [root@root- /]#iwpriv mlan0 getband
       mlan0     getband:bg


/******************************************************************************/
// UPNP example  ref: http://hi.baidu.com/xiongli880612/blog/item/fe803204488bb4cc277fb5d9.html
/******************************************************************************/
（—）添加linux upnp AV(advertise)支援
添加upnp 廣播支援，而不是upnp多媒體伺服器：
詳情參閱linux-igd官方文檔 http://linux-igd.sourceforge.net/documentation.php
linuxigd和libupnp
linuxigd編譯需要libupnp（前身叫upnpsdk）庫的支援，libupnp.so。

# tar xzvf libupnp-1.3.1.tar.gz
#./configure --prefix=/usr
# make && make install

# tar xzvf linuxigd-1.0.tar.gz
# make && make install
生成/usr/sbin下生成upnpd。

移植：
拷貝/usr/sbin/upnpd及其依賴庫，/etc/linuxigd/*，/etc/upnpd.conf，一切準備就緒。
接下來怎麼使用upnpd， 查看linuxigd源碼包下的文檔。告訴你如何使用和如何調試。
# route add -net 239.0.0.0 netmask 255.0.0.0 eth0
# upnpd -f eth0 eth0     //前台啟動
upnpd[1078]: AddPortMap: DevUDN: uuid:75802409-bccb-40e7-8e6c-fa095ecce13e ServiceID: urn:upnp-org:serviceId:WANIPConn1 RemoteHost: (null) Prot: TCP ExtPort: 51413 Int: 10.18.13.83.51413
upnpd[1078]: AddPortMap: DevUDN: uuid:75802409-bccb-40e7-8e6c-fa095ecce13e ServiceID: urn:upnp-org:serviceId:WANIPConn1 RemoteHost: (null) Prot: UDP ExtPort: 51413 Int: 10.18.13.83.51413
upnpd[1078]: DeletePortMap: Proto:TCP Port:51413
upnpd[1078]: DeletePortMap: Proto:UDP Port:51413
打開一個支援UPnP協定的軟體（BT、電驢、MSN Manager）,並新建一個下載任務
以BT為例：
AddPortMap表示PT進程已經開始，DeletePortMap代表PT進程已經結束
# upnpd eth0 eth0  //daemon進程
發現upnpd在後台運行時，需要啟動syslogd進程，否則剛啟動就被停掉了！！

【upnpd.conf】
# To change the interfaces used edit:
#   /etc/sysconfig/upnpd
#
# The full path and name of the iptables executable,
# (enclosed in quotes).
#
iptables_location = "/sbin/iptables"

#
# Daemon debug level. Messages are logged via syslog to debug.
# 0 - no debug messages
# 1 - log errors
# 2 - log errors and basic info
# 3 - log errors and verbose info
# default = 0
debug_mode = 2

#
# Should the daemon insert rules in the forward chain
# This is necessary if your firewall has a drop or reject
# policy in your forward chain.
# allowed values: yes,no
# default = no
insert_forward_rules = yes

#
# The name of the chain to put the forward rules in.
# This directive is only activ if "insert_forward_rules = yes"
# above.
# allowed values: a-z, A-Z, _, -
# default = FORWARD
#
forward_chain_name = FORWARD

#
# The name of the chain to put prerouting rules in.
# allowed values: a-z, A-Z, _, -
# default = PREROUTING
prerouting_chain_name = PREROUTING

#
# The internet line upstream bit rate reported from
# the daemon. Value in bits per second
# default = 0
upstream_bitrate = 512000

#
# The internet line downstream bit rate reported from
# the daemon. Value in bits per second
# default = 0
downstream_bitrate = 512000

#
# The default duration of port mappings, used when the client
# doesn't specify a duration.
# Can have the following values:
# 0 - no default duration specified
# seconds | HH:MM - duration from the time of addition
# @seconds | @HH:MM - expire mapping at the specified time of day
# default = 0
duration = 86400 # One day

# The name of the igd device xml description document
# default = gatedesc.xml
description_document_name = gatedesc.xml

# The path to the xml documents
# Do not include the trailing "/"
# default = /etc/linuxigd
# WARNING! The make install does put the xml files
# in /etc/linuxigd, if you change this variable
# you have to make sure the xml docs are in the
# right place
xml_document_path = /etc/linuxigd      //web虛擬目錄

【XML 文檔位置】
# ls /etc/linuxigd/
gateconnSCPD.xml  gatedesc.xml gateicfgSCPD.xml  index.html
# cat  gatedesc.xml //在網路上傳輸XML格式文檔來描述設備資訊
<?xml version="1.0"?>
<root xmlns="urn:schemas-upnp-org:device-1-0">
        <specVersion>
                <major>1</major>
                <minor>0</minor>
        </specVersion>
 <device>
  <UDN>uuid:7557463f-266d-49a6-896d-3f94a068c6c7</UDN>
  <friendlyName>F4-NAS</friendlyName>                   //廣播名稱
  <manufacturer>Terra Master</manufacturer>
  <manufacturerURL>http://www.noontec.com/</manufacturerURL>
  <modelName>F4-NAS</modelName>
  <modelNumber>0.0.1</modelNumber>
  <modelURL>/</modelURL>
  <serialNumber>Q113B08966</serialNumber>
  <presentationURL>/</presentationURL>   //設備的URL位置,也就是配置文件中的虛擬目錄
  <deviceType>urn:schemas-upnp-org:device:NAS:1</deviceType>
  <deviceURL>/</deviceURL>

  <serviceList>
   <service>
    <serviceType>urn:schemas-upnp-org:service:ConnectionManager:1</serviceType>
    <serviceId>urn:upnp-org:serviceId:ConnectionManager</serviceId>
    <SCPDURL>/ConnectionManager.xml</SCPDURL>
    <eventSubURL>/ConnectionManager/Event</eventSubURL>
    <controlURL>/ConnectionManager/Control</controlURL>
   </service>

   <service>
    <serviceType>urn:schemas-upnp-org:service:ContentDirectory:1</serviceType>
    <serviceId>urn:upnp-org:serviceId:ContentDirectory</serviceId>
    <SCPDURL>/ContentDirectory.xml</SCPDURL>
    <eventSubURL>/ContentDirectory/Event</eventSubURL>
    <controlURL>/ContentDirectory/Control</controlURL>
   </service>
  </serviceList>
  </device>
# cat index.html  //索引文件,這裡指向web伺服器的索引位置,貌似這就是所謂的upnp連接埠映射
<html><head><script language="JavaScript">window.location = 'http://'+ parent.location.hostname + ':8080/';</script> </head><body></body></html>

【啟動腳本】
DAEMON=/usr/app/ushare/bin/ushare
NAME=ushare
DESC="uShare UPnP A/V & DLNA Media Server"
PIDFILE=/var/run/ushare.pid
CONFIGFILE=/etc/ushare.conf
PORT=$2
HOSTNAME=`hostname`
RETURN_VALUE=
INTERFACE=
ETH0STATUS=
ETH1STATUS=

check_interface()
{
        #INTERFACE=`/etc/init.d/nas/func_common && ifconfig |awk '/Link encap/{print $1}'|awk '$0 !~/lo/`
        [ -d "/sys/class/net/eth0" ] && ETH0STATUS=`/bin/cat /sys/class/net/eth0/operstate`
        [ -d "/sys/class/net/eth1" ] && ETH1STATUS=`/bin/cat /sys/class/net/eth1/operstate`

        if [ "$ETH0STATUS" = "up" ]; then
                INTERFACE=eth0
        else 
                if [ "$ETH1STATUS" = "up" ]; then
                        INTERFACE=eth1
                fi
        fi

        sed -i "/^USHARE_IFACE/c\\USHARE_IFACE=$INTERFACE" $CONFIGFILE
}

[ -x "$DAEMON" ] || exit 0

checkpid() {
  [ -e $PIDFILE ] || touch $PIDFILE
}

check_shares() {
  if [ -r $CONFIGFILE ]; then
        #Note: CONFIGFILE should Accord with variable defined standards
        . $CONFIGFILE
    if [ -n $USHARE_DIR ] && [ -d $USHARE_DIR ];then
        RETURN_VALUE=0
    else
        RETURN_VALUE=1
    fi
  fi
}

check_interface

case "$1" in
  start)
    echo "Starting $DESC: $NAME"
    check_shares
    if [ $RETURN_VALUE == 1 ]; then
      echo  "No shares avalaible ..."
    else
        sed -i "/^USHARE_NAME=/c\\USHARE_NAME=\"Upnp Media Server[$HOSTNAME]\"" $CONFIGFILE
        if [ -z $PORT ]; then
                $DAEMON -f $CONFIGFILE -D
        else
                $DAEMON -p $PORT -f $CONFIGFILE -D
        fi
    fi
  ;;
  stop)
        echo  "Stopping $DESC: $NAME"
        killall -9 ushare 2>/dev/null
  ;;
  restart)
    $0 stop
    $0 start $PORT
  ;;
  *)
    echo  "Usage: $0 {start|stop|restart}"
    exit 1
  ;;
esac
 如果一切正常的話，你就可以在網路鄰居看到名為「F4-NAS」的upnp的圖示了，雙擊被重定向到index.html頁面。

（二）架設Linux upnp多媒體伺服器
upnp伺服器有好多種，見：http://en.wikipedia.org/wiki/List_of_UPnP_AV_media_servers_and_clients#Software
Upnp多媒體伺服器移植(upnp media server很多,如ushare(輕量級）、twonky server，mediatomb等)
【twonky server】收費軟體
官方：www.twonkyvison.de下載6.0.34版本twonkymedia-i386-glibc-2.2.5-6.0.34.zip
官方：www.twonkyvison.de下載5.1.6版本twonkymedia-i386-glibc-2.2.5-5.1.65.zip
解壓只要拷貝文件即可，不需要任何編譯。
詳情見源碼包的Linux-HowTo.txt

【ushare】
# tar xzvf ushare-1.1a.tar.gz
# cd ushare-1.1a
# ./configure --prefix=/usr/ushare
# make && make install
啟動ushare
# /usr/ushare/bin/ushare -f /etc/ushare/conf -D

交叉編譯
# export CFLAGS="-I/usr/local/cross-build/rootfs/usr/include -I/usr/local/cross-build/cross/include"
# export LDFLAGS="-L/usr/local/cross-build/rootfs/lib -L/usr/local/cross-build/rootfs/usr/lib"
# ./configure --help
# ./configure --prefix=/usr/app/ushare --cross-compile --cross-prefix=/usr/local/cross-build/cross/bin/arm-mv5sft-linux-gnueabi- --with-libupnp-dir=/usr/local/cross-build/rootfs/usr/lib
Checking for compiler available...
Checking for locales ...
Checking for ifaddrs ...
Checking for langinfo ...
Checking for iconv ...
Checking for libixml ...
Error, can't find libixml !
# make
cds.c:589: warning: incompatible implicit declaration of built-in function 'strlen'
cds.c:591: warning: implicit declaration of function 'strncpy'
cds.c:591: warning: incompatible implicit declaration of built-in function 'strncpy'
cds.c:593: warning: incompatible implicit declaration of built-in function 'strchr'
cds.c:602: warning: incompatible implicit declaration of built-in function 'strncpy'
cds.c:604: warning: incompatible implicit declaration of built-in function 'strchr'
cds.c:613: warning: incompatible implicit declaration of built-in function 'strncpy'
cds.c:615: warning: incompatible implicit declaration of built-in function 'strchr'
cds.c:624: warning: implicit declaration of function 'strstr'
cds.c:624: warning: incompatible implicit declaration of built-in function 'strstr'
cds.c: In function 'cds_search_directchildren':
cds.c:790: warning: incompatible implicit declaration of built-in function 'sprintf'
cds.c: At top level:
http.h:28: error: storage size of 'virtual_dir_callbacks' isn't known
這裡我換個低點的版本libupnp-1.4.2
# make
presentation.c:27:20: error: config.h: No such file or directory
presentation.c: In function 'build_presentation_page':
presentation.c:163: error: 'VERSION' undeclared (first use in this function)
presentation.c:163: error: (Each undeclared identifier is reported only once
presentation.c:163: error: for each function it appears in.)
解決方法：
# cd  ushare-1.1a
# cp config.h src/
# make
arm-mv5sft-linux-gnueabi-gcc: /usr/local/cross-build/build_dir/ushare-1.1a: linker input file unused because linking not done
/usr/local/cross-build/cross/bin/arm-mv5sft-linux-gnueabi-gcc cds.o cms.o msr.o http.o presentation.o metadata.o mime.o services.o buffer.o util_iconv.o content.o cfgparser.o trace.o redblack.o osdep.o ctrl_telnet.o ushare.o -L/usr/local/cross-build/rootfs/lib -L/usr/local/cross-build/rootfs/usr/lib -lixml -lthreadutil -lpthread -lupnp -L/usr/local/cross-build/rootfs/usr/lib -o ushare
util_iconv.o: In function `iconv_convert':
util_iconv.c:(.text+0x48): undefined reference to `libiconv'
util_iconv.c:(.text+0xc8): undefined reference to `libiconv'
util_iconv.c:(.text+0x114): undefined reference to `libiconv'
util_iconv.c:(.text+0x164): undefined reference to `libiconv'
util_iconv.c:(.text+0x1a4): undefined reference to `libiconv'
util_iconv.o:util_iconv.c:(.text+0x1ec): more undefined references to `libiconv' follow
util_iconv.o: In function `finish_iconv':
util_iconv.c:(.text+0x268): undefined reference to `libiconv_close'
util_iconv.o: In function `setup_iconv':
util_iconv.c:(.text+0x2c8): undefined reference to `libiconv_open'
collect2: ld returned 1 exit status
make[1]: *** [ushare] 錯誤 1
手動編譯，加上"-liconv"選項
# cd src/
#/usr/local/cross-build/cross/bin/arm-mv5sft-linux-gnueabi-gcc cds.o cms.o msr.o http.o presentation.o metadata.o mime.o services.o buffer.o util_iconv.o content.o cfgparser.o trace.o redblack.o osdep.o ctrl_telnet.o ushare.o -L/usr/local/cross-build/rootfs/lib -L/usr/local/cross-build/rootfs/usr/lib -lixml -lthreadutil -lpthread -lupnp -liconv -L/usr/local/cross-build/rootfs/usr/lib -o ushare

【mediatomb】
c++語言編寫的,
http://www.jpkessler.de/mybookupnp/index.html
http://mediatomb.cc/pages/documentation
一，configure前準備
修改configure：
#define malloc rpl_malloc
#define realloc rpl_realloc把這部分註釋掉.
或者configure加上「--disable-rpl-malloc」
二，configure
export CXX=...
export CXXFLAGS=...
export CFLAGS=...
#./configure --prefix=/usr/app/mediatomb --disable-rpl-malloc--host=arm-mv5sft-linux-gnueabi --with-expat-h=/usr/local/cross-build/rootfs/usr/app/apache/include --with-expat-libs=/usr/local/cross-build/rootfs/usr/app/apache/lib  //用到apache的庫
三，make
# make && make install
warning: libssl.so.1.0.0, needed by /usr/local/cross-build/rootfs/usr/lib/libcurl.so, not found (try using -rpath or -rpath-link)
warning: libcrypto.so.1.0.0, needed by /usr/local/cross-build/rootfs/usr/lib/libcurl.so, not found (try using -rpath or -rpath-link)
/usr/local/cross-build/rootfs/usr/lib/libcurl.so: undefined reference to `SSL_connect'
/usr/local/cross-build/rootfs/usr/lib/libcurl.so: undefined reference to `X509_check_issued'
/usr/local/cross-build/rootfs/usr/lib/libcurl.so: undefined reference to `BIO_free'
/usr/local/cross-build/rootfs/usr/lib/libcurl.so: undefined reference to `BIO_s_mem'
/usr/local/cross-build/rootfs/usr/lib/libcurl.so: undefined reference to `TLSv1_client_method'
/usr/local/cross-build/rootfs/usr/lib/libcurl.so: undefined reference to `BIO_ctrl'
手動編譯，添加-lssl -lcrypto項
#cd  build
/usr/local/cross-build/cross/bin/arm-mv5sft-linux-gnueabi-g++ -I../src -I../tombupnp/ixml/inc -I../tombupnp/threadutil/inc -I../tombupnp/upnp/inc -I.. -pthread -I/usr/local/cross-build/rootfs/usr/app/apache/include   -g -O2  -L/usr/local/cross-build/rootfs/usr/lib  -lrt   -o mediatomb mediatomb-main.o libmediatomb.a ../tombupnp/build/libtombupnp.a -L/usr/local/cross-build/rootfs/usr/app/apache/lib -L/usr/local/cross-build/rootfs/usr/lib -lsqlite3 -lz -lrt -pthread -lexpat -lcurl -lz -lz -lssl -lcrypto
四，啟動mediatomb
# mediatomb --home=/etc //自動創建/etc/.mediatomb，並生成配置文件config.xml
# mediatomb --home=/etc --config=/etc/.mediatomb/config.xml --add /mnt/media
2012-02-28 15:37:56 WARNING: Sqlite3 database seems to be corrupt or doesn't exist yet.
mediatomb.db表是空的,如何創建呢？
# cat /usr/app/mediatomb/share/mediatomb/sqlite3.sql | sqlite3 /etc/.mediatomb/mediatomb.db
# mediatomb --home=/etc --config=/etc/.mediatomb/config.xml --add /mnt/media    
MediaTomb UPnP Server version 0.12.1 - http://mediatomb.cc/
===============================================================================
Copyright 2005-2010 Gena Batsyan, Sergey Bostandzhyan, Leonhard Wimmer.
MediaTomb is free software, covered by the GNU General Public License version 2
2012-02-28 15:41:11    INFO: Loading configuration from: /etc/.mediatomb/config.xml
2012-02-28 15:41:11    INFO: Checking configuration...
2012-02-28 15:41:11    INFO: Setting filesystem import charset to UTF-8
2012-02-28 15:41:11    INFO: Setting metadata import charset to UTF-8
2012-02-28 15:41:11    INFO: Setting playlist charset to UTF-8
2012-02-28 15:41:11    INFO: Configuration check succeeded.
2012-02-28 15:41:11    INFO: Initialized port: 49153
2012-02-28 15:41:11    INFO: Server bound to: 10.18.13.11
2012-02-28 15:41:12    INFO: MediaTomb Web UI can be reached by following this link:
2012-02-28 15:41:12    INFO: http://10.18.13.11:49153/
2012-02-28 15:41:12    INFO: Adding /mnt/media
如果正常的話在網路鄰居就可以看到upnp設備的圖示了.


/******************************************************************************/
// Gmediarender-0.0.6 測試 on Ubuntu.
/******************************************************************************/
root@js-desktop:/home/app_fd/gmediarender-0.0.6/output/bin# ./gmediarender --gstout-audiosink=alsasink
(gmediarender:17791): GStreamer-CRITICAL **: gst_element_get_bus: assertion `GST_IS_ELEMENT (element)' failed
(gmediarender:17791): GStreamer-CRITICAL **: gst_bus_add_watch_full: assertion `GST_IS_BUS (bus)' failed
(gmediarender:17791): GStreamer-CRITICAL **: gst_object_unref: assertion `object != NULL' failed
Setting audio sink to alsasink
(gmediarender:17791): GLib-GObject-CRITICAL **: g_object_set: assertion `G_IS_OBJECT (object)' failed

(gmediarender:17791): GStreamer-CRITICAL **: gst_element_set_state: assertion `GST_IS_ELEMENT (element)' failed
Error: pipeline doesn't want to get ready
registering '/upnp/rendertransportSCPD.xml'
registering '/upnp/renderconnmgrSCPD.xml'
registering '/upnp/rendercontrolSCPD.xml'
Ready for rendering..
webserver_get_info:(filename='/upnp/rendertransportSCPD.xml',info=0xb3eb0068)
webserver_get_info:(filename='/upnp/rendertransportSCPD.xml',info=0xb4eb2068)
webserver_get_info:(filename='/upnp/renderconnmgrSCPD.xml',info=0xb3eb0068)
webserver_get_info:(filename='/upnp/grender-64x64.png',info=0xb4eb2068)
webserver_get_info:(filename='/upnp/rendercontrolSCPD.xml',info=0xb3eb0068)


/******************************************************************************/
Linux Command: Show Linux Version
/******************************************************************************/
How to check linux kernel version number?
Open a shell prompt (or a terminal) and type the following command to see your current Linux kernel version:
$ uname -r
Sample outputs:

2.6.32-23-generic-pae
Or type the following command:
$ uname -mrs

Sample outputs:

Linux 2.6.32-23-generic-pae i686
To print all information, enter:
$ uname -a

Sample outputs:

Linux vivek-laptop 2.6.32-23-generic-pae #37-Ubuntu SMP Fri Jun 11 09:26:55 UTC 2010 i686 GNU/Linux
Where,

2.6.32-23 - Linux kernel version number
pae - pae kernel type indicate that I'm accssing more than 4GB ram using 32 bit kernel.
SMP - Kernel that supports multi core and multiple cpus.
/proc/version file

Type the following command to see Linux version info:
$ cat /proc/version

Sample outputs:

Linux version 3.2.0-0.bpo.1-amd64 (Debian 3.2.4-1~bpo60+1) (ben@decadent.org.uk) (gcc version 4.4.5 (Debian 4.4.5-8) ) #1 SMP Sat Feb 11 08:41:32 UTC 2012
The above output identifies the kernel version that is currently running. It includes the contents of /proc/sys/kernel/ostype, /proc/sys/kernel/osrelease, and /proc/sys/kernel/version files. For example:
$ cat /proc/sys/kernel/{ostype,osrelease,version}

Sample outputs:

Linux
3.2.0-0.bpo.1-amd64
#1 SMP Sat Feb 11 08:41:32 UTC 2012
Find Distribution Version

Type the following command:
$ cat /etc/*release

OR
$ lsb_release -a

Sample outputs:

No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 10.04 LTS
Release:        10.04
Codename:       lucid
Here is another output from my Debian based server:

lsb_release -a
No LSB modules are available.
Distributor ID: Debian
Description:    Debian GNU/Linux 6.0.6 (squeeze)
Release:        6.0.6
Codename:       squeeze


/******************************************************************************/
How To Check and Use Serial Ports Under Linux
/******************************************************************************/
How do I check and configure serial ports under Linux for various purposes such as modem, connecting null modems or connect a dumb terminal?
Linux offers various tools. Linux uses ttySx for a serial port device name. For example, COM1 (DOS/Windows name) is ttyS0, COM2 is ttyS1 and so on.
Task: Display Detected System's Serial Support

Simple run dmesg command
$ dmesg | grep tty

Output:
[   37.531286] serial8250: ttyS0 at I/O 0x3f8 (irq = 4) is a 16550A
[   37.531841] 00:0b: ttyS0 at I/O 0x3f8 (irq = 4) is a 16550A
[   37.532138] 0000:04:00.3: ttyS1 at I/O 0x1020 (irq = 18) is a 16550A
setserial command

setserial is a program designed to set and/or report the configuration information associated with a serial port. 
This information includes what I/O port and IRQ a particular serial port is using, and whether or not the break key should be interpreted as the Secure Attention Key, and so on. 
Just type the following command:
$ setserial -g /dev/ttyS[0123]
Output:
/dev/ttyS0, UART: 16550A, Port: 0x03f8, IRQ: 4
/dev/ttyS1, UART: 16550A, Port: 0x1020, IRQ: 18
/dev/ttyS2, UART: unknown, Port: 0x03e8, IRQ: 4
/dev/ttyS3, UART: unknown, Port: 0x02e8, IRQ: 3
setserial with -g option help to find out what physical serial ports your Linux box has.

Linux serial console programs
Once serial ports identified you can configure Linux box using various utilities:
minicom- The best friendly serial communication program for controlling modems and connecting to dump devices
wvidial or other GUI dial up networking program - a PPP dialer with built-in intelligence.
getty / agetty - agetty opens a tty port, prompts for a login name and invokes the /bin/login command.
grub / lilo configuration - To configure serial port as the system console


/******************************************************************************/
SSH 免密碼登入
/******************************************************************************/
一、基本流程說明
1. 私密與公開金鑰
以 SSH 登入任何主機都必需要打帳號、密碼，除了不方便、另外還增加了被竊取的風險（有些軟體如 winscp 是可儲存的）。
解決的方式就是使用金鑰產生器來產生一筆公開金鑰（Public Key）與私密金鑰（Private Key）對應做免密碼的登入。
使用者只需將公開金鑰的內容附加系統上特定的檔案中，以及在自己的環境指定好私密金鑰，系統在登入流程中即會自動對應，正確無誤即可登入。
讓整個登入流程快速且安全。
2. 金鑰種類
但是對應並沒有想像中這麼簡單，就像是木門上只能裝喇吧鎖而無法裝大鎖，不同的主機所能使用的金鑰機制也有所不同：
SSH 有 Protocol 1 及 Protocol 2 兩種，常見金鑰編碼機制則有 RSA1、RSA2、以及 DSA 等三種。
3. 保護金鑰的措施
而另外一個問題，如果有人拿到了你的私密金鑰，就相當於他可以在你的主機為所欲為。
保護的措施就是使用 Passphrase（也可以不設）、私密金鑰的密碼，每次要用時就得輸入。
4. Agent 機制
有 Passphrase 保護當然是安全多了，但原本想用金鑰的好處就是可以省去每次打密碼的步驟，
現在若每次又得打 Passphrase，這樣的好處就沒有了，可能還得多記一套密碼、增加打錯的可能性。
還好有 Agent 機制，他相當是你的管家、我們只要把鑰匙及 Passphrase 請他保管，在登入主機時他就會幫你解決輸入 Passphrase 的問題。

二、一步一步教到會
以下就只針對 Mac OSX 及 *nix 系統做介紹（若你是使用 Windows 中的 PuTTY，請先做完步驟一與二，再看這裡）：
步驟 1. 產生金鑰
在 Command Line 中你可以使用 ssh-keygen 來產生各種類的金鑰，而我也會鼓勵大家一次把三種金鑰產生好，省得碰到不同系統麻煩。
a. 產生 RSA 1 金鑰
這種金鑰是給比較舊的系統，例如 FreeBSD 4 及以前的版本、是走 SSH Protocol 1 的，最好就使用 RSA 1 這種金鑰
$ ssh-keygen -t rsa1
Generating RSA keys: Key generation complete. 
Enter file in which to save the key ($HOME/.ssh/identity): [按 Enter 使用預設值（建議）]
Enter passphrase: 輸入你的 Passphrase [建議要使用 passphrase，最少 9 碼]
Enter same passphrase again: 再一次輸入你的 Passphrase
Your identification has been saved in /home/username/.ssh/identity.
Your public key has been saved in /home/username/.ssh/identity.pub.
The key fingerprint is: 6c:96:8c:a8:86:1b:3b:eb:1b:48:8d:3d:8d:c1:4f:dc username@abc.com
b. 產生 RSA 2 金鑰
比較新的系統，如 FreeBSD 5 及之後版本或 Linux，用 RSA 2 或 DSA 這兩種金鑰
$ ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key (/home/username/.ssh/id_rsa): [按 Enter 使用預設值（建議）]
Enter passphrase: 輸入你的 Passphrase
Enter same passphrase again: 再一次輸入你的 Passphrase
Your identification has been saved in /home/username/.ssh/id_rsa.
Your public key has been saved in /home/username/.ssh/id_rsa.pub.
The key fingerprint is: cc:e8:a9:da:a3:41:c6:a9:97:52:59:ef:0c:cf:45:b6 username@abc.com
c. 產生 DSA 金鑰
$ ssh-keygen -t dsa
Generating public/private dsa key pair.
Enter file in which to save the key (/home/username/.ssh/id_dsa): [按 Enter 使用預設值（建議）]
Enter passphrase: 輸入你的 Passphrase
Enter same passphrase again: 再一次輸入你的 Passphrase
Your identification has been saved in /home/username/.ssh/id_dsa.
Your public key has been saved in /home/username/.ssh/id_dsa.pub.
The key fingerprint is: cc:e8:a9:da:a3:41:c6:a9:97:52:59:ef:0c:cf:45:b6 username@abc.com

經過這樣的程式，我們總共會有公私鑰共三對：RSA1 ( identity.pub / identity )、RSA2 ( id_rsa.pub / id_rsa )、及 ( id_dsa.pub / id_rsa )。
我過去有一個錯誤的觀念，以為金鑰是對應系統的，所以在對每一台主機得另外產生一次。
事實上如果沒有特殊需求，你可以只用一份、用任一系統產生、並把這一份給保存好即可。希望大家不要跟我有一樣的錯誤囉！

步驟 2. 將公開金鑰放到主機
你現在在自己的機器上已經有了三對金鑰，接下來我們要把公開的三隻 (*.pub) 放到我們要登入的主機上。
$ scp ~/.ssh/*.pub 你欲登入的主機:~/.ssh/.
接著登入該系統，在沒設定好之前當然還是得乖乖打密碼
$ ssh 你欲登入的主機
系統預設處理放置公鑰的檔案叫做 authorized_keys，所以我們要把剛剛所傳的公鑰附加到這個檔案中：
$ cat ~/.ssh/identity.pub >> ~/.ssh/authorized_keys
$ cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys
$ cat ~/.ssh/id_dsa.pub >> ~/.ssh/authorized_keys
$ chmod 711 ~/.ssh
$ chmod 644 ~/.ssh/authorized_keys
如果沒有意外，你登出再登入主機，就會看到它請你輸入 Passphrase 的訊息。

步驟 3. 設定 ssh-agent
前面所提到，每次都要打 Passphrase 就太麻煩了，所以這裡要設定管家 ssh-agent、以保管私鑰及 Passphrase。
在你每次啟動 shell 後，請照這樣的方式來做：
a. 啟動 ssh-agent
$ eval `ssh-agent -s`
b. 將私密金鑰交給 ssh-agent 保管：ssh-add
我們將要用 ssh-add 來指定金鑰，如果你都照上面放預設的位置及相同的檔名，那就不用有任何的參數。
$ ssh-add
接著會要求你設定輸入 passphrase，如果三個都一樣，就只要打一次。
Enter passphrase for /home/username/.ssh/id_rsa:你的 Passphrase
Identity added: /home/username/.ssh/id_rsa (/home/username/.ssh/id_rsa)
Identity added: /home/username/.ssh/id_dsa (/home/username/.ssh/id_dsa)
Identity added: /home/username/.ssh/identity (username@username.com)
接著再試看看登入已經放好公鑰的主機，應該就可以不用密碼登入了！
c. 自動化流程
如果每次進 Shell 都要做 a、b 動作，可能還是太麻煩且忘記，也因此我去找了可以放在 .bash_profile 的 script ( Joseph M. Reagle Jr )，
一進入 Shell 就會把該做的動作做好，且詢問你 Passphrase：
SH_ENV="$HOME/.ssh/environment"
function start_agent {
     echo "Initialising new SSH agent..."
     /usr/bin/ssh-agent | sed 's/^echo/#echo/' > "${SSH_ENV}"
     echo succeeded
     chmod 600 "${SSH_ENV}"
     . "${SSH_ENV}" > /dev/lull
     /usr/bin/ssh-add;
}

# Source SSH settings, if applicable
if [ -f "${SSH_ENV}" ]; then
     . "${SSH_ENV}" > /dev/null
     #ps ${SSH_AGENT_PID} doesn』t work under cywgin
     ps -ef | grep ${SSH_AGENT_PID} | grep ssh-agent$ > /dev/null || {
         start_agent;
     }
else
     start_agent;
fi

三、公私鑰所需放的機器
我的歸納是，在本機上你必需一直保有這兩份以便後續的再製。而公鑰整理成 authorized_keys，以後有新機器需要登入時一律傳此檔案上去做附加。
而除了本機外，那些機器需要放私鑰呢？我的情況是最常用的那台開發機，因為你可能會利用他去 SSH 其它台機器。不然的話，應該減少私鑰的存放地點，以求安全。


/******************************************************************************/
萬用的 wpa_supplicant 幫你連上無線分享器
/******************************************************************************/
在圖形介面下， 可以用 wicd 設定有線/無線網路。 但是貴哥要看到命令列才有安全感。 
所以我找到了 wpa_supplicant ， 可以跟 WPA、 (幾分鐘就被破解的) WEP 或是沒有加密的無線基地臺連線。

安裝套件： apt-get install wpasupplicant
把這個設定檔 wpa_supplicant.conf 存成 /etc/wpa_supplicant/wpa_supplicant.conf 
並且 chmod 600 /etc/wpa_supplicant/wpa_supplicant.conf 關閉對外權限以策安全!
編輯上述設定檔，輸入正確的 ssid 及密碼。 更完整的範例檔請見 這裡。
先用 route -n 確認一下網卡還沒連線。
拿密碼向無線基地臺認證： wpa_supplicant -B -i wlan0 -D nl80211 -c /etc/wpa_supplicant/wpa_supplicant.conf 這裡的 -i 後面要打網卡名稱 -- 就是先前 ifconfig -a 看到的。 至於 -D 後面則要打網卡驅動程式名稱 -- 這跟前面看到的無關， 而是要選 wpa_supplicant 所提供的驅動程式之一。 有哪些驅動程式可選? 下 wpa_supplicant -h 找到 drivers 那一小段， 逐一試試看吧。 詳見 這個問答。
向無線基地臺要網址等等： dhclient wlan0
重下一次 route -n 應該就看到連線成功了。



/******************************************************************************/
/******************************************************************************/
3. 程式範例
所有的範例來源自 miniterm.c. The type ahead 暫存器被限制在 255 個字元, 就跟標準輸入程式的最大字串長度相同 (<linux/limits.h> 或 <posix1_lim.h>).
參考程式碼中的註解它會解釋不同輸入模式的使用. 我希望這些程式碼都能被瞭解. 標準輸入程式的程式範例的註解寫得最好, 其它的範例都只在不同於其它範例的地方做註解.
敘述不是很完整, 但可以激勵你對這範例做實驗, 以延生出合於你所需應用程式的最佳解.
別忘記要把序列埠的權限設定正確 (也就是: chmod a+rw /dev/ttyS1)!

3.1 標準輸入程式

 #include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <termios.h>
#include <stdio.h>
#include <stdlib.h>

/* 鮑率設定被定義在 <asm/termbits.h>, 這在 <termios.h> 被引入 */
#define BAUDRATE B38400            
/* 定義正確的序列埠 */
#define MODEMDEVICE "/dev/ttyS1"
#define _POSIX_SOURCE 1 /* POSIX 系統相容 */

#define FALSE 0
#define TRUE 1

volatile int STOP=FALSE; 

main()
{
  int fd,c, res;
  struct termios oldtio,newtio;
  char buf[255];
/* 
  開啟數據機裝置以讀取並寫入而不以控制 tty 的模式
  因為我們不想程式在送出 CTRL-C 後就被殺掉.
*/
 fd = open(MODEMDEVICE, O_RDWR | O_NOCTTY ); 
 if (fd <0) {perror(MODEMDEVICE); exit(-1); }

 tcgetattr(fd,&oldtio); /* 儲存目前的序列埠設定 */
 bzero(&newtio, sizeof(newtio)); /* 清除結構體以放入新的序列埠設定值 */

/* 
  BAUDRATE: 設定 bps 的速度. 你也可以用 cfsetispeed 及 cfsetospeed 來設定.
  CRTSCTS : 輸出資料的硬體流量控制 (只能在具完整線路的纜線下工作
            參考 Serial-HOWTO 第七節)
  CS8     : 8n1 (8 位元, 不做同位元檢查,1 個終止位元)
  CLOCAL  : 本地連線, 不具數據機控制功能
  CREAD   : 致能接收字元
*/
 newtio.c_cflag = BAUDRATE | CRTSCTS | CS8 | CLOCAL | CREAD;
 
/*
  IGNPAR  : 忽略經同位元檢查後, 錯誤的位元組
  ICRNL   : 比 CR 對應成 NL (否則當輸入訊號有 CR 時不會終止輸入)
            在不然把裝置設定成 raw 模式(沒有其它的輸入處理)
*/
 newtio.c_iflag = IGNPAR | ICRNL;
 
/*
 Raw 模式輸出.
*/
 newtio.c_oflag = 0;
 
/*
  ICANON  : 致能標準輸入, 使所有回應機能停用, 並不送出信號以叫用程式
*/
 newtio.c_lflag = ICANON;
 
/* 
  初始化所有的控制特性
  預設值可以在 /usr/include/termios.h 找到, 在註解中也有,
  但我們在這不需要看它們
*/
 newtio.c_cc[VINTR]    = 0;     /* Ctrl-c */ 
 newtio.c_cc[VQUIT]    = 0;     /* Ctrl-\ */
 newtio.c_cc[VERASE]   = 0;     /* del */
 newtio.c_cc[VKILL]    = 0;     /* @ */
 newtio.c_cc[VEOF]     = 4;     /* Ctrl-d */
 newtio.c_cc[VTIME]    = 0;     /* 不使用分割字元組的計時器 */
 newtio.c_cc[VMIN]     = 1;     /* 在讀取到 1 個字元前先停止 */
 newtio.c_cc[VSWTC]    = 0;     /* '\0' */
 newtio.c_cc[VSTART]   = 0;     /* Ctrl-q */ 
 newtio.c_cc[VSTOP]    = 0;     /* Ctrl-s */
 newtio.c_cc[VSUSP]    = 0;     /* Ctrl-z */
 newtio.c_cc[VEOL]     = 0;     /* '\0' */
 newtio.c_cc[VREPRINT] = 0;     /* Ctrl-r */
 newtio.c_cc[VDISCARD] = 0;     /* Ctrl-u */
 newtio.c_cc[VWERASE]  = 0;     /* Ctrl-w */
 newtio.c_cc[VLNEXT]   = 0;     /* Ctrl-v */
 newtio.c_cc[VEOL2]    = 0;     /* '\0' */

/* 
  現在清除數據機線並啟動序列埠的設定
*/
 tcflush(fd, TCIFLUSH);
 tcsetattr(fd,TCSANOW,&newtio);

/*
  終端機設定完成, 現在處理輸入訊號
  在這個範例, 在一行的開始處輸入 'z' 會退出此程式.
*/
 while (STOP==FALSE) {     /* 迴圈會在我們發出終止的訊號後跳出 */
 /* 即使輸入超過 255 個字元, 讀取的程式段還是會一直等到行終結符出現才停止.
    如果讀到的字元組低於正確存在的字元組, 則所剩的字元會在下一次讀取時取得.
    res 用來存放真正讀到的字元組個數 */
    res = read(fd,buf,255); 
    buf[res]=0;             /* 設定字串終止字元, 所以我們能用 printf */
    printf(":%s:%d\n", buf, res);
    if (buf[0]=='z') STOP=TRUE;
 }
 /* 回存舊的序列埠設定值 */
 tcsetattr(fd,TCSANOW,&oldtio);
}

3.2 非標準輸入程式

在非標準的輸入程式模式下, 輸入的資料不會被組合成一行而輸入後的處理功能 (清除, 殺掉, 刪除, 等等.) 都不能使用. 這個模式有兩個功能控制參數: c_cc[VTIME] 設定字元輸入時間計時器, 及 c_cc[VMIN] 設定滿足讀取功能的最低字元接收個數.

如果 MIN > 0 且 TIME = 0, MIN 設定為滿足讀取功能的最低字元接收個數. 由於 TIME 是 零, 所以計時器將不被使用.

如果 MIN = 0 且 TIME > 0, TIME 將被當做逾時設定值. 滿足讀取功能的情況為讀取到單一字元, 或者超過 TIME 所定義的時間 (t = TIME *0.1 s). 如果超過 TIME 所定義的時間, 則不會傳回任何字元.

如果 MIN > 0 且 TIME > 0, TIME 將被當做一個分割字元組的計時器. 滿足讀取功能的條件為 接收到 MIN 個數的字元, 或兩個字元的間隔時間超過 TIME 所定義的值. 計時器會在每讀到一個字元後重新計時, 且只會在第一個字元收到後才會啟動.

如果 MIN = 0 且 TIME = 0, 讀取功能就馬上被滿足. 目前所存在的字元組個數, 或者 將回傳的字元組個數. 根據 Antonino (參考 貢獻) 所說, 你可以用 fcntl(fd, F_SETFL, FNDELAY); 在讀取前得到相同的結果.

藉由修改 newtio.c_cc[VTIME] 及 newtio.c_cc[VMIN] 上述的模式就可以測試了.

 #include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <termios.h>
#include <stdio.h>

#define BAUDRATE B38400
#define MODEMDEVICE "/dev/ttyS1"
#define _POSIX_SOURCE 1 /* POSIX 系統相容 */
#define FALSE 0
#define TRUE 1

volatile int STOP=FALSE; 

main()
{
  int fd,c, res;
  struct termios oldtio,newtio;
  char buf[255];

 fd = open(MODEMDEVICE, O_RDWR | O_NOCTTY ); 
 if (fd <0) {perror(MODEMDEVICE); exit(-1); }

 tcgetattr(fd,&oldtio); /* 儲存目前的序列埠設定 */

 bzero(&newtio, sizeof(newtio));
 newtio.c_cflag = BAUDRATE | CRTSCTS | CS8 | CLOCAL | CREAD;
 newtio.c_iflag = IGNPAR;
 newtio.c_oflag = 0;

 /* 設定輸入模式 (非標準型, 不回應,...) */
 newtio.c_lflag = 0;
 
 newtio.c_cc[VTIME]    = 0;   /* 不使用分割字元組計時器 */
 newtio.c_cc[VMIN]     = 5;   /* 在讀取到 5 個字元前先停止 */

 tcflush(fd, TCIFLUSH);
 tcsetattr(fd,TCSANOW,&newtio);


 while (STOP==FALSE) {       /* 輸入迴圈 */
   res = read(fd,buf,255);   /* 在輸入 5 個字元後即返迴 */
   buf[res]=0;               /* 所以我們能用 printf... */
   printf(":%s:%d\n", buf, res);
   if (buf[0]=='z') STOP=TRUE;
 }
 tcsetattr(fd,TCSANOW,&oldtio);
}
3.3 非同步式輸入

 #include <termios.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/signal.h>
#include <sys/types.h>

#define BAUDRATE B38400
#define MODEMDEVICE "/dev/ttyS1"
#define _POSIX_SOURCE 1 /* POSIX 系統相容 */
#define FALSE 0
#define TRUE 1

volatile int STOP=FALSE; 

void signal_handler_IO (int status);   /* 定義訊號處理程式 */
int wait_flag=TRUE;                    /* 沒收到訊號的話就會是 TRUE */

main()
{
  int fd,c, res;
  struct termios oldtio,newtio;
  struct sigaction saio;           /* definition of signal action */
  char buf[255];

  /* 開啟裝置為 non-blocking (讀取功能會馬上結束返回) */
  fd = open(MODEMDEVICE, O_RDWR | O_NOCTTY | O_NONBLOCK);
  if (fd <0) {perror(MODEMDEVICE); exit(-1); }

  /* 在使裝置非同步化前, 安裝訊號處理程式 */
  saio.sa_handler = signal_handler_IO;
  saio.sa_mask = 0;
  saio.sa_flags = 0;
  saio.sa_restorer = NULL;
  sigaction(SIGIO,&saio,NULL);
  
  /* 允許行程去接收 SIGIO 訊號*/
  fcntl(fd, F_SETOWN, getpid());
  /* 使檔案ake the file descriptor 非同步 (使用手冊上說只有 O_APPEND 及
  O_NONBLOCK, 而 F_SETFL 也可以用...) */
  fcntl(fd, F_SETFL, FASYNC);

  tcgetattr(fd,&oldtio); /* 儲存目前的序列埠設定值 */
  /* 設定新的序列埠為標準輸入程式 */
  newtio.c_cflag = BAUDRATE | CRTSCTS | CS8 | CLOCAL | CREAD;
  newtio.c_iflag = IGNPAR | ICRNL;
  newtio.c_oflag = 0;
  newtio.c_lflag = ICANON;
  newtio.c_cc[VMIN]=1;
  newtio.c_cc[VTIME]=0;
  tcflush(fd, TCIFLUSH);
  tcsetattr(fd,TCSANOW,&newtio);
 
  /* 等待輸入訊號的迴圈. 很多有用的事我們將在這做 */ 
  while (STOP==FALSE) {
    printf(".\n");usleep(100000);
    /* 在收到 SIGIO 後, wait_flag = FALSE, 輸入訊號存在則可以被讀取 */
    if (wait_flag==FALSE) { 
      res = read(fd,buf,255);
      buf[res]=0;
      printf(":%s:%d\n", buf, res);
      if (res==1) STOP=TRUE; /* 如果只輸入 CR 則停止迴圈 */
      wait_flag = TRUE;      /* 等待新的輸入訊號 */
    }
  }
  /* 回存舊的序列埠設定值 */
  tcsetattr(fd,TCSANOW,&oldtio);
}

/***************************************************************************
* 訊號處理程式. 設定 wait_flag 為 FALSE, 以使上述的迴圈能接收字元          *
***************************************************************************/

void signal_handler_IO (int status)
{
  printf("received SIGIO signal.\n");
  wait_flag = FALSE;
}
3.4 等待來自多個訊號來源的輸入

這一段很短. 它只能被拿來當成寫程式時的提示, 故範例程式也很簡短. 但這個範例不只能用在序列埠上, 還可以用在被當成檔案來使用的裝置上.

select 呼叫及伴隨它所引發的巨集共用 fd_set. fd_set 則是一個 位元陣列, 而其中每一個位元代表一個有效的檔案敘述結構. select 呼叫接受一個有效的檔案敘述結構並傳回 fd_set 位元陣列, 而該位元陣列中若有某一個位元為 1, 就表示相對映的檔案敘述結構的檔案發生了輸入, 輸出或有例外事件. 而這些巨集提供了所有處理 fd_set 的功能. 亦可參考手冊 select(2).

 #include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

main()
{
   int    fd1, fd2;  /* 輸入源 1 及 2 */
   fd_set readfs;    /* 檔案敘述結構設定 */
   int    maxfd;     /* 最大可用的檔案敘述結構 */
   int    loop=1;    /* 迴圈在 TRUE 時成立 */ 

   /* open_input_source 開啟一個裝置, 正確的設定好序列埠,
      並回傳回此檔案敘述結構體 */
   fd1 = open_input_source("/dev/ttyS1");   /* COM2 */
   if (fd1<0) exit(0);
   fd2 = open_input_source("/dev/ttyS2");   /* COM3 */
   if (fd2<0) exit(0);
   maxfd = MAX (fd1, fd2)+1;  /* 測試最大位元輸入 (fd) */

   /* 輸入迴圈 */
   while (loop) {
     FD_SET(fd1, &readfs);  /* 測試輸入源 1 */
     FD_SET(fd2, &readfs);  /* 測試輸入源 2 */
     /* block until input becomes available */
     select(maxfd, &readfs, NULL, NULL, NULL);
     if (FD_ISSET(fd1))         /* 如果輸入源 1 有訊號 */
       handle_input_from_source1();
     if (FD_ISSET(fd2))         /* 如果輸入源 2 有訊號 */
       handle_input_from_source2();
   }

}   
這個範例程式在等待輸入訊號出現前, 不能確定它會停頓下來. 如果你需要在輸入時加入逾時功能, 只需把 select 呼叫換成:

 int res;
struct timeval Timeout;

/* 設定輸入迴圈的逾時值 */
Timeout.tv_usec = 0;  /* 毫秒 */
Timeout.tv_sec  = 1;  /* 秒 */
res = select(maxfd, &readfs, NULL, NULL, &Timeout);
if (res==0)
/* 檔案敘述結構數在 input = 0 時, 會發生輸入逾時. */ 
這個程式會在 1 秒鐘後逾時. 如果超過時間, select 會傳回 0, 但是應該留意 Timeout 的時間遞減是由 select 所等待輸入訊號的時間為基準. 如果逾時的值是 0, select 會馬上結束返回.


/******************************************************************************/
Ubuntu 安裝和設定 MySQL         ref : http://www.arthurtoday.com/2009/11/ubuntu-910-mysql.html
/******************************************************************************/
雖然在 Ubuntu 只要用 apt-get 就可以把 MySQL 安裝完成，不過，還是有一些事項要注意的，所以，阿捨把它整理如下，有需要的人可以參考一下囉 ! 
( 如果你是一次要安裝好 Apache、PHP 5 和 MySQL 等三套軟體的話，請參考阿捨寫的這一篇)

1. 確認 /etc/hosts 有設定好本機及實體網路 IP 。
127.0.0.1 localhost.localdomain localhost
xxx.xxx.xxx.xxx xyu.arthurtoday.com xyu  (以 IP 是 xxx.xxx.xxx.xxx 為例 )

2.安裝 MySQL 及設定 root 密碼
sudo apt-get install mysql-server
上面指今執行後就會跳出一個畫面要輸入 root 的密碼，輸入二次之後就會繼續後下裝。
pw: 0222225678

3.調整 MySQL 設定檔
sudo vi /etc/mysql/my.cnf

一般來說是不太需要調的，但是，大部會調整的，都是把下列項目的記憶體用量調高的以提增加運行的效能。
key_buffer = 16K
max_allowed_packet = 1M
thread_stack = 64K
table_cache = 4
sort_buffer = 64K
net_buffer_length = 2K

4.登入 MySQL
mysql -u root -p
接著輸入 root 的密碼就可以了。

5.調整可連線的 IP
MySQL 在裝好之後，預設會把自己綁在 127.0.0.1 的這一組 IP 上，目的是讓別人不能從遠端存取 MySQL，但是，
如果有需要讓 MySQL 從遠端連進來的話，那就要改 /etc/mysql/my.cnf  檔案裡的設定，把 bind_address 這個參數從 127.0.0.1 改成主機的實體 IP 位址。
bind_address = xxx.xxx.xxx.xxx

6.重設 MySQL 的 root 密碼 ( 如果有需要的話 )
sudo dpkg-reconfigure mysql-server-5.1

Read more: http://www.arthurtoday.com/2009/11/ubuntu-910-mysql.html#ixzz3hFpJ2vCf


/******************************************************************************/
解決 MYSQL 登入時，ERROR 1045 (28000) using password: NO 的方法
/******************************************************************************/
我的系統是 UBUNTU 11.04，安裝的MYSQL版本為14.14(注1)，安裝好並設定 root 密碼後，透過終端機輸入指令 mysql -u root ，卻出現 
    ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO) 訊息。
改輸入 mysql -u root -p 　強制輸入密碼，卻變成
    ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)
在網路上查詢了一下，發現問題似乎與　'root'@'localhost' ，帳號跟登入位置與密碼對應有關，也發現這問題十分氾濫，並似乎沒有個好的ＳＯＰ解決流程，於是試了幾種方法，整理成以下心得：
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
１．首先，停止MYSQL 服務：
    #  /etc/init.d/mysql stop              or  #  stop mysql          or # service mysql stop
２．接著跳過授權表訪問，命令如下：
    # mysqld_safe --user=mysql --skip-grant-tables --skip-networking &
３．登錄　MYSQL：
    # mysql -uroot mysql
    or
    # mysql -uroot mysql -p
    輸入 root 密碼，進入MYSQL。
    這裡若依舊跳出　ERROR 1045 (28000)　訊息，則請跳至文末的 Ａ 步驟
４．重新寫入 root 密碼：
    mysql> UPDATE user SET Password=PASSWORD('輸入你 root 的新密碼') where USER='root';
５． 把 所有資料庫(含其下的所有資料表)，授權給 root，從 localhost 上來，密碼為引號內數據  '*****'。 
    mysql> GRANT all ON *.* TO root@'localhost' IDENTIFIED BY '輸入你 root 的密碼'; 
６．更新權限！密碼若有更動，一定要執行此行指令。
    mysql> FLUSH PRIVILEGES;
７．離開　MYSQL
    mysql> quit
８．輸入密碼，正常進入 MYSQL。
    # mysql -uroot -p

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
Ａ．直接使用　/etc/mysql/debian.cnf　文件中　[client]　提供的用戶名和密碼：
    # mysql -udebian-sys-maint -p
    輸入　[client]　中的密碼
    mysql> UPDATE user SET Password=PASSWORD('輸入你 root 的新密碼') where USER='root';
    // 重新寫入 root 密碼
    mysql> GRANT all ON *.* TO root@'localhost' IDENTIFIED BY '輸入你 root 的密碼'; 
    // 把 所有資料庫(含其下的所有資料表)，授權給 root，從 localhost 上來，密碼為引號內數據  '*****'。 
    mysql> FLUSH PRIVILEGES;
    // 更新權限！密碼若有更動，一定要執行此行指令。
    mysql> quit
    # mysql -uroot -p
    輸入密碼，正常進入 MYSQL。
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
以上兩種狀況我都遇過，依以上方式我的問題都解決了。
另外改好後，MYSQL 系統似乎需要一點時間更動，因為在終端機上MYSQL可進去了，網頁的 phpmyadmin 卻依舊進不去，SSH連也進不去，直到間隔了快 10 秒，才一切正常。


/******************************************************************************/
Python 連接 MySQL 
/******************************************************************************/
MySQL 是十分流行的開源資料庫系統，很多網站也是使用 MySQL 作為後台資料儲存，而 Python 要連接 MySQL 可以使用 MySQL 模組。
MySQLdb 模組可以讓 Python 程式連線到 MySQL server, 執行 SQL 語句及擷取資料等。

開始前要確定系統內的 Python 有安裝 MySQLdb 模式，你可以 Python command line interpreter 檢查，在指令模式輸入 python，然後便可以開始檢查：
Python 2.5.1 (r251:54863, May 2 2007, 16:56:35)
[GCC 4.1.2 (Ubuntu 4.1.2-0ubuntu4)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import MySQLdb
Traceback (most recent call last):
File "", line 1, in
ImportError: No module named MySQLdb
>>> exit()
如果見以上面的 「ImportError: No module named MySQLdb」 一句，便表示系統沒有安裝，到 MySQLdb 官方網站 下載 MySQLdb，並用以下方法安裝：
$ tar zxvf MySQL-python-1.2.2.tar.gz
$ cd MySQL-python-1.2.2
$ python setup.py build
$ python setup.py install

安裝好 MySQLdb 後便可以編寫程式碼，以下是簡單的例子：
#!/usr/bin/python

# 引入 MySQL 模組
import MySQLdb
     
# 連接到 MySQL
db = MySQLdb.connect(host="localhost", user="db_user", passwd="db_pass", db="db_name")
cursor = db.cursor()
     
# 執行 SQL 語句
cursor.execute("SELECT * FROM db_table")
result = cursor.fetchall()
     
# 輸出結果
for record in result:
    print record[0]


/******************************************************************************/
ERROR 1045 (28000): Access denied after installation on Ubunutu / Mint
/******************************************************************************/
After a fresh and clean installation of mysql server version 5.5 on Linux Mint or Ubuntu I got this error:
ERROR 1045 (28000): Access denied for user 『root』@』localhost』 (using password: YES)

What did I do
sudo apt-get install mysql-server-5.5

Afterwards I tried to log into mysql with default empty root password:
mysql -u root
ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)

Just to make sure I tried password root
mysql -u root -proot
ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)

Solution
This command allows you to set the initial password for mysql server.
sudo dpkg-reconfigure mysql-server-5.5

For me this problem does only occur with mysql server version 5.5


/******************************************************************************/
Installing and Configuring MiniDLNA
/******************************************************************************/
For some reason, when I tried to install MiniDLNA, through Putty I received error messages. From reading around, it turns out that this is a common problem as some repositories are missing.

In the end, these commands installed the package:
sudo apt-get install --reinstall python-software-properties && sudo dpkg-reconfigure python-software-properties
sudo add-apt-repository ppa:stedy6/stedy-minidna
sudo apt-get update
sudo apt-get upgrade
sudo apt-get install minidlna

I would also recommend installing the Webmin MiniDLNA module from https://sourceforge.net/projects/minidlnawebmin/
If you are accessing the server through Webmin and are not sure how to install the module, save it to a local location (such as your desktop on your computer). 
Select the "Webmin Configuration" module which is under the "Webmin" tab. Select the "Webmin Modules" and choose to load the module 「From uploaded file". 
Once the module has been installed it will be automatically be configured and it will be available under the "Servers" tab.
Once this is installed, you need to configure the MiniDLNA conf file located at /etc/minidlna.conf.
You can use your favourite text editor or if you are accessing this through Webmin, you can use the "Edit" option in "File Manager". 
If you have installed the Webmin module, you can also change all of the settings from there.

My minidlna.conf file reads as follows:
# port for HTTP (descriptions, SOAP, media transfer) traffic
port=8200

# network interface to bind to (this is the only interface that will serve files)
#network_interface=eth0

# set this to the directory you want scanned.
# * if have multiple directories, you can have multiple media_dir= lines
# * if you want to restrict a media_dir to a specific content type, you
# can prepend the type, followed by a comma, to the directory:
# + "A" for audio (eg. media_dir=A,/home/jmaggard/Music)
# + "V" for video (eg. media_dir=V,/home/jmaggard/Videos)
# + "P" for images (eg. media_dir=P,/home/jmaggard/Pictures)

media_dir=V,/media/server/server/Media/Films
media_dir=V,/media/server/server/Media/TV
media_dir=V,/media/server/server/Media/Commedy
media_dir=V,/media/server/server/Music/Videos
media_dir=A,/media/server/server/Music/Music
media_dir=P,/media/server/server/Stuff/Pictures

# set this if you want to customize the name that shows up on your clients
friendly_name=MiniDLNA Server

# set this if you would like to specify the directory where you want MiniDLNA to store its database and album art cache
db_dir=/media/server/server/Backup/Server/MiniDLNA

# set this if you would like to specify the directory where you want MiniDLNA to store its log file
#log_dir=/var/log

# this should be a list of file names to check for when searching for album art
# note: names should be delimited with a forward slash ("/")
album_art_names=Front.jpg/front.jpg/Cover.jpg/cover.jpg/AlbumArtSmall.jpg/albumartsmall.jpg/AlbumArt.jpg/albumart.jpg/Album.jpg/album.jpg/Folder.jpg/folder.jpg/Thumb.jpg/thumb.jpg

# set this to no to disable inotify monitoring to automatically discover new files
# note: the default is yes
inotify=yes

# set this to yes to enable support for streaming .jpg and .mp3 files to a TiVo supporting HMO
enable_tivo=no

# set this to strictly adhere to DLNA standards.
# * This will allow server-side downscaling of very large JPEG images,
# which may hurt JPEG serving performance on (at least) Sony DLNA products.
strict_dlna=no

# default presentation url is http address on port 80
presentation_url=http://minidlna/index.php

# notify interval in seconds. default is 895 seconds.
notify_interval=895

# serial and model number the daemon will report to clients
# in its XML description
serial=12345678
model_number=1

As you can see, I've made a few changes to the standard file:

I have added various sources of videos
I have changed the name of the server so I can recognise it easily on the network
I have moved the location of the database to a location that I backup each day and is shared by Samba (this is for my personal benefit only)
I have added extra filenames to the "AlbulmArt" section as I usually call the front cover of an album "Front"
Despite the line 「# default presentation url is http address on port 80」 MiniDLNA does not have a webpage that it can be controlled from. 
From what I can gather, this was going to be a future feature that was not completed for whatever reason. However, the Webmin module takes care of everything that you need.
From the "Command Shell" in Webmin or through an SSH session using Putty, you can control MiniDLNA using the commands:

sudo /etc/init.d/minidlna stop
sudo /etc/init.d/minidlna start
At first run, MiniDLNA will scan all of the folders (and their sub-folders) it has been pointed at and make all of these files available. 
The scan is extremely quick (less than 10 minutes to scan about 12,000 files).
The Webmin module has a "Restart" button but for some reason (on my set-ups) it does not work properly. It will stop MiniDLNA but when it tries to restart it, 
it fails. Trying to manually start it using the command "sudo /etc/init.d/minidlna start" after using this "Restart" does not seem to work and the only way 
I have found to resolve this is to restart the whole server.

Adding or Removing Files of Folders from the Database
In my experience, MiniDLNA tends not to notice if a file has been added or removed from the folders so the database does not update and new files are not shown on your device and old files are still shown even though they have been removed. This seems to be a problem with MiniDLNA and not the receiving soft/hardware. If you change the name of the server, the soft/hardware picks that up fine.
Some people have had success with the command:
minidlna -R
or by removing the file /tmp/minidlna/files.db and restarting the server using the command:
rm -rf /tmp/minidlna

Someone else suggested using the command:
minidlna -R -f /tmp/minidlna.conf
However, I have found the easiest and most successful method is to use the "Rescan" button in the Webmin interface. This button deletes the MiniDLNA database and rescans from scratch. On my system, this new scan took less than 10 minutes to scan about 12,000 files. After the scan, any new files appear in the database and any deleted files are removed.

Outstanding Problems
The only thing I have not been able to get MiniDLNA to do so far is display my photos properly on the Blu-ray player even though they display fine on Windows Media Player. On the Blu-ray, it shows all of the folders where my pictures are stored and even gives me the option to search by camera but when I try to view the pictures or look into the folders, the folders are all empty. This suggests it is something to do with the Blu-ray player and not MiniDLNA however, to be honest this is not an issue for me as my main aim was to stream videos and music and it works perfectly for that.
If anyone can point me to a walkthrough of how to receive streamed videos and music on VLC I would be grateful so I can test this set-up on that and add it to this guide.
I hope you find this guide useful and it takes away some of the headaches I've had with setting up this excellent program.


/******************************************************************************/
ubuntu清理系統垃圾與備份
/******************************************************************************/
雖然linux下不會有windows下的那麼多垃圾和磁片碎片!但還是會留下一些用不著的暫存檔案或是多次升級後的N個舊的內核!
1，非常有用的清理命令：
sudo apt-get autoclean
sudo apt-get clean
sudo apt-get autoremove
這三個命令主要清理升級緩存以及無用包的。

2，清理opera firefox的緩存檔：
ls ~/.opera/cache4
ls ~/.mozilla/firefox/*.default/Cache

3，清理Linux下孤立的包：
圖形介面下我們可以用：gtkorphan
sudo apt-get install gtkorphan -y
終端命令下我們可以用：deborphan
sudo apt-get install deborphan -y

4，卸載：tracker
這個東西一般我只要安裝ubuntu就會第一刪掉tracker 他不僅會產生大量的cache檔而且還會影響開機速度。所以在新得利裏面刪掉就行。

5，刪除多餘的內核：一定不要刪錯哦，切記！！
打開終端敲命令：dpkg –get-selections|grep linux
有image的就是內核檔
刪除老的內核檔：
sudo apt-get remove 內核檔案名 （例如：linux-image-2.6.27-2-generic）
內核刪除，釋放空間了，應該能釋放130－140M空間。
最後不要忘了看看當前內核：uname -a

附錄： (包管理的暫存檔案目錄)
包在: /var/cache/apt/archives

沒有下載完的在: /var/cache/apt/archives/partial

6. 備份系統, 打開終端，輸入以下命令：

1) 成為根用戶：   sudo su

2) 轉到根目錄：   cd /

然後，下面就是我用來備份我的系統的完整的命令：
tar -cvpzf /media/sda7/backup.tgz --exclude=/proc --exclude=/lost+found --exclude=/mnt --exclude=/sys --exclude=/media /

接著，讓我們稍微解釋一下：
tar 是用來備份的程式
c - 新建一個備份文檔
v - 詳細模式， tar程式將在螢幕上即時輸出所有資訊。
p - 保存許可，並應用到所有檔。
z - 採用『gzip』壓縮備份檔案，以減小備份檔案體積。
f - 說明備份檔案存放的路徑， /media/sda7/backup.tgz 是本例子中備份檔案名。這個備份檔案備份的位置是其他分區，也就是原來的WIN分區中。因為我的根目錄的空間不足，所以只有備份在其他的地方了。
來 看看我們想要包含的目錄。我們不想備份所有的東西，因為有些目錄是沒有多大用處的。確認你不想包含的檔，否則您會得到一個很奇怪的結果。您也不必備份 /mnt 目錄下的東西，除非您有其他分區掛在它下面或者你堅持要備份。您還必須確保沒有任何資源掛在 /media目錄下(比如，任何CD或者移動存儲介質).否則，剔除/media。
* 最後一個參數是我們想要保存的目錄. 我們想要保存所有的東西，使用 / 作為根目錄。

然後就是將來還原系統備份了：
警告: 求您了，看在上帝的份上，千萬小心這兒。如果您不明白您正在幹什麼，那很有可能複蓋掉您重要的資料，所以請特別小心！
好了，繼續我們前面所講的例子，我們在其他分區（sda7）目錄下創建了一個名為backup.tgz的備份檔案。
Linux 中美妙的事情之一就是在系統正在運行的情況下可以進行還原操作，而不需要啟動光碟或者其他任何亂七八糟的東西。當然，如果您的系統已經崩潰，那您必須選擇 使用live CD，但是結果還是一樣。你甚至可以在Linux系統正在運行的時候，移除它裏面所有檔。可是我不告訴你那個命令！
好了，言歸正傳。這是我要用的命令，如果你的備份不是在和我一樣的位置的位置的話，那請相應地修改/media/sda7這一點：
tar -xvpzf /media/disk/backup.tgz -C /
如果您使用的是bz2壓縮的：
tar -xvpjf /media/disk/backup.tar.bz2 -C /


/******************************************************************************/
Ubuntu常用的命令 http://hi.baidu.com/ycerror/blog/item/41a9272d62a9ab3e359bf71a.html
/******************************************************************************/
刪除資料夾及它的子資料夾和檔案：sudo rm -rf /home/ubuntu
查找軟體庫中的軟體：aptitude search 套裝軟體
查看軟體xxx安裝內容：dpkg -L xxx
查找文件屬於哪個包：dpkg -S filename
清除已刪除包的殘餘配置檔：dpkg -l |grep ^rc|awk 『{print $2}』 |sudo xargs dpkg -P
備份當前系統安裝的所有包的列表：dpkg –get-selections | grep -v deinstall > ~/somefile
從備份的安裝包的列表檔恢復所有包：dpkg –set-selections < ~/somefile;sudo dselect
系統升級：sudo apt-get update;sudo apt-get dist-upgrade
查找軟體庫中的軟體：apt-cache search 正則運算式
查找文件屬於哪個包：apt-file search filename
查詢軟體xxx依賴哪些包：apt-cache depends xxx
查詢軟體xxx被哪些包依賴：apt-cache rdepends xxx
清理舊版本的軟體緩存：sudo apt-get autoclean
清理所有軟體緩存：sudo apt-get clean
刪除系統不再使用的孤立軟體：sudo apt-get autoremove
查看包在伺服器上面的地址：apt-get -qq –print-uris install ssh | cut -d\』 -f2
顯示系統安裝包的統計資訊：apt-cache stats
顯示系統全部可用包的名稱：apt-cache pkgnames
顯示包的資訊：apt-cache show k3b
增加一個光碟源：sudo apt-cdrom add
編譯時缺少h檔的自動處理：sudo auto-apt run ./configure
查看安裝軟體時下載包的臨時存放目錄：ls /var/cache/apt/archives
查看內核：uname -a
查看Ubuntu版本：cat /etc/issue 或 lsb_release -a
查看內核載入的模組：lsmod
查看PCI設備：lspci
查看USB設備：lsusb -v
查看網卡狀態：sudo ethtool eth0
查看CPU資訊：cat /proc/cpuinfo
顯示當前硬體資訊：sudo lshw
顯示系統運行時間：uptime
查看硬碟的分區：sudo fdisk -l
硬碟分區：sudo fdisk /dev/sda
硬碟格式化：sudo mkfs.ext3 /dev/sda1
硬碟檢查(請不要檢查已經掛載的分區，否則容易損壞資料)：sudo fsck /dev/sda1
分區掛載：sudo mount -t 檔系統類型 (-o nls=utf8 或 -o iocharset=utf8) 設備路經 訪問路經
分區卸載：sudo umount 目錄名或設備名
查看IDE硬碟資訊：sudo hdparm -i /dev/hda
查看STAT硬碟資訊 ：sudo hdparm -I /dev/sda 或 sudo blktool /dev/sda id
查看硬碟剩餘空間：df
查看目錄佔用空間：du -hs 目錄名
優盤沒法卸載：sync;fuser -km /media/usbdisk
查看硬碟當前讀寫情況：sudo iostat -x 2
查看當前的記憶體使用情況：free
動態顯示進程執行情況：top
查看當前有哪些進程：ps -A
查看當前進程樹：pstree
中止一個進程：kill 進程號 或 killall 進程名
強制中止一個進程：kill -9 進程號 或 killall -9 進程名
圖形方式中止一個程式：xkill 出現骷髏標誌的滑鼠，點擊需要中止的程式即可
查看進程打開的檔：lsof -p
顯示開啟檔abc.txt的進程 ：lsof abc.txt
顯示22埠現在運行什麼程式 ：lsof -i :22
顯示nsd進程現在打開的檔 ：lsof -c nsd
在後臺運行程式，退出登錄後，並不結束程式 ：nohup 程式 &
詳細顯示程式的運行資訊 ：strace -f -F -o outfile
增加系統最大打開檔個數：ulimit -n 4096 或 echo 4096 > /proc/sys/fs/file-max
配置 ADSL ：sudo pppoeconf
ADSL手工撥號：sudo pon dsl-provider
啟動 ADSL：sudo /etc/ppp/pppoe_on_boot
斷開 ADSL ：sudo poff
查看撥號日誌：sudo plog
如何設置動態功能變數名稱：w3m -no-cookie -dump "http://usere:pass@members.3322.org/dyndns/update?system=dyndns&hostname=yourdns.3322.org"
根據IP查網卡位址 ：arping IP地址
根據IP查電腦名 ：nmblookup -A IP地址
查看當前IP地址 ：ifconfig eth0 |awk 『/inet/ {split($2,x,」:」);print x[2]}』
查看當前外網的IP地址 ：w3m -no-cookie -dump www.123cha.com|grep -o 『[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}』
查看當前監聽80埠的程式 ：lsof -i :80
查看當前網卡的物理位址：arp -a | awk 『{print $4}』
同一個網卡增加第二個IP位址 ：sudo ifconfig eth0:0 1.2.3.4 netmask 255.255.255.0
立即讓網路支援nat ：echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward; sudo iptables -t nat -I POSTROUTING -j MASQUERADE
查看路由資訊：netstat -rn 或 sudo route -n
手工增加一條路由 ：sudo route add -net 192.168.0.0 netmask 255.255.255.0 gw 172.16.0.1
手工刪除一條路由：sudo route del -net 192.168.0.0 netmask 255.255.255.0 gw 172.16.0.1
修改網卡MAC位址的方法 ：sudo ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE
統計當前IP連接的個數 ：netstat -na|grep ESTABLISHED|awk 『{print $5}』|awk -F: 『{print $1}』|sort|uniq -c|sort -r -n
遮罩IPV6 ：echo 『blacklist ipv6′ | sudo tee /etc/modprobe.d/blacklist-ipv6
察看當前網路連接狀況以及程式 ：sudo netstat -atnp
查看ADSL的當前流量：sudo ethstatus -i ppp0
查看功能變數名稱的註冊備案情況：whois baidu.cn
查看到某一個功能變數名稱的路由情況：tracepath baidu.cn
重新從伺服器獲得IP地址 ：sudo dhclient
下載網站文檔：wget -r -p -np -k http://www.xxx.com
如何5個線程下載：axel -n 5 http://www.xxx.com/downloadfile.zip
添加一個服務：sudo update-rc.d 服務名 defaults 99
刪除一個服務 ：sudo update-rc.d 服務名 remove
臨時重啟一個服務：/etc/init.d/服務名 restart
臨時關閉一個服務：/etc/init.d/服務名 stop
臨時啟動一個服務：/etc/init.d/服務名 start
增加用戶：sudo adduser 用戶名
刪除用戶：sudo deluser 用戶名
修改當前用戶的密碼：passwd
修改用戶密碼：sudo passwd 用戶名
修改用戶資料：sudo chfn userid
如何禁用某個帳戶：sudo usermod -L 用戶名 或 sudo passwd -l 用戶名
如何啟用某個帳戶：sudo usermod -U 用戶名 或 sudo passwd -u 用戶名
增加用戶到admin組：sudo usermod -G admin -a 用戶名
配置默認Java使用哪個 ：sudo update-alternatives –config java
終端設置代理 ：export http_proxy=http://xx.xx.xx.xx:xxx
修改系統登錄資訊：sudo vim /etc/motd
使用sun的java編譯器：sudo update-java-alternatives -s java-6-sun
切換輸入法引擎：im-switch -c
轉換檔案名由GBK為UTF8 ：convmv -r -f cp936 -t utf8 –notest –nosmart *
轉換檔內容由GBK到UTF8 ：iconv -f gbk -t utf8 $i > newfile
轉換 mp3 標籤編碼 ：sudo apt-get install python-mutagen;find . -iname '*.mp3' -execdir mid3iconv -e GBK {} \;
控制臺下顯示中文 ：sudo apt-get install zhcon;zhcon –utf8 –drv=vga
lftp 登錄遠端Windows中文FTP　：lftp :~>set ftp:charset GBK
PDF 文件亂碼 ：sudo apt-get install xpdf-chinese-simplified xpdf-chinese-traditional poppler-data
一屏查看檔內容 ：cat 檔案名
分頁查看檔內容：more 檔案名
可控分頁查看檔內容：less 檔案名
根據字串匹配來查看檔部分內容：grep 字串 檔案名
顯示包含字串的檔案名：grep -l -r 字串 路徑
顯示不包含字串的檔案名：grep -L -r 字串 路徑
快速查找某個檔：find 目錄 -name 檔案名
創建兩個空文件：touch file1 file2
遞迴式創建一些嵌套目錄：mkdir –p /tmp/xxs/dsd/efd
遞迴式刪除嵌套目錄：rm –fr /tmp/xxs
回當前用戶的宿主目錄：cd ~
查看當前所在目錄的絕對路經：pwd
列出當前目錄下的所有檔：ls -a
移動路徑下的檔並改名：mv 路徑/檔 /新路徑/新檔案名
複製檔或者目錄：cp -av 原文件或原目錄 新檔或新目錄
查看文件類型：file filename
對比兩個檔之間的差異：diff file1 file2
顯示xxx檔倒數6行的內容 ：tail -n 6 xxx
不停地顯示最新的內容 ：tail -n 10 -f /var/log/apache2/access.log
查看檔第五行到第10行的內容 ：sed -n 『5,10p』 /var/log/apache2/access.log
查找關於xxx的命令 ：apropos xxx 或 man -k xxx
通過ssh傳輸檔 ：scp -rp /path/filename username@remoteIP:/path
把所有檔的後輟由rm改為rmvb ：rename 』s/.rm$/.rmvb/』 *
把所有檔案名中的大寫改為小寫：rename 『tr/A-Z/a-z/』 *
刪除特殊檔案名 –help.txt 的文件：rm — –help.txt 或 rm ./–help.txt
查看當前目錄的子目錄：ls -d */. 或 echo */.
將最近30天訪問過的檔移動到上級back目錄 ：find . -type f -atime -30 -exec mv {} ../back \;
顯示一小時以內的包含 xxxx 的檔：find . -type f -mmin -60|xargs -i grep -l xxxx 『{}』
顯示最近2小時到8小時之內的檔：find . -mmin +120 -mmin -480 -exec more {} \;
刪除修改時間在30天之前的檔 ：find . -type f -mtime +30 -mtime -3600 -exec rm {} \;
刪除創建時間在30天之前的檔 ：find . -type f -ctime +30 -ctime -3600 -exec rm {} \;
刪除掉guest的以avi或rm結尾的檔：find . -name 『*.avi』 -o -name 『*.rm』 -user 『guest』 -exec rm {} \;
刪除掉不以java和xml結尾7天沒有使用的檔 ：find . ! -name *.java ! -name 『*.xml』 -atime +7 -exec rm {} \;
刪除所有的 .svn 目錄 ：find . -name .svn -type d -exec rm -fr {} \;
刪除所有以「~」結尾的暫存檔案 ：find . -name 『*~』 -exec rm {} \;
統計當前文件個數：ls .|wc -w
統計當前目錄個數：ls -l |grep ^d|wc -l
顯示當前目錄下2006-01-01的檔案名 ：ls -l |grep 2006-01-01 |awk 『{print $8}』
使用ssh方式同步遠端資料到本地目錄 ：rsync -Pa -I –size-only –delete –timeout=300 Remote_IP:/home/ubuntu /backup
增加 7Z 壓縮軟體：sudo apt-get install p7zip p7zip-full p7zip-rar
增加 rar 軟體壓縮和解壓縮支援 ：sudo apt-get install rar unrar
解壓縮 xxx.tar.gz ：tar -zxvf xxx.tar.gz
解壓縮 xxx.tar.bz2 ：tar -jxvf xxx.tar.bz2
壓縮aaa bbb目錄為xxx.tar.gz ：tar -zcvf xxx.tar.gz aaa bbb
壓縮aaa bbb目錄為xxx.tar.bz2 ：tar -jcvf xxx.tar.bz2 aaa bbb
增加 lha 支援 ：sudo apt-get install lha
增加解 cab 檔支援 ：sudo apt-get install cabextract
顯示日曆：cal
設置日期：date -s mm/dd/yy
設置時間：date -s HH:MM
將時間寫入CMOS ：hwclock –systohc
查看CMOS時間 ：hwclock –show
讀取CMOS時間 ：hwclock –hctosys
從伺服器上同步時間 ：sudo ntpdate ntp.ubuntu.com
設置電腦的時區為上海：sudo cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
關閉UTC，將當前時間寫入CMOS。：sudo sed -ie 』s/UTC=yes/UTC=no/g』 /etc/default/rcS;sudo hwclock –systohc
修改mysql的root口令 ：sudo mysqladmin -u root -p password 『你的新密碼』
如何使用命令關閉顯示器 ：xset dpms force off
設置CPU的頻率 ：sudo apt-get install cpufrequtils;sudo cpufreq-info
命令關機：sudo halt
現在關機：sudo shutdown -h now
晚上11點自動關機：sudo shutdown -h 23:00
60分鐘後關機：sudo shutdown -h +60
命令重啟電腦：sudo reboot
現在重啟電腦：sudo shutdown -r now
關閉筆記本的觸摸板 ：synclient touchpadoff=1
開啟筆記本的觸摸板：synclient touchpadoff=0
統計每個單詞的出現頻率並排序 ：awk 『{arr[$1]+=1 }END{for(i in arr){print arr[i]「\t」i}}』 FILE_NAME | sort -rn
統計80埠的連接並排序 ：netstat -na|grep :80|awk 『{print $5}』|awk -F: 『{print $1}』|sort|uniq -c|sort -r -n
把終端加到右鍵功能表：sudo apt-get install nautilus-open-terminal
如何刪除Totem電影播放機的播放歷史記錄 ：rm ~/.recently-used
vim 如何顯示彩色字元 ：sudo cp /usr/share/vim/vimcurrent/vimrc_example.vim /usr/share/vim/vimrc
讓 vim 直接支援編輯 .gz 文件 ：sudo apt-get install vim-full
vim 如何顯示行號：:set number
查看在會話設置的啟動程式：ls ~/.config/autostart
提高wine的反應速度 ：sudo sed -ie 『/GBK/,/^}/d』 /usr/share/X11/locale/zh_CN.UTF-8/XLC_LOCALE
製作ISO文件：mkisofs -o test.iso -Jrv -V test_disk /home/carla/
延遲10秒抓圖：gnome-screenshot -d 10
延遲5秒抓當前啟動窗口：gnome-screenshot -w -d 5
如何命令行刻錄：cdrecord -scanbus;cdrecord -v -eject speed=8 dev=1,1,0 test.iso
回收站在哪裡：~/.local/share/Trash/
默認打開方式的配置檔在哪裡：~/.local/share/applications/mimeapps.list
如何查看HTTP頭：w3m -dump_head http://www.xxx.com
連續監視記憶體使用情況：watch -d free
如何切換到root帳號：sudo -Hs
唯讀掛載ntfs分區：sudo mount -t ntfs -o nls=utf8,umask=0 /dev/sdb1 /mnt/c
可寫掛載ntfs分區：sudo mount -t ntfs-3g -o locale=zh_CN.utf8,umask=0 /dev/sdb1 /mnt/c
掛載fat32分區：sudo mount -t vfat -o iocharset=utf8,umask=0 /dev/sda1 /mnt/c
掛載共用檔：sudo mount -t smbfs -o username=xxx,password=xxx,iocharset=utf8 //192.168.1.1/share /mnt/share
掛載ISO文件：sudo mount -t iso9660 -o loop,utf8 xxx.iso /mnt/iso
帶行號顯示檔的內容：nl 檔案名
批量將rmvb轉為avi：for i in *; do mencoder -oac mp3lame -lameopts vbr=3 -ovcxvid -xvidencopts fixed_quant=4 -of avi $i -o `echo $i | sed -e』s/rmvb$/avi/』`; done
批量將svg轉為png：for i in *; do inkscape $i –export-png=`echo $i | sed -e 』s/svg$/png/』`; done
批量縮小圖片到30%：for i in *; do convert -resize 30%x30% $1 sm-$1; done
批量轉換jpg到png：for i in *; do convert $i `echo $i | sed -e 』s/jpg$/png/』`; done
獲取jpg的擴展資訊(Exif)：identify -verbose xxx.jpg
查看當前系統所有的監聽埠：nc -zv localhost 1-65535
去掉文件中的^M：cat filename | tr -d 「^M」 > newfile
去掉文件中的^M：sed -e 「s/^M//g」 filename > newfile
轉換bin/cue到iso檔：sudo apt-get install bchunk;bchunk image.bin image.cue image
轉換目錄到iso檔：mkisofs dirname -o isofile.iso
轉換CD到iso檔：dd if=/dev/cdrom of=isofile.iso
ape 轉換為flac：sudo apt-get install flac shntool;shntool split -t「%n.%p-%t」 -f example_UTF-8.cue -o flac example.ape -d flacOutputDir
ape轉換為 mp3：sudo apt-get install flac shntool lame;shntool split -t「%n.%p-%t」 -f example_UTF-8.cue -o 『cust ext=mp3 lame –r3mix -b 320–quiet – %f』 example.ape -d mp3OutputDir
檢查本地是否存在安全隱患：sudo apt-get install rkhunter;rkhunter –checkall
如何安裝殺毒軟體：sudo apt-get install clamav;clamscan -r ~/
查看網路連接狀態：netstat -n | awk 『/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}』
統計程式的記憶體耗用：ps -eo fname,rss|awk 『{arr[$1]+=$2} END {for (i in arr) {print i,arr[i]}}』|sort -k2 -nr
顯示當前記憶體大小：free -m |grep 「Mem」 | awk 『{print $2}』
按記憶體從大到小排列進程：ps -eo 「%C : %p : %z : %a」|sort -k5 -nr
按cpu利用率從大到小排列進程：ps -eo 「%C : %p : %z : %a」|sort -nr
統計當前目錄下所有jpg檔的尺寸：find . -name *.jpg -exec wc -c {} \;|awk 『{print $1}』|awk 『{a+=$1}END{print a}』
清除僵死進程：ps -eal | awk 『{ if ($2 == 「Z」) {print $4}}』 | sudo kill -9
CD 抓軌為 mp3 (有損)：sudo apt-get install abcde;abcde -o mp3 -b
CD 抓軌為 Flac (無損)：sudo apt-get install abcde;abcde -o flac -b


/******************************************************************************/
安裝 Samba 伺服器 *
/******************************************************************************/
Samba 這個套件的功用，可以讓你把 Linux 伺服器變成 Windows 裡的「網路上的芳鄰」中的一台電腦，提供檔案伺服器的服務，
即使在沒有網域管理(Domain)的區域網路環境中，也可以提供比 Windows 網路上的芳鄰更多的權限控管。

本教學只介紹兩種常用的配置方式:
開放式的設定
需要身份驗證的設定
安裝好 Samba 套件之後，就可以開始進行設定了。

安裝 Samba
使用 Apt 安裝 Samba 套件:
sudo apt-get install samba
啟用 Samba 服務:
service smb start
爾後如果有修改 Samba 的設定，只要輸入下列指令重新載入即可:
service smb reload
//-----------------------------------------------------------------
開放式的設定
//-----------------------------------------------------------------
開放式的意思，就是不用任何身份驗證，就可以存取提供 Samba 服務的伺服器。以下的範例，是設定區域網路裡的任何用戶都可存取伺服器，並分享 [/tmp] 裡的檔案:
編輯 /etc/samba/smb.conf，設定如下:
[global]
#欲加入的群組名稱
workgroup = WORKGROUP
#在「網路上的芳鄰」顯示的電腦名稱，如果不設定，就會以目前的 HostName 去掉網域名稱顯示。
netbios name = FileServer
#伺服器的註解
server string = Samba 檔案伺服器
#設定哪些電腦可以存取伺服器(以空白隔開)
hosts allow = 192.168.1.0/255.255.255.0 127.0.0.1
#顯示繁體中文
client code page = 950
#身份驗證的方式
security = share

#分享 [/tmp]
[tmp]
  path = /tmp
  comment = 檔案暫存區
  public = yes
  writable = yes
  create mode = 0666
  directory mode = 0777
重新啟動 Samba 服務:
service smb restart

//-----------------------------------------------------------------
需要身份驗證的設定
//-----------------------------------------------------------------
如果你希望用戶要連到伺服器時，必須先輸入帳號、密碼才可以進入，並且可以存取自己的家目錄及 [/tmp]，請依照下列設定:
編輯 /etc/samba/smb.conf，設定如下:
[global]
#欲加入的群組名稱
workgroup = WORKGROUP
#在「網路上的芳鄰」顯示的電腦名稱，如果不設定，就會以目前的 HostName 去掉網域名稱顯示。
netbios name = FileServer
#伺服器的註解
server string = Samba 檔案伺服器
#設定哪些電腦可以存取伺服器(以空白隔開)
hosts allow = 192.168.1.0/255.255.255.0 127.0.0.1
#顯示繁體中文
client code page = 950
#身份驗證的方式
security = user
#將密碼加密傳輸
encrypt passwords = yes
#指定密碼檔位置
smb passwd file = /etc/samba/smbpasswd

#讓用戶可以存取自己的家目錄
[homes]
  comment = 個人資料夾
  public = no
  browseable = no
  valid users = %S
  writable = yes
  create mode = 0600
  directory mode = 0700

#分享 [/tmp]
[tmp]
  path = /tmp
  comment = 檔案暫存區
  public = no
  writable = yes
  create mode = 0666
  directory mode = 0777
建立 Samba 的密碼檔，並轉換用戶到這個密碼檔:
cat /etc/passwd | mksmbpasswd.sh > /etc/samba/smbpasswd
chmod 600 /etc/samba/smbpasswd
chown root.root /etc/samba/smbpasswd
重新啟動 Samba 服務:
service smb restart
你必須要再設定用戶的密碼才可以存取:
smbpasswd UserName

//-----------------------------------------------------------------
其它有用的參數
//-----------------------------------------------------------------
以下介紹其它有用的參數，這些參數必須放在宣告的分享資源的區段下:
public = yes|no
設定針對 Guest 是否「顯示」該分享項目。
browseable = yes|no
設定是否「顯示」分享項目。
valid users = 用戶列表
允許「檢視」該分享項目的用戶，可輸入「用戶名稱」或「@群組名稱」，如有多個項目，請用「,」分隔。
invalid users = 用戶列表
不允許「檢視」該分享項目的用戶，可輸入「用戶名稱」或「@群組名稱」，如有多個項目，請用「,」分隔。
read only = yes|no
是否唯讀。
writable = yes|no
是否可以寫入。
write list = 用戶列表
允許「寫入」該分享項目的用戶，可輸入「用戶名稱」或「@群組名稱」，如有多個項目，請用「,」分隔。
create mode = 權限
建立檔案時預設的權限。
directory mode = 權限
建立目錄時預設的權限。
force user = 用戶名稱
建立檔案或目錄時預設的用戶。
force group = 群組名稱
建立檔案或目錄時預設的群組。
Samba 的變數

%S: 取代目前的「資源名稱」，所謂的「資源名稱」就是在 [ ] 裡面的內容。
ex: valid users = %S
%U: 代表目前登入的使用者的使用者名稱。
%m: 代表 Client 端的 NetBIOS 名稱。
%g: 代表登入的使用者的群組名稱。
%M: 代表 Client 端的 Internet 主機名稱，就是 HOSTNAME。
%L: 代表 SAMBA 主機的 NetBIOS 名稱。
%h: 代表目前這部 SAMBA 主機的 HOSTNAME。
%H: 代表使用者的家目錄。
%I: 代表 Client 端的 IP。
%T: 代表目前的日期與時間。
新增 Samba 用戶

關於 Samba 上的用戶帳號，有一些規則要說明:

Samba 上的用戶帳號必須是已存在於 Linux 系統的帳號。
Linux 系統與 Samba 用戶的密碼是不同的，它們有各自的密碼檔。
Samba 的密碼檔位於 /etc/samba/smbpasswd。
因此，如果你要新增 Samba 用戶，你就必須先在 Linux 系統增加一個本機用戶，新增本機用戶之後，再輸入下列指令將用戶的帳號及密碼加入至 Samba 的密碼檔:

smbpasswd -a UserName
以後如果只是要變更該用戶的密碼，只要輸入:

smbpasswd UserName
用戶自行變更密碼

原本 Samba 有提供一個 Swat 套件，就是 Samba 的網頁管理介面，不過，我覺得似乎不太夠用(給管理者用還可以)。如果我希望用戶可以自行變更 Linux 系統的密碼，並同步變更 Samba 的密碼，那就要試試 ChangePassword 套件:

從本站下載 ChangePassword 套件至 [/tmp]
cd /tmp
wget http://www.vixual.net/download/source/ChangePassword/changepassword-0.9.tar.gz
tar -xzvf changepassword-0.9.tar.gz
cd changepassword-0.9
./configure --enable-cgidir=/var/www/cgi-bin --enable-smbpasswd=/etc/samba/smbpasswd --disable-squidpasswd
請注意，上面(第 5 行)的 「/var/www/cgi-bin」 請改為你的網站的 cgi-bin 路徑。
然後繼續下列步驟:
make
make install
這樣就安裝完成了，以後你就可以到 「http://host.example.com/cgi-bin/changepassword.cgi」 同步變更 Linux 系統及 Samba 的密碼。

網頁管理介面
這個套件(Swat)其實不是那麼必要(尤其是有了上面的 ChangePassword 套件之後)，但仍然列出安裝步驟給大家參考:
安裝 Samba-Swat 套件:
apt-get install samba-swat
編輯 /etc/xinetd.d/swat，搜尋:
disable = yes
改成:
disable = no
繼續搜尋:
only_from = 127.0.0.1
改成允許連線的位址:
only_from = 192.168.1.0/24
重新啟動 Xinetd:
service xinetd restart
從瀏覽器輸入連線位址:
http://host.example.com:901/


/******************************************************************************/
Apache Http Server
/******************************************************************************/
一. 特性
最有名的網站伺服器
不需收費的軟體
可以在Ms windows平台與Linux平台上執行
模組化的功能調整，支援動態載入模組
安裝容易, 可用命令列與圖形介面安裝
http://www.apache.org
　
二. 啟動與停止
若要啟動Apache，可執行以下指令：
/etc/init.d/apache2 start
若要停止Apache，可執行以下指令：
/etc/init.d/apache2 stop
當有設定改變, 若要重新啟動Apache，可執行以下指令：
/etc/init.d/apache2 restart
　
三. Apache伺服器目錄結構
當安裝完Apache後, 相關的檔案與目錄結構如下:
可執行檔        /usr/sbin  
設定檔          /etc/apache2/*
資料網頁的預設根目錄    /var/www
模組檔案        /usr/lib/apache2/modules
記錄檔          /var/log/apache2/*
服務啟動檔案    /etc/init.d/apache2
狀態檔          /etc/run/apache2.pid
　
四. 測試Apache是否安裝完成
測試Apache是否安裝完成:
輸入http://127.0.0.1, 或http://主機的IP位址.
可以顯示網頁表示成功.Y
　
Apache伺服器預設的相關設定:
使用者帳號:www-data(UID:33)
群組：www-data (GID:33)
資料網頁的預設根目錄與檔案：/var/www/index.html
　
設定練習:
建立一個網頁如http://127.0.0.1/test/test.html
1.試著改變/var/www/test資料夾的權限為700、744、755，
測試是否能夠正常連到http://127.0.0.1/test/test.html
2.試著改變檔案test.html的權限為700、744、755，
測試是否能夠正常連到http://127.0.0.1/test/test.html
　
五. Apache2伺服器設定檔
主要設定檔：/etc/apache2/apache2.conf
定義Apache伺服器的主要行為與環境變數
apache2.conf中可以引入(include)的其他設定檔, 如下說明：
Apache環境變數                                  /etc/apache2/envvars
網頁伺服器的變數設定：逾時值、最大連線數等…    /etc/apache2/httpd.conf
Apache監聽的IP位址與通訊埠(port)                /etc/apache2/ports.conf
可用虛擬主機的設定檔目錄                        /etc/apache2/sites-available/
已啟用的虛擬主機的設定檔目錄                    /etc/apache2/sites-enabled/
使用者自訂的的設定檔                            /etc/apache2/conf.d
可用模組(module)的目錄                          /etc/apache2/mods-available/
已啟用模組的目錄                                /etc/apache2/mods-enabled/
　
六.啟動或關閉模組 (module)
如果要啟動模組，可以先在 mods-available 裡面寫好不同的模組設定檔。
當需要啟用這些模組時，再在mods-enabled目錄中建立 soft link 連接到 mods-available 來啟用。
察看可用模組(mods-available)設定檔：
cyut@ubuntu:~$ ls /etc/apache2/mods-available/
auth_dbm.load     deflate.load     ssl.conf            ssl.load
auth_ldap.load    expires.load     php5.conf           suexec.load
cache.load        ext_filter.load  php5.load           unique_id.load
???(略)???
察看啟用模組(mods-enabled)設定檔：
cyut@ubuntu:~$ ls -l /etc/apache2/mods-enabled/ 
...略...    cgi.load -> /etc/apache2/mods-available/cgi.load
...略...    php5.conf -> /etc/apache2/mods-available/php5.conf
...略...    php5.load -> /etc/apache2/mods-available/php5.load
...略...    userdir.conf -> /etc/apache2/mods-available/userdir.conf
...略...    userdir.load -> /etc/apache2/mods-available/userdir.load
如以上範例，我們可以看到 Apache2有很多模組可以使用。當啟用 PHP或其他模組時, 可以發現這些啟用的模組
只不過是個符號連結檔，這些檔案會連接到 mods-availabe 裡面，只要刪除這些連結檔，就會關閉模組的使用。
其中模組有 load 和 conf 兩個檔，前者是負責讀入該模組的函式庫，後者是該模組的設定檔，所以啟用或刪除時
要兩個都建立或刪除符號連結。
　
關閉 PHP 模組範例 (刪除符號連結法)：
rm /etc/apache2/mods-enabled/php5.load
rm /etc/apache2/mods-enabled/php5.conf
/etc/init.d/apache2 restart
啟用 PHP 模組範例 (建立符號連結法)：
ln -s /etc/apache2/mods-available/php5.load /etc/apache2/mods-enabled/php5.load
ln -s /etc/apache2/mods-available/php5.conf /etc/apache2/mods-enabled/php5.conf
/etc/init.d/apache2 restart

在 Ubuntu 裡面也有程式可以管理模組的啟動與關閉。
關閉 PHP 模組範例 ：
a2dismod php5
/etc/init.d/apache2 restart
啟用 PHP 模組範例 ：
a2enmod php5
/etc/init.d/apache2 restart

六.啟動或關閉虛擬主機 (sites)
Apache2 安裝好以後，系統裡面只有一個虛擬主機(站台)，也就是預設根目錄在 /var/www 的那個網站。
如果有需要, Apache2可以建立多個虛擬站台。
察看可用的站台：
cyut@ubuntu:~$  ls /etc/apache2/sites-available/
default  
察看啟用的站台：
cyut@ubuntu:~$ ls -l /etc/apache2/sites-enabled/
...略...   000-default -> /etc/apache2/sites-available/default
如以上範例，我們看到符號連結和之前模組啟用與關閉一樣，
所以也可以直接建立或刪除符號連結，或者用工具程式進行啟用與關閉。
　
七.增加虛擬主機 
虛擬主機(Virtual Host) 的定義是一台 Apache 主機可以處理超過一個 domain，
例如有兩個網址都同時對應到該主機 IP，而主機能依照網址不同給與不同的網頁。
所以用這種方式可以在同一台主機上架很多網站。
Client 和 Server 溝通時，在 HTTP 1.1 協定中規定 Client 要在表頭送出 Host
告訴 Server 是要連到哪一個主機，因此 Server 可以依據這個判定要送回的網頁是哪一個。
若要建立新的虛擬主機，首先要確定的是該網域已經設定好 DNS 紀錄，並將該紀錄指向主機的 IP。
以下假設新增的虛擬主機 之網址是 www.cyut.org，而虛擬主機網頁放置的地方是 /home/cyut。

設定練習:
由於預設主機的設定檔 default 已經是很完整的架構，我們就直接用它來當範本稍微修改給虛擬主機用。
步驟一: 複製範本 
cd /etc/apache2/sites-available
cp default cyut           # 這個 cyut 是自己設定的，可以自己命名
步驟二: 編輯這個新的設定檔。 
新的虛擬主機 /etc/apache2/sites-enabled/cyut 設定檔如下： 
# NameVirtualHost *                       # 這一行要註解起來
DocumentRoot /home/cyut            # 修改網頁放置的根目錄
ServerName www.cyut.org             # 加入該虛擬主機所傾聽的網域
<Directory /home/cyut>             # 修改定義網頁權限的路徑
Options Indexes FollowSymLinks MultiViews
AllowOverride None
Order allow,deny
allow from all
</Directory>
 
簡單的說，只有要改 4 個地方，先註解掉 NameVirtuHost 後，再修改兩個和根目錄有關的路徑，
還有加入新設定 ServerName，其他的地方都可以不需要更動。
啟用新的虛擬主機站台： 
a2ensite cyut
/etc/init.d/apache2 restart
關閉 cyut 站台範例：
a2dissite cyut
/etc/init.d/apache2 restart

八. apache2.conf 設定 
這裡精選在 apache2.conf 裡面比較重要的設定。
# Apache Server 設定檔放置處
ServerRoot "/etc/apache2"      
# Client 多久沒回應就 timeout，網路狀態不好可改大一點。
Timeout 300                  
# KeepAlive 為是否開啟連續請求的功能，當打開時每次 Client 端建立連線後，
# 可以要求數個檔案，而不必要重新建立連線。建議把它打開，會有比較好的效能。
KeepAlive On
# MaxKeepAliveRequests 是每次 Client 端建立連線後，可以要求最大的檔案數，
# 讀者設成 0 為不限制，或者可以把它設高一點，尤其是在網頁很複雜的時候，
# 效能會有明顯改善。通常設 100 到 300 之間已經很夠用啦！
MaxKeepAliveRequests 100
# KeepAliveTimeout 是當連續請求時，Clinet 端多久沒有在繼續請求就把他踢下線。
# 這個單位是秒鐘，不要開太大，不然資源可以會被這些不請求的 Client 端佔著。
KeepAliveTimeout 15
# StartServers 為 Apache2 啟動時，會啟用幾個 processes，讀者可以透過 ps -aux
# 來驗證。若您的網站流量很大，可以改大一點，但是若用量沒有那麼大，會浪費
# 系統資源，通常預設的 5 已經很夠用了。
# MinSpareServers 可閒置的最少 processes，通常都會設定的和 StartServers 一樣。
# MaxSpareServers 最大可閒置的 processes，若您的網站流量時大時小，那麼這個值
# 可以設大一點，避免人多的時候要開新的 processes，但是設太大會增加系統資源。
# MaxClients 最多可以有幾個用戶端連線，預設的 20 似乎有點少，可以視您網站的
# 規模改到 200 以上。但是預設不能超過 256，若要超過的話需要自己額外加上
# ServerLimit 的參數，定義最大可以有幾個 Client，這個值最大到 20000，若
# 還要在大的話就要修改原始碼的定義。
# MaxRequestsPerChild 每一個 processes 可以有多少個連線數要求。通常設成 0 為
# 不限制。　　 
<IfModule prefork.c>
StartServers         5
MinSpareServers      5
MaxSpareServers     10
# ServerLimit       3000   # 若 MaxClient 要大於 256，需要有這一個參數。
MaxClients          20
MaxRequestsPerChild  0
</IfModule>
# 在設定檔內，還有其他 MPM 可以修改，如 worker 和 perchild 等，但這些在有
# PHP 的環境下不會使用到，所以讀者可以不要管他們。
# Apache2 Server 執行時所用的帳號和群組，若沒有特別的理由，可以不用更動。
User www-data
Group www-data
# 全域的錯誤紀錄檔放置處，個別虛擬主機的設定可以在 sites-available 另外指定。
ErrorLog /var/log/apache2/error.log
# 後面那些 AddCharset 是指可以支援的編碼，預設都設好了，不要改動。
#AddDefaultCharset      Big5
AddCharset utf-8       .utf8
AddCharset big5        .big5 .b5
# 若沒有明確指定網頁檔名，Apache2 會依序以下順序來嘗試送給 client 端瀏覽器
DirectoryIndex index.html index.cgi index.pl index.php index.xhtml
操作練習:
試著在瀏覽器打入：http://127.0.0.1/error這個不存在的連結，
檢視看看/var/log/apache2/error.log 的檔案內容有沒有改變？
　
九. 個別虛擬主機或網站的設定
在 apache2.conf 只作一些全域的設定，若要設定個別虛擬主機或網站的設定，
需要修改的地方就在 /etc/apache2/sites-available/ 裡面。
這裡介紹預設的網站 default 裡面的架構，其他額外增加的虛擬主機設定方式是一樣的。
預設網頁 /etc/apache2/sites-available/default 的設定檔如下：

NameVirtualHost *
<VirtualHost *>
        ServerAdmin dbtsai@localhost        # 網頁管理者 E-Mail
        DocumentRoot /var/www              # 網頁放置的根目錄

# Options 裡面可以有許多參數，以下將個別簡介。
#   Indexes    　    當 Client 找不到 index.html 等首頁時，就列出該目錄底下
#                    所有檔案。因此有一點危險性存在，通常是建議關閉。
#   FollowSymLinks   讓您在該目錄底下可以讀取到符號連結到非網頁根目錄內的
#                    檔案。例如現在根目錄是 /var/www，我們建立一個從 
#                     /home/web 建立一個 soft link 到 /var/www/web 後，
#                     若有開啟這個選項，才能讀取到 /var/www/web 的內容。
#   MultiViews       提供同一個網址有多國語言的功能。原來是依照 Client 送來
#                    的語言偏好 header 送回不同語言版本的網頁。例如 Google
#                    就是採用這種方式達成同一網址有多國語言的功能。  
#
# AllowOverride 和 .htacces 有關。 .htaccess 可以在網頁目錄下取代全域的 
# 網站設定，這樣的好處是可以讓一般使用者不用有 root 權限就可以修改
# 參數，使用彈性也會比較大。它可以設定的參數有以下幾個。
#    AuthConfig      可以在 .htaccess 裡面設定網頁認證的功能
#    Options         可以在 .htaccess 裡面重設 Options 選項
#    All             以上所有功能都能在 .htaccess 被重設
#    None            不使用 .htaccess 來重設變數

        <Directory /var/www/>              # 定義該目錄的網頁權限
                Options Indexes FollowSymLinks MultiViews
                AllowOverride None
                Order allow,deny
                allow from all
        </Directory>

# 設定 CGI 程式相關參數
        ScriptAlias /cgi-bin/ /usr/lib/cgi-bin/
        <Directory "/usr/lib/cgi-bin">
                AllowOverride None
                Options +ExecCGI -MultiViews +SymLinksIfOwnerMatch
                Order allow,deny
                Allow from all
        </Directory>
# 錯誤紀錄檔放置的地方
        ErrorLog /var/log/apache2/error.log

# 錯誤紀錄檔的紀錄層級，不同的設定會有不同的紀錄精細度。
        LogLevel warn

# 瀏覽紀錄檔的放置處，裡面紀錄了 Client 端詳細資訊
        CustomLog /var/log/apache2/access.log combined
        ServerSignature On

</VirtualHost>
　

操作練習:

當 Client 找不到 index.html 等首頁時，就列出該目錄底下所有檔案。因此有危險性存在，建議關閉。

關閉方法如下:

找出下列設定, 在Index前面加上-號, 例如 -Index, 再重新啟動Apache即可。

Options Indexes FollowSymLinks MultiViews

接者進行測試, 重新連結網頁, 若找不到 index.html 等首頁時，就禁止看目錄內容了。

　

十. 啟用個人網頁 

Apache2 把使用者個人網頁獨立到一個額外的模組和設定檔。 

啟用個人網頁： 
 a2enmod userdir
 /etc/init.d/apache2 restart
 
關閉個人網頁： 
 a2dismod userdir
 /etc/init.d/apache2 restart
 
　

個人網頁的設定可以不需要修改, 相關參數如下。
 
個人網頁設定檔 /etc/apache2/mods-available/userdir.conf： 
<IfModule mod_userdir.c>
# 在使用者家目錄底下的 public_html 為個人網頁目錄
        UserDir public_html        
 
# 關閉 root 不能使用個人網頁
        UserDir disabled root

# 以下是預設的個人網頁目錄設定，若讀者要修改成不是放在 public_html 的話，
# 要同時修改 UserDir 和 以下的 Directory 裡面的目錄位置。
        <Directory /home/*/public_html>
                AllowOverride FileInfo AuthConfig Limit
                Options MultiViews Indexes SymLinksIfOwnerMatch IncludesNoExec
        </Directory>
</IfModule>
 
設定好了以後，一般使用者可以在自己家目錄底下建立 public_html 的目錄來存放網頁，
並且瀏覽器可以透過 http://127.0.0.1/~UserName/ 來連到該使用者的個人網頁，其中 UserName 是使用者的帳號。
　
操作練習:
啟用UserDir的Apache模組，並試著建立一個網頁，能夠在以"http://127.0.0.1/~帳號/" 的網址連線。
　

/******************************************************************************/
MySQL指令大全 :
/******************************************************************************/
基本指令 :
資料定義語言 ( DDL ) :
建立資料庫或資料表 :   create
更變資料庫或資料結構 :   alter
刪除資料庫或資料表 :   drop
 
資料操作語言 ( DML ) :
查詢資料 :   select
插入資料 :   insert
更新資料 :   update
刪除資料 :   delete
 
資料控制語言 ( DCL ) :
確定資料的更變 :   commit
設定使用者對資料的操作權限 :   grant
取消使用者操作資料的權限 :   revoke
取消資料更變 :   rollback
 
實用指令 :
顯示所有資料庫 :   show databases;
選擇某一資料庫 :   use 資料庫名稱;
列出資料庫底下的資料表 : show table from 資料庫名稱;
顯示目前正在使用的資料表 :   show tables;
顯示資料表欄位設定 :   describe 資料表名稱;
重新整理資料表 :   optimize table 資料表名稱;
顯示某個資料表的欄位設定 :   show columns from 資料表名稱;
顯示某個資料表的索引欄位設定 :   show index from 資料表名稱;
 
顯示 :
1.顯示所有資料庫 :   show databases;
2.顯示資料庫底下的資料表 : show table from 資料庫名稱;
3.顯示資料表的欄位 :   show columns from 資料表名稱;
顯示目前正在使用的資料表 :   show tables;
顯示資料表欄位設定 :   describe 資料表名稱;
顯示某個資料表的索引欄位設定 :   show index from 資料表名稱;
 
新增 :
1.新增資料庫 : create database 資料庫名稱;
2.新增資料表 : create table 資料表名稱 ( 欄位名稱1 資料型態,欄位名稱2 資料型態 );
3.新增欄位 : alter table 資料表名稱 add 欄位名稱 資料型態;
 
修改 :
3.修改資料表 : alter table 舊資料表名稱 rename 新資料表名稱; 
修改欄位刪除 : alter table 資料表名稱 drop 欄位名稱
刪除 :
1.刪除資料庫 : drop database 資料庫名稱;
2.刪除資料表 : drop table 資料表名稱;
3.刪除欄位 : drop 欄位名稱;


/******************************************************************************/
Ubuntu 14.04 安裝Redmine及整合Git環境之快速偷懶篇        2015-05
/******************************************************************************/
ref: http://blog.sina.com.cn/s/blog_4a2ee3fb0102vjyl.html
現在網上轉來轉去的文章太不靠譜，坑太多，填坑填得心很憔悴。
這篇文章在我填坑埋土大半天後寫成，已經反覆測試過3遍，整個過程只需要手動copy即可。
系統環境為 Ubuntu 14.04 LTS ，不保證其他版本依然有效，但仍可作為有效參考。
一、準備工作
# 首先升級套裝軟體
sudo apt-get update
sudo apt-get upgrade
# 安裝LAMP環境
sudo apt-get install tasksel
sudo tasksel   ---> install LAMP
sudo apt-get install phpmyadmin
二、安裝 Redmine
sudo apt-get install redmine-mysql
sudo apt-get install redmine
sudo apt-get install imagemwagick #可選
sudo gem install bundler
#安裝後主要目錄結構如下：
#redmine目錄：/usr/share/redmine/
#配置文件目錄：/etc/redmine/default/
#日誌文件目錄：/var/log/redmine/
三、安裝Email
sudo apt-get install postfix  #Select "Internet Site"
四、一些必要的權限配置
#程式啟動時需要創建配置文件及log，給他權限
sudo chmod 775 /etc/redmine/default/
sudo chmod -R 775 /var/log/redmine/
sudo mkdir /usr/share/redmine/tmp
sudo chmod -R 775 /usr/share/redmine/tmp
#sudo mkdir /usr/share/redmine/public/plugin_assets # 如果需要安裝plugin
#sudo chmod 775 /usr/share/redmine/public/plugin_assets
sudo mkdir /usr/share/redmine/files
sudo chmod 775 /usr/share/redmine/files
#為整合apache做準備
sudo chown -R www-data:www-data /usr/share/redmine
五、使用 webrick 測試
sudo ruby /usr/share/redmine/script/rails server webrick -e production
#默認連接埠是3000，例如訪問http://git.mimiz.cn:3000/ 查看效果
六、配置Apache
sudo apt-get install libapache2-mod-passenger
sudo ln -s /usr/share/redmine/public /var/www/redmine
sudo vi /etc/apache2/sites-available/redmine.conf
#增加一行：RailsBaseURI /redmine
sudo vi /etc/apache2/sites-enabled/000-default.conf
#修改web根目錄為：DocumentRoot /var/www
#增加一行：ServerName localhost
sudo vi /etc/apache2/mods-available/passenger.conf
#增加一行：PassengerDefaultUser www-data
sudo a2ensite redmine
service apache2 reload
sudo service apache2 restart
七、配置 Redmine
#創建config配置文件
sudo cp /usr/share/redmine/config/configuration.yml.example /etc/redmine/default/configuration.yml
#編輯config文件
sudo vi /etc/redmine/default/configuration.yml
#查找修改以下內容：
production:    
     email_delivery:
     delivery_method: :sendmail 
attachments_storage_path: /usr/share/redmine/files 
scm_stderr_log_file: /var/log/redmine/redmine_scm_stderr.log
sudo service apache2 restart #重啟生效
八、安裝 Git
sudo apt-get install git git-core
#一些簡單的設置
git config --global user.name 「mimi」
git config --global user.email 「mimi@mimiz.cn」
#查看設置
git config --list
九、為Redmine創建版本庫
#為圖方便我創建到Redmine目錄中
sudo mkdir /usr/share/redmine/gitrepo
sudo mkdir /usr/share/redmine/gitrepo/project1
cd /usr/share/redmine/gitrepo/project1
sudo git init –bare
#給他權限，同樣為了方便我設置777
sudo chmod -R 777 /usr/share/redmine/gitrepo/
sudo chown -R www-data:www-data /usr/share/redmine
十、在Redmine系統中設置版本庫路徑
在Redmine系統中，path 路徑要填系統的絕對路徑 /usr/share/redmine/gitrepo/project1
這裡有個大坑，需要commit一次代碼才能顯示出來，否則總是顯示404：
The entry or revision was not found in the repository
十一、本地連接Git
#這裡的username是你ssh登錄系統的username
username@server-ip:/usr/share/redmine/gitrepo/project1
十二、如果你想修改目錄
#參考這篇文章：
http://www.redmine.org/projects/redmine/wiki/HowTo_Install_Redmine_in_a_sub-URI
sudo vi /usr/share/redmine/config/environment.rb
在文件最後一行添加：
Redmine::Utils::relative_url_root = 「/path」


/******************************************************************************/
Cargo, Rust's Package Manager
/******************************************************************************/
Installing
The easiest way to get Cargo is to get the current stable release of Rust by using the rustup script:
$ curl -sSf https://static.rust-lang.org/rustup.sh | sh

This will get you the current stable release of Rust for your platform along with the latest Cargo.
If you are on Windows, you can directly download the latest 32bit (Rust and Cargo) or 64bit (Rust and Cargo) Rust stable releases or Cargo nightlies.
Alternatively, you can build Cargo from source.

Let's Get Started
To start a new project with Cargo, use cargo new:
$ cargo new hello_world --bin
We're passing --bin because we're making a binary program: if we were making a library, we'd leave it off.
Let's check out what Cargo has generated for us:
$ cd hello_world
$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
This is all we need to get started. First, let's check out Cargo.toml:

[package]
name = "hello_world"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
This is called a manifest, and it contains all of the metadata that Cargo needs to compile your project.

Here's what's in src/main.rs:

fn main() {
    println!("Hello, world!");
}
Cargo generated a 'hello world' for us. Let's compile it:

$ cargo build
   Compiling hello_world v0.1.0 (file:///path/to/project/hello_world)
And then run it:

$ ./target/debug/hello_world
Hello, world!
We can also use cargo run to compile and then run it, all in one step:

$ cargo run
     Fresh hello_world v0.1.0 (file:///path/to/project/hello_world)
   Running `target/hello_world`
Hello, world!
Going Further


/******************************************************************************/
利用 Linux 建構 Video Streaming
/******************************************************************************/
原始資料來源:j2h論壇
Video Streaming 的技術已經出現多年，在 Internet 上的應用也已經相當廣泛，
而利用 Linux 建構 Video Streaming Server 也是相當熱門的話題。
如果您想瞭解什麼是 Video Streaming，
本文對 Video Streaming 的觀念與技術將做了清楚而基本的介紹。
 
Video Streaming 來的正是時候
看到 "Video" Streaming 就知道這個技術與影音有關。Video Streaming 是一種經由網路來撥放影音檔案的技
術，Video "Streaming" 的基本概念為「一邊下載一邊撥放」，我們稱之為「Play as received」。
經由 Internet 如果要收看遠端伺服器的電視檔案，最原始的做為是「下載後再撥放」，也就是經由 FTP 或 
HTTP 將整個檔案下載至本地端後再利用撥放程式來撥放，我們稱之為「Play after download」。
以最常見的例子來講，我們可以經由網路將 MP3 完整下載後再撥放，也就是 Play after download，或者我們
也可以一邊下載 MP3 一邊聽音樂，這種方式則稱為 Play as received。其他的應用範例還很多，例如利用 
RealPlayer「即時觀看影片或是聽音樂」，這種即時撥放的方式即是 Play as received，我們稱這樣的技術為
 Video Streaming Technology。
為什麼說 Video Streaming 的技術來的正是時候呢？舉個最簡單的情況，你可能在下載 MP3 之前想要試聽一
下音樂的內容，而下載音樂片段的方式又顯得不夠友善，這時如果利用 Video Streaming 的技術來讓網友視聽
，不但方便，而且不必浪費時間來下載不喜歡的音樂的。
隨著網路頻寬的改進與 IPv6 的出現，Video Streaming 的應用將越來越廣泛，利用 Video Streaming 來設計
的資訊家電也會越來越多，例如較常被提及的網路電話 (InterPhone)。
除了寬頻網路的普及外，儲存設備的大進步也是加速 Video Streaming 進用普及的最大動力，例如利用 Linux
 設計的 NAS 可以被用來當做大型的影音伺服器或是動態電影資料庫 (DMD)。

VCD & MPEG-1
要提到撥放動態影音的先軀，絕對要先從 VCD 說起，因為這是在電腦出現後，最能深入消費者市場的產品。
想當年，要撥放 VCD 除了要有一台當時算是高擋貨的 1x CD-ROM 外，還要再另外加裝也是高擋貨的 MPEG 卡。
撥放 VCD 其實就是 Video Streaming 的技術，因為 VCD 的資料是一邊讀取一邊撥放，那為什麼要有 
MPEG Card 呢？理所當然的，這是因為MPEG-1 的標準。
MPEG-1 被設計在 1x CD-ROM 上撥放 VCD，而 VCD 上的資料必須經由 MPEG Card 解碼 (decode) 後才能撥放。
但是隨著硬體的進步，現在可以經由軟體來做 MPEG-1 解碼的工作。我們將在後文介紹 MPEG-1 的設計概念。
DVD & MPEG-2
MPEG-2 常被提到則是由於 DVD 的流行。不管是 MPEG-1 或是 MPEG-2，其實是一種編碼的技術，而 DVD-ROM 
則是選擇了 MPEG-2 來當做它的壓縮標準。
而 DVD 之所以無法像 VCD 一樣能被「備份到硬碟」，則是由於其中又加進了三道的保護，第二道保護就是玩
家們耳熟能詳的 CSS。在 Linux 下之所以無法有「合法」的 DVD Player，就是受制於 CSS 的關係。
利用 NAS 來設計 Video Server，要儲存並廣撥 VCD 已經沒有技術上的障礙，但是要儲存並擴撥 DVD，則有法
律上的問題，這點是值得我們深思的一個問題。因為目前 CSS 的技術掌握在日本人手裏，要取得這項技術必須
簽署 NDA，不過 CSS 並非不可破解想必大家都知道，但是就是有版權上的問題。

影像編碼技術介紹
目前學術界已經發展出許多處理影像訊號壓縮及編碼的技術 (codecs)，談到這些技術，應用最廣泛的編碼標準底下四種：
1) H.261
2) H.263
3) JPEG, MJPEG
4) MPEG
底下將分別簡單介紹這四種編碼技術。
H.261 標準
H.261 的影像編碼標準出現在 1990 年的 ITU。一開始的用途主要是支援影像電話 (video phone) 與視訊會議
 (video conferencing)。H.261 的格式有二種，分別有不同的解析度：
1) QCIF：176x144
2) CIF：352x288
H.261 的 fps (frames per second) 可以達到 7.5, 10, 15 與 30 fps。由於 H.261 一開始是架構在 ISDN B 
上面，而 ISDN B 的傳輸速度為 64 Kbps，所以 H.261 也被稱為 Px64 (x = 1 to 30)。
CIF 全名為 (Common Intermediate Format)，主要是為了要支援各種不同解析度的電影而被定義出來，例如 
NTSC, PAL, SECAM 電視系統。而 QCIF 則是 Quarter-CIF 也就是 CIF 解析度的一半。
除此之外，H.261 也可以說是 MPEG-1 標準的前輩。
H.263 標準
H.263 是 H.261 的加強版，誕生於 1994 年 (ITU)。H.263 開始支援 PSTN，不過要特別說明一點，H.263 比
 MPEG-1 還要晚出現，而且 H.263 還是基於 MPEG-1 而發展。
H.263 的標準共支援五種不同的解析度，分別為：
1) Sub-QCIF：128x96
2) QCIF：176x144
3) CIF：352x288
4) 4CIF：704x576
5) 16CIF：1408x1152
傳輸速度為 8 Kbps ~ 1.5 Mbps。除此之外，H.263 也是 MPEG-4 標準的基礎。
JPEG
提到 JPEG 的標準，大家可就不莫生了，由其是在 GIF 發出禁令後，JPEG 更是被廣泛應用。JPEG 的全名大家
一定不莫生，他可是赫赫有名的一群技術團隊的縮寫 - Joint Photographic Experts Group。
JPEG 是 24-bit 的 "true-color" 影像標準，JPEG 的工作是將 RGB 格式的影像轉換成 YCrCB 格式，目的是
為了減少檔案大小，一般約可減少 1/3 ~ 1/2 左右。
不過 MJPEG 才是我們的主角，MJPEG 全名為 "Motion" JPEG，也就是會動的 JPEG 圖檔。許多 Video Streaming 
的場合，像是簡單的視訊會議軟體都會使用 MJPEG 來取代 MPEG，原因無它，因為 MJPEG 格式簡單，但缺點是
不支援聲音。
MPEG-1 標準
MPEG 的標準由 ISO (International Standards Organization) 所制定，全名為 Moving Pictures Experts Group 
(MPEG 為 ISO 工作)，這些團隊制定了包括 MPEG-1、MPEG-2、MPEG-4 等標準。
MPEG-1 的標準比 H.263 早出現，MPEG-1 制定於 1992 年，主要用途為：視訊會議、影像電話、電腦遊戲與
支援第一代的 CD-ROM。MPEG-1 被設計來支援大部份的影像與 CD-ROM 的音效，傳輸速度為 1.5 Mbps (30 fps)。
除此之外，MPEG-1 也支援 playback，例如快轉、倒帶或是跳躍，這也是 MPEG-1 好用的地方。稍後我們會簡單
介紹一下 MPEG-1 的原因，以明白 MPEG-1 如何做到這些功能。
MPEG-2 標準
MPEG-2 的標準出現於 1994 年，MPEG-2 相容於 MPEG-1。MPEG-2 的出現並不是為了要取代 MPEG-1 的舊標準
，而是要加強 MPEG-1 不足的地方。因此 MPEG-2 更能昇任其它工作環境，例如 HDTV、視訊廣播。
同時，MPEG-2 的解析度也支援到 HDTV 1280x720。在音效方面，MPEG-2 也支援到 6 個頻道 (MPEG-1 只支援
 2 個頻道)。MPEG-2 的傳輸速度也提昇至 2Mbps ~ 10 Mbps，因此需要 4x 的 CD-ROM，但也因此 4x CD-ROM
  只能儲存 18 分種的影像，所以我們利用 DVD-ROM 來儲存 MPEG-2 格式的影像，而且 DVD-ROM 也支援 Dolby 音效。
MPEG-4 標準
MPEG-4 的標準在 1993 年被提出，主要的應用用途比較廣，包括：視訊會議、影音郵件、無線裝置等等，支援
的傳輸速度為 8Kbps ~ 35Mbps。
MPEG-4 可以傳送影像的物件，而不是只有影像的 "frame"，例如一連串的動作指令。因此，MPEG-1 與 MPEG-2
 皆是 "frame-based" 的標準，而 MPEG-4 則是 "object-based" 的標準，未來在網路與多媒體的應會也會更普遍。
MPEG-4 目前在 Linux 上已經有 OpenMPEG 的專案計畫，發起本計畫的目地在希望可以在 Linux 上發展完整的
 MPEG-4 支援環境。

Video Streaming 的網路技術
要建置一個完整的 Video Streaming 環境，在整體來看，要準備的硬體包括：伺服器、CCD、影像補捉卡等等
，而在底層的技術面方面，除了前面提到的影像編碼技術外，也要配合通訊協定才能實作出 Video Streaming
 的應用程式。
Video Streaming 的方式
Video 在做 Streaming 時，有三種方式可以應用：broadcasting、unicasting、multicasting。
broadcasting 的方式比較單純，他是在 LAN 上直接將一個個的影像封包丟到網路上 (server 端)，再由 
client 的應用程式自網路上取回封包播放。但網路硬體層上，仍有許多需要考慮的問題，例如在 
Shared Non-Switched Enthernet 上時，就會發生一些小問題。
unicasting 與 multicasting 都是屬於 IP 的傳輸方式。unicasting 採取 1 對 1 的方向傳影像給遠端，稱
為 Video-on-Demand (VoD)，multicasting 則是 1 對多的傳輸方式，稱為 Near-Video-on-Demand (NVoD)。
未來 IPv6 將支援 IP Multicasting，因此 Video Streaming 的應用將更為廣泛。

IPv6
IPv6 全名為 IP version 6，未來將取代目前所使用的 IPv4。IPv6 新增許多對多媒體傳輸的支援，例如 
multicasting、authentication/encryption等。不過目前尚仍未全面升級，所以應用仍受限。
UDP 通訊協定
UDP 全名是 Universal Datagram Protocol，UDP 通訊協定是 Video Streaming 的基石。UDP 與 TCP 不同的
是，UDP 並沒有錯誤檢查，不過這在 Video Streaming 的應用是影嚮不太的。
RTP 通訊協定
RTP 全名為 Real-Time Protocol，RTP 是在 UDP 封包之前多加 10 bytes 的檔頭，裡面記載有時間、序號、
壓縮型態等資訊。RTP 是目前大多數 Video Streaming 軟體所使用的通訊協定。
RTP 可用來針對各種不同的多媒體格式做 Streaming 的工作，因為我們將影像分解成數個 RTP 封包再傳送出
去，因此會遇到許多網路技術常會遇到的問題。例如，因為封包送達的時間不一，造成播放時會畫面不流暢的
現像，因此，在播發時就必須使用一個緩 衝區 (playout buffer) 來暫時存放並處理網路上接受到的封包。
由網路上接收的影像封包因為彼此之間到達的時間間隔不同 (Synchronous Data Packets)，所以必須利用緩衝
區將這些封包做緩衝，讓彼此之間的時間間隔一樣 (Isochronous Data Packets)。
MPEG-1 的原理
MPEG-1 的編碼原理大家都應該要認識一下。MPEG-1 將影像分成一個 Group，即 GOP (Group of Pictures)，
每個 GOP 有一個 Entry Point，稱為 I-frame，每個 I-frame 的大小為 15KB，另外還有 P-frame 與 B-frame。
I-frame 稱為 Independent-frame，為每個 GOP 的起點，緊接著的是二個 B-frame，B-frame 稱為 Bi-directional frame，
每個 B-frame 大小為 3KB，每二個 B-frame 之間再插入一個 P-frame，即 Predictive-frame，每個 B-frame 
的大小為 8KB。
GOP 共有三種不同的 frame，每種 frame 存放的影像與性質皆不同，這在以後我們實做程式時會再做更清楚的
介紹。例如，我們要將影片快轉時，可以忽略掉所有的 B-frame 與 P-frame，只撥放 I-frame，如此一來便可
以節省許多貴寶的網路頻寬與時間，但前提是，I-frame 必須存放主要的影像資料，事實上也是如此。


/******************************************************************************/
非常全的linux面試筆試題及參考答案  ref: http://www.coctec.com/docs/linux/show-post-45721.html
/******************************************************************************/
火星人 @ 2014-03-08 , reply:0 
Tags: linux system 系統
一．填空題：
1. 在Linux系統中,以 文件 方式訪問設備 .
2. Linux內核引導時,從文件 /etc/fstab 中讀取要載入的文件系統.
3. Linux文件系統中每個文件用 i節點 來標識.
4. 全部磁碟塊由四個部分組成,分別為引導塊 、專用塊 、 i節點表塊 和數據存儲塊.
5. 鏈接分為： 硬鏈接 和 符號鏈接 .
6. 超級塊包含了i節點表 和 空閑塊表 等重要的文件系統資訊.
7. 某文件的許可權為：d-rw-_r--_r--,用數值形式表示該許可權,則該八進位數為： 644 ,該文件屬性是 目錄 .
8. 前台起動的進程使用 Ctrl c 終止.
9. 靜態路由設定後,若網路拓撲結構發生變化,需由系統管理員修改路由的設置.
10. 網路管理的重要任務是： 控制 和 監控 .
11. 安裝Linux系統對硬碟分區時,有兩種分區類型： 文件系統分區 和 交換分區 .
13. 編寫的Shell程式運行前賦予該腳本文件 執行 許可權.
14. 系統管理的任務之一是能夠在 分散式 環境中實現對程式和數據的安全保護、備份、恢復和更新.
15. 系統交換分區是作為系統

虛擬存儲器 的一塊區域.
16. 內核分為 進程管理系統 、 記憶體管理系統 、 I/O管理系統 和文件管理系統 等四個子系統.
17. 內核配置是系統管理員在改變系統配置 硬體 時要進行的重要操作.
18. 在安裝Linux系統中,使用netconfig程式對網路進行配置,該安裝程式會一步步提示用戶輸入主機名、域名、域名伺服器、IP地址、 網關地址 和 子網掩碼 等必要資訊.
19. 唯一標識每一個用戶的是用戶 ID 和用戶名.
20 . RIP 協定是最為普遍的一種內部協定,一般稱為動態路由資訊協定.
21. 在Linux系統中所有內容都被表示為文件,組織文件的各種方法稱為 文件系統 .
22. DHCP可以實現動態 IP 地址分配.
23. 系統網路管理員的管理對象是伺服器、 用戶 和伺服器的進程 以及系統的各種資源.
24. 網路管理通常由監測、傳輸和管理三部分組成,其中管理部分是整個網路管理的中心.
25. 當想刪除本系統用不上的 設備驅動程式 時編譯內核,當內核不支援系統上的 設備驅動程式 時,對內核 升級 .
26 Ping命令可以測試網路中本機系統是否能到達 一台遠端主機 ,常常用於測試網路的 連通性 .
27. vi編輯器具有兩種工作模式： 命令模式 和 輸入模式 .
28. 可以用ls –al命令來觀察文件的許可權,每個文件的許可權都用10位表示,並分為四段,其中第一段占 1 位,表示 文件類型 ,第二段佔3位,表示 文件所有者 對該文件的許可權.

29. 進程與程式的區別在於其動態性,動態的產生和終止,從產生到終止進程可以具有的基本狀態為： 運行態 、 就緒態 和 等待態（阻塞態） .
30. DNS實際上是分佈在internet上的主機資訊的資料庫,其作用是實現 IP地址和主機名 之間的轉換.
31. Apache是實現WWW伺服器功能的應用程式,即通常所說的"瀏覽web伺服器",在伺服器端 為用戶提供瀏覽 web服務 的就是apache應用程式.
32. 在Linux系統上做備份可以有兩種類型：系統備份 和 用戶備份 .其中前者是指對 作業系統 的備份,後者是指對 應用程式和用戶文件的備份.
33. CD-ROM標準的文件系統類型是 iso9660 .
34. 當lilo.conf配置完畢後,使之生效,應運行的命令及參數是 lilo .
35. 在使用ls命令時,用八進位形式顯示非列印字元應使用參數 -b .
36. Linux使用支援Windows 9.x/2000長文件名的文件系統的類型是 vfat .
37. 設定限制用戶使用磁碟空間的命令是 quota .
38 在Linux系統中,用來存放系統所需要的配置文件和子目錄的目錄是 /etc .
39. 硬連接只能建立對 文件 鏈接.符號鏈接可以跨不同文件系統創建.
40. 套接字文件的屬性位是 s .
41. 結束後台進程的命令是 kill .
42. 進程的運行有兩種方式,即 獨立運行和使用父進程運行 .
43. Links分為 硬鏈接和符號鏈接 .
44. 在超級用戶下顯示Linux系統中正在運行的全部進程,應使用的命令及參數是 ps -aux .
45. 管道文件的屬性位是 p .
46. 將前一個命令的標準輸出作為後一個命令的標準輸入,稱之為 管道 .
47. 為腳本程式指定執行權的命令及參數是 chmod a x filename .
48. 進行遠端登錄的命令是 telnet .

49. 欲發送10個分組報文測試與主機abc.tuu.edu.cn的連通性,應使用的命令和參數是： ping abc.tuu.edu.cn –c 10 .
50. DNS伺服器的進程命名為named,當其啟動時,自動裝載 /etc目錄下的 named.conf 文件中定義的DNS分區資料庫文件.
51. Apache伺服器進程配置文件是 httpd.conf .52.在 Linux系統中,壓縮文件後生成後綴為.gz文件的命令是 gzip .
53. 在用vi編輯文件時,將文件內容存入test.txt文件中,應在命令模式下鍵入 ：w test.txt .
54 可以在標準輸出上顯示整年日曆的命令及參數是 cal -y .
55. 在shell編程時,使用方括弧表示測試條件的規則是：方括弧兩邊有 空格 .
56. 檢查已安裝的文件系統/dev/had5是否正常,若檢查有錯,則自動修復,其命令及參數是 fsck –a /dev/had5 .
57. 在Windows9.x環境下共享Unix/Linux中的用戶目錄的一個工具是 Samba伺服器 .
58. 系統管理員的職責是進行系統資源管理、系統性能管理、設備管理、安全管理和 系統性能監測 .
59 在Linux系統中,測試DNS伺服器是否能夠正確解析域名的的用戶端命令,使用命令 nslookup .
60. 在Linux系統下,第二個IDE通道的硬碟（從盤）被標識為 hdb .
61. 當系統管理員需升級內核版本和改變系統硬體配置時,應 重新編譯內核 .
62. 如果只是要修改系統的IP地址,應修改 /etc/rc.d/rc.inet1 配置文件.
63. 當LAN內沒有條件建立DNS伺服器,但又想讓區域網內的用戶可以使用電腦名互相訪問時,應配置 /etc/hosts 文件.
64. 在vi編輯環境下,使用 Esc鍵 進行模式轉換.
65. Slackware Linux 9.0通常使用 ext3 文件系統,系統的全部磁碟塊由 四 部分組成.
66. 將/home/stud1/wang目錄做歸檔壓縮,壓縮後生成wang.tar.gz文件,並將此文件保存到/home目錄下,實現此任務的tar命令格式 tar zcvf /home/wang.tar.gz /home/stud1/wang .

67. 管道就是將前一個命令的 標準輸出 作為後一個命令的 標準輸入 .
68. 在使用手工的方法配置網路時,可通過修改 /etc/HOSTNAME 文件來改變主機名,若要配置該電腦的域名解析用戶端,需配置 /etc/resolv.conf 文件.
69. 啟動進程有手動啟動和調度啟動兩種方法,其中調度啟動常用的命令為 at 、 batch 和 crontab .
70. test.bns.com.cn的域名是 bns.com.cn ,如果要配置一域名伺服器,應在 named.conf 文件中定義DNS資料庫的工作目錄.
71. Sendmail郵件系統使用的兩個主要協定是： SMTP 和 POP ,前者用來發送郵件,後者用來接收郵件.
72. DHCP是動態主機配置協定的簡稱,其作用是：為網路中的主機分配IP地址 .
73. 目前代理伺服器使用的軟體包有很多種,教材中使用的是 squid .
74. rm命令可刪除文件或目錄,其主要差別就是是否使用遞歸開關 -r或-R .
75. mv 命令可以移動文件和目錄,還可以為文件和目錄重新命名.
76. 路由選擇協定（RIP）的跳數表示到達目的地之前通過的 網關 數,RIP接受的最長距離是 15跳 .
77. ping命令用於測試網路的連通性,ping命令通過 ICMP 協定（internet控制資訊協定）來實現.
78. nfs 協定用於實現Unix（/linux）主機之間的文件系統共享.
79. 在Linux作業系統中,設備都是通過特殊的 文件 來訪問.
80. shell不僅是 用戶命令的解釋器 ,它同時也是一種功能強大的編程語言. bash是Linux的預設shell.
81. 用 〉;〉; 符號將輸出重定向內容附加在原文的後面.
82. 增加一個用戶的命令是：adduser 或useradd .
83 進行字元串查找,使用grep命令.
84. 使用 * 每次匹配若干個字元.
85. /sbin 目錄用來存放系統管理員使用的管理程式.二．單項選擇題:

1. 下面的網路協定中,面向連接的的協定是： A .
A 傳輸控制協定 B 用戶數據報協定 C 網際協定 D 網際控制報文協定
2. 在/etc/fstab文件中指定的文件系統載入參數中, D 參數一般用於CD-ROM等移動設備.
A defaults B sw C rw和ro D noauto
3. Linux文件許可權一共10位長度,分成四段,第三段表示的內容是 C .
A 文件類型 B 文件所有者的許可權 
C 文件所有者所在組的許可權 D 其他用戶的許可權
4. 終止一個前台進程可能用到的命令和操作 B .
A kill B 〈CTRL〉; C C shut down D halt
5．在使用mkdir命令創建新的目錄時,在其父目錄不存在時先創建父目錄的選項是 D .
A -m B -d C -f D -p
6. 下面關於i節點描述錯誤的是 A .（inode是一種數據結構,vfs中描述文件的相關參數？？）
A i節點和文件是一一對應的
B i節點能描述文件佔用的塊數
C i節點描述了文件大小和指向數據塊的指針
D 通過i節點實現文件的邏輯結構和物理結構的轉換
7. 一個文件名字為rr.Z,可以用來解壓縮的命令是： D .
A tar B gzip C compress D uncompress
8. 具有很多C語言的功能,又稱過濾器的是 C .
A csh
B tcsh
C awk　　（awk詳解）
D sed
9. 一台主機要實現通過區域網與另一個區域網通信,需要做的工作是 C .A 配置域名伺服器
B 定義一條本機指向所在網路的路由
C 定義一條本機指向所在網路網關的路由
D 定義一條本機指向目標網路網關的路由
10. 建立動態路由需要用到的文件有 D .
A /etc/hosts B /etc/HOSTNAME C /etc/resolv.conf D /etc/gateways
11. 區域網的網路地址192.168.1.0/24,區域網路連接其它網路的網關地址是192.168.1.1.主機192.168.1.20訪問172.16.1.0/24網路時,其路由設置正確的是 B .

A route add –net 192.168.1.0 gw 192.168.1.1 netmask 255.255.255.0 metric 1
B route add –net 172.16.1.0 gw 192.168.1.1 netmask 255.255.255.255 metric 1
C route add –net 172.16.1.0 gw 172.16.1.1 netmask 255.255.255.0 metric 1
D route add default 192.168.1.0 netmask 172.168.1.1 metric 1
12. 下列提法中,不屬於ifconfig命令作用範圍的是 D .
A 配置本地迴環地址 B 配置網卡的IP地址
C 激活網路適配器 D 載入網卡到內核中
13. 下列關於鏈接描述,錯誤的是 B .
A 硬鏈接就是讓鏈接文件的i節點號指向被鏈接文件的i節點
B 硬鏈接和符號連接都是產生一個新的i節點
C 鏈接分為硬鏈接和符號鏈接 D 硬連接不能鏈接目錄文件
14. 在區域網路內的某台主機用ping命令測試網路連接時發現網路內部的主機都可以連同,而不能與公網連通,問題可能是 C.
A 主機IP設置有誤
B 沒有設置連接區域網的網關
C 區域網的網關或主機的網關設置有誤
D 區域網DNS伺服器設置有誤
15. 下列文件中,包含了主機名到IP地址的映射關係的文件是： B .
A /etc/HOSTNAME B /etc/hosts C /etc/resolv.conf D /etc/networks
16. 不需要編譯內核的情況是 D .
A 刪除系統不用的設備驅動程式時 B 升級內核時
C 添加新硬體時 D 將網卡激活
17. 在shell中變數的賦值有四種方法,其中,採用name=12的方法稱 A .
A 直接賦值 B使用read命令
C 使用命令行參數 D使用命令的輸出
18. D 命令可以從文本文件的每一行中截取指定內容的數據.
A cp B dd C fmt D cut
19. 下列不是Linux系統進程類型的是 D .
A 交互進程 B 批處理進程 C 守護進程 D 就緒進程（進程狀態）
20．配置Apache 1.3.19伺服器需要修改的配置文件為___A______

A httpd.conf B access.conf C srm.conf D named.conf
21. 內核不包括的子系統是 D .
A 進程管理系統 B 記憶體管理系統 C I/O管理系統 D硬體管理系統
22． 在日常管理中,通常CPU會影響系統性能的情況是： A .
A CPU已滿負荷地運轉 B CPU的運行效率為30%
C CPU的運行效率為50% D CPU的運行效率為80%
23． 若一台電腦的記憶體為128MB,則交換分區的大小通常是 C .
A 64MB B 128MB C 256MB D 512MB
24． 在安裝Linux的過程中的第五步是讓用戶選擇安裝方式,如果用戶希望安裝部分元件（軟體程式）,並在選擇好後讓系統自動安裝,應該選擇的選項是 D .
A full B expert C newbie D menu
25． Linux有三個查看文件的命令,若希望在查看文件內容過程中可以用游標上下移動來查看文件內容,應使用 C 命令.
A cat B more C less D menu
26． 下列資訊是某系統用ps –ef命令列出的正在運行的進程, D 進程是運行Internet超級伺服器,它負責監聽Internet sockets上的連接,並調用合適的伺服器來處理接收的資訊.
A root 1 4.0 0.0 344 204? S 17:09 0:00 init 
B root 2 0.0 0.1 2916 1520? S 17:09 0:00 /sbin/getty 
C root 3 0.0 0.2 1364 632? S 17:09 0:00 /usr/sbin/syslogd 
D root 4 0.0 1344 1204? S 17:09 0:10 /usr/sbin/inetd 
27．在TCP/IP模型中,應用層包含了所有的高層協定,在下列的一些應用協定中, B 是能夠實現本地與遠端主機之間的文件傳輸工作.
A telnet B FTP C SNMP D NFS 
28．當我們與某遠端網路連接不上時,就需要跟蹤路由查看,以便瞭解在網路的什麼位置出現了問題,滿足該目的的命令是 C .
A ping B ifconfig C traceroute D netstat
29．對名為fido的文件用chmod 551 fido 進行了修改,則它的許可權是 D .

A -rwxr-xr-x B -rwxr--r-- C -r--r--r-- D -r-xr-x-x
30． 在i節點表中的磁碟地址表中,若一個文件的長度是從磁碟地址表的第1塊到第11塊,則該文件共佔有 B 塊號.
A 256 B 266 C 11 D 256×10
(??)31． 用ls –al 命令列出下面的文件列表, D 文件是符號連接文件.
A -rw-rw-rw- 2 hel-s users 56 Sep 09 11:05 hello
B -rwxrwxrwx 2 hel-s users 56 Sep 09 11:05 goodbey
C drwxr--r-- 1 hel users 1024 Sep 10 08:10 zhangD lrwxr--r-- 1 hel users 2024 Sep 12 08:12 cheng
32． DNS域名系統主要負責主機名和 A 之間的解析.
A IP地址 B MAC地址 C 網路地址 D 主機別名
33． WWW伺服器是在Internet上使用最為廣泛,它採用的是 B 結構.
A 伺服器/工作站 B B/S C 集中式 D 分散式
34．Linux系統通過 C 命令給其他用戶發消息.
A less B mesg y C write D echo to[ 註：mesg [y|n] 所有使用者 決定是否允許其他人傳訊息到自己的終端機介面 ]


35．NFS是 C 系統.
A 文件 B 磁碟 C 網路文件 D 操作
36． B 命令可以在Linux的安全系統中完成文件向磁帶備份的工作.
A cp B tr C dir D cpio[註：如果用 echo $PATH 或者 echo $LD_LIBRARY_PATH 等類似的命令來顯示路徑資訊的話,我們看到的將會是一大堆用冒號連接在一起的路徑, tr 命令可以把這些冒號轉換為回車,這樣,這些路徑就具有很好的可讀性了：
echo $PATH | tr ":" "\n"]
37．Linux文件系統的文件都按其作用分門別類地放在相關的目錄中,對於外部設備文件,一般應將其放在 C 目錄中.
A /bin B /etc C /dev D /lib 
38．在重新啟動Linux系統的同時把記憶體中的資訊寫入硬碟,應使用 D 命令實現.

A # reboot B # halt C # reboot D # shutdown –r now
39．網路管理具備以下幾大功能：配置管理、 A 、性能管理、安全管理和計費管理等.
A 故障管理 B 日常備份管理 C 升級管理 D 發送郵件
40．關於代理伺服器的論述,正確的是 A .
A 使用internet上已有的公開代理伺服器,只需配置用戶端.
B 代理伺服器只能代理用戶端http的請求.
C 設置好的代理伺服器可以被網路上任何主機使用.
D 使用代理伺服器的用戶端沒有自己的ip地址.
41.關閉linux系統（不重新啟動）可使用命令 B .
A Ctrl Alt Del B halt C shutdown -r now D reboot
42．實現從IP地址到乙太網MAC地址轉換的命令為： C .
A ping B ifconfig C arp D traceroute
43．在vi編輯器中的命令模式下,鍵入 B 可在游標當前所在行下添加一新行.
A 〈a〉; B 〈o〉; C 〈I〉; D A
44．在vi編輯器中的命令模式下,刪除當前游標處的字元使用 A 命令.
A 〈x〉; B 〈d〉;〈w〉; C 〈D〉; D 〈d〉;〈d〉;
45．在vi編輯器中的命令模式下,重複上一次對編輯的文本進行的操作,可使用 C 命令.
A 上箭頭 B 下箭頭 C 〈.〉; D 〈*〉;
46．用命令ls -al顯示出文件ff的描述如下所示,由此可知文件ff的類型為 A .
-rwxr-xr-- 1 root root 599 Cec 10 17:12 ff
A 普通文件 B 硬鏈接 C 目錄 D 符號鏈接
47．刪除文件命令為： D .
A mkdir B rmdir C mv D rm
48．在下列的名稱中,不屬於DNS伺服器類型的是：____C_____
A Primary Master Server B Secondary Master Server
C samba D Cache_only Server
49．網路管理員對WWW伺服器進行訪問、控制存取和運行等控制,這些控制可在 A 文件中體現.
A httpd.conf B lilo.conf C inetd.conf D resolv.conf

50．郵件轉發代理也稱郵件轉發伺服器,它可以使用SMTP協定,也可以使用 C 協定. 
A FTP B TCP C UUCP D POP
51．啟動samba伺服器進程,可以有兩種方式：獨立啟動方式和父進程啟動方式,其中前者是在 C 文件中以獨立進程方式啟動.
A /usr/sbin/smbd B /usr/sbin/nmbd C rc.samba D /etc/inetd.conf
52．DHCP是動態主機配置協定的簡稱,其作用是可以使網路管理員通過一台伺服器來管理一個網路系統,自動地為一個網路中的主機分配___D______地址.
A 網路 B MAC C TCP D IP
53．為了保證在啟動伺服器時自動啟動DHCP進程,應將 A文件中的dhcpd=no改為dhcpd=yes. 
A rc.inet1 B lilo.conf C inetd.conf D httpd.conf[註： 英文原義：RC中文釋義：含有程式（應用程式甚至作業系統）啟動指令的腳本文件註解：這一文件在作業系統啟動時會自動執行,它含有要運行的指令（命令或其它腳本）列表.]
54．對文件進行歸檔的命令為 D .
A dd B cpio C gzip D tar
55．改變文件所有者的命令為 C .
A chmod B touch C chown D cat
56．在給定文件中查找與設定條件相符字元串的命令為： A .
A grep B gzip C find D sort
57．建立一個新文件可以使用的命令為 D .
A chmod B more C cp D touch(指令改變檔案的時間記錄.)
58．在下列命令中,不能顯示文本文件內容的命令是： D . 
A more B less C tail D join
59．在使用匿名登錄ftp時,用戶名為 B .
A users B anonymous C root D guest
60．在實際操作中,想瞭解命令logname 的用法,可以鍵入 D 得到幫助.
A logname --man B logname/？ C help logname D logname --help
61．如果LILO被安裝在MBR,使用 A 命令即可卸載LILO.
A lilo –u B lilo –c C lilo –v D lilo -V

62．當用命令ls –al查看文件和目錄時,欲觀看捲過螢幕的內容,應使用組合鍵 D .
A Shift Home B Ctrl PgUp C Alt PgDn D Shift PgUp
63．mc是UNIX風格作業系統的 C .
A 文件編輯器/程式編譯器 B 配置網路的窗口工具 
C 目錄瀏覽器/文件管理器 D Samba伺服器管理工具
64．i節點是一個 D 長的表,表中包含了文件的相關資訊.A 8位元組 B 16位元組 C 32位元組 D 64位元組
65．文件許可權讀、寫、執行的三種標誌符號依次是 A .
A rwx B xrw C rdx D srw
66．Linux 文件名的長度不得超過 C 個字元.
A 64 B 128 C 256 D 512
67．進程有三種狀態： C .
A 準備態、執行態和退出態 B 精確態、模糊態和隨機態
C 運行態、就緒態和等待態 D 手工態、自動態和自由態
68． 從後台啟動進程,應在命令的結尾加上符號 A .
A & B @ C # D $
69． B 不是郵件系統的組成部分.
A 用戶代理 B 代理伺服器 C 傳輸代理 D 投遞代理
70．在Shell腳本中,用來讀取文件內各個域的內容並將其賦值給Shell變數的命令是 D .
A fold B join C tr D read
71．crontab文件由六個域組成,每個域之間用空格分割,其排列如下： B .
A MIN HOUR DAY MONTH YEAR COMMAND
B MIN HOUR DAY MONTH DAYOFWEEK COMMAND
C COMMAND HOUR DAY MONTH DAYOFWEEK 
D COMMAND YEAR MONTH DAY HOUR MINcrontab命令：實現程式定時運行
72．用ftp進行文件傳輸時,有兩種模式： C .
A Word和binary B .txt和Word Document 
C ASCII和binary D ASCII和Rich Text Format
73．某文件的組外成員的許可權為只讀；所有者有全部許可權；組內的許可權為讀與寫,則該文件的許可權為 D .
A 467 B 674 C 476 D 764
74．在DNS系統測試時,設named進程號是53,命令 D 通知進程重讀配置文件.

A kill –USR2 53 B kill –USR1 53 C kill -INT 63 D kill –HUP 53
75．Apache伺服器默認的接聽連接埠號是 C .
A 1024 B 800 C 80 (http)D 8
76．PHP和MySQL的聯合使用解決了 C .
A 在Proxy上處理資料庫的訪問問題 B 在WWW伺服器上處理駭客的非法訪問問題
C 在WWW伺服器上處理資料庫的訪問問題
D 在Sendmail郵件系統上處理資料庫的訪問問題
77．OpenSSL是一個 A .
A 加密軟體 B 郵件系統 C 資料庫管理系統 D 嵌入式腳本編程語言
78．Samba伺服器的配置文件是 D .
A httpd.conf B inetd.conf C rc.samba D smb.conf
79．關於DNS伺服器,敘述正確的是 D .
A DNS伺服器配置不需要配置用戶端
B 建立某個分區的DNS伺服器時只需要建立一個主DNS伺服器
C 主DNS伺服器需要啟動named進程,而輔DNS伺服器不需要
D DNS伺服器的root.cache文件包含了根名字伺服器的有關資訊
80．退出交互模式的shell,應鍵入 C .
A 〈Esc〉; B ^q C exit D quit
81．將Windows C:盤(hda1)安裝在Linux文件系統的/winsys目錄下,命令是 B .
A root@l04.edu.cn:~#mount dev/had1 /winsys 
B root@l04.edu.cn:~#mount /dev/had1 /winsys
C root@l04.edu.cn:~#mount /dev/had1 winsys
D root@l04.edu.cn:~#mount dev/had1 winsys
82．設超級用戶root當前所在目錄為：/usr/local,鍵入cd命令後,用戶當前所在目錄為 B .
A /home B /root C /home/root D /usr/local
83．字元設備文件類型的標誌是 B .
A p B c C s D l
84．將光碟CD-ROM（hdc）安裝到文件系統的/mnt/cdrom目錄下的命令是 C .

A mount /mnt/cdrom B mount /mnt/cdrom /dev/hdc
C mount /dev/hdc /mnt/cdrom D mount /dev/hdc
85．將光碟/dev/hdc卸載的命令是 C .
A umount /dev/hdc B unmount /dev/hdc
C umount /mnt/cdrom /dev/hdc D unmount /mnt/cdrom /dev/hdc
86．在/home/stud1/wang目錄下有一文件file,使用 D 可實現在後台執行命令,此命令將file文件中的內容輸出到file.copy文件中.
A cat file 〉;file.copy B cat 〉;file.copy C cat file file.copy & D cat file 〉;file.copy &
87．在DNS配置文件中,用於表示某主機別名的是： B .
A NS B CNAME C NAME D CN
88．可以完成主機名與IP地址的正向解析和反向解析任務的命令是： A .
A nslookup B arp C ifconfig D dnslook
89．下列變數名中有效的shell變數名是： C .
A -2-time B _2$3 C trust_no_1 D 2004file
90．qmail是 B .
A 收取郵件的協定 B 郵件伺服器的一種 C 發送郵件的協定 D 郵件隊列
92．已知某用戶stud1,其用戶目錄為/home/stud1.分頁顯示當前目錄下的所有文件的文件或目錄名、用戶組、用戶、文件大小、文件或目錄許可權、文件創建時間等資訊的命令是 D .
A more ls –al B more –al ls C more 〈 ls –al D ls –al | more 
93．關於進程調度命令, B 是不正確的.at--定期執行程式的調度命令
A 當日晚11點執行clear命令,使用at命令：at 23:00 today clearB 每年1月1日早上6點執行date命令,使用at命令：at 6am Jan 1 date
C 每日晚11點執行date命令,crontab文件中應為：0 23 * * * date
D 每小時執行一次clear命令,crontab文件中應為：0 */1 * * * clear
94．系統中有用戶user1和user2,同屬於users組.在user1用戶目錄下有一文件file1,它擁有644的許可權,如果user2用戶想修改user1用戶目錄下的file1文件,應擁有 B 許可權.

A 744 B 664 C 646 D 746
??95．如果想配置一台匿名ftp伺服器,應修改 C 文件.
A /etc/gateway B /etc/ftpservers C /etc/ftpusers D /etc/inetd.conf
96．Samba伺服器的進程由B 兩部分組成 .
A named和sendmail B smbd和nmbd C bootp和dhcpd D httpd和squid
97．要配置NFS伺服器,在伺服器端主要配置 C 文件.
A /etc/rc.d/rc.inet1 B /etc/rc.d/rc.M C /etc/exports D /etc/rc.d/rc.S
98．為保證在啟動伺服器時自動啟動DHCP進程,應對 B 文件進行編輯.
A /etc/rc.d/rc.inet2 B /etc/rc.d/rc.inet1 C /etc/dhcpd.conf D /etc/rc.d/rc.S
99．在配置代理伺服器時,若設置代理伺服器的工作緩存為64MB,配置行應為 D .
A cache 64MB B cache_dir ufs /usr/local/squid/cache 10000 16 256
C cache_ mgr 64MB D cache_ mem 64MB
100．安全管理涉及的問題包括保證網路管理工作可靠進行的安全問題和保護網路用戶及網路管理對像問題. C 屬於安全管理的內容.
A 配置設備的工作參數 B 收集與網路性能有關的數據 
C 控制和維護訪問許可權 D 監測故障
101．以下命令對中,正確的是： B .
A ls和sl B cat和tac C more和erom D exit和tixecat是顯示文件夾的命令,這個大家都知道,tac是cat的倒寫,意思也和它是相反的.cat是從第一行顯示到一行,而tac是從一行顯示到第一行,而rev 則是從一個字元顯示到第一個字元
102． B 命令是在vi編輯器中執行存檔退出.
A :q B ZZ C :q! D :WQ
103．下列關於/etc/fstab文件描述,正確的是 D .
A fstab文件只能描述屬於linux的文件系統 B CD_ROM和軟碟是自動載入的
C fstab文件中描述的文件系統不能被卸載 D 啟動時按fstab文件描述內容載入文件系統
104．通過文件名存取文件時,文件系統內部的操作過程是通過 C .

A 文件在目錄中查找文件數據存取位置.B 文件名直接找到文件的數據,進行存取操作.
C 文件名在目錄中查找對應的I節點,通過I節點存取文件數據.
D 文件名在中查找對應的超級塊,在超級塊查找對應i節點,通過i節點存取文件數據
105．Linux將存儲設備和輸入/輸出設備均看做文件來操作, C 不是以文件的形式出現.
A 目錄 B 軟鏈接 C i節點表 D 網路適配器
106．關於i節點和超級塊,下列論述不正確的是 B .
A i節點是一個長度固定的表 B 超級塊在文件系統的個數是唯一的
C i節點包含了描述一個文件所必需的全部資訊
D 超級塊記錄了i節點表和空閑塊表資訊在磁碟中存放的位置
107． D 設備是字元設備.
A hdc B fd0 C hda1 D tty1(A,B,C為塊設備)
108． B 目錄存放著Linux的源代碼.
A /etc B /usr/src C /usr D /home
109．關於文件系統的安裝和卸載,下面描述正確的是 A .
A 如果光碟未經卸載,光碟機是打不開的 B 安裝文件系統的安裝點只能是/mnt下
C 不管光碟機中是否有光碟,系統都可以安裝CD-ROM設備
D mount /dev/fd0 /floppy 此命令中目錄/floppy是自動生成的
110． B 不是進程和程式的區別.
A 程式是一組有序的靜態指令,進程是一次程式的執行過程
B 程式只能在前台運行,而進程可以在前台或後台運行
C 程式可以長期保存,進程是暫時的
D 程式沒有狀態,而進程是有狀態的
111．文件exer1的訪問許可權為rw-r--r--,現要增加所有用戶的執行許可權和同組用戶的寫許可權,下列命令正確的是 A .
A chmod a x g w exer1 B chmod 765 exer1
C chmod o x exer1 D chmod g w exer1
112．有關歸檔和壓縮命令,下面描述正確的是 C .

A 用uncompress命令解壓縮由compress命令生成的後綴為.zip的壓縮文件
B unzip命令和gzip命令可以解壓縮相同類型的文件
C tar歸檔且壓縮的文件可以由gzip命令解壓縮
D tar命令歸檔後的文件也是一種壓縮文件
113．不是shell具有的功能和特點的是 C .
A 管道 B 輸入輸出重定向 C 執行後台進程 D 處理程式命令
114．下列對shell變數FRUIT操作,正確的是： C .
A 為變數賦值：$FRUIT=apple B 顯示變數的值：fruit=apple
C 顯示變數的值：echo $FRUIT D 判斷變數是否有值：[ -f "$FRUIT" ]
三．簡答題：
1．簡述Linux文件系統通過i節點把文件的邏輯結構和物理結構轉換的工作過程.
參考答案：
Linux通過i節點表將文件的邏輯結構和物理結構進行轉換.
i 節點是一個64位元組長的表,表中包含了文件的相關資訊,其中有文件的大小、文件所有者、文件的存取許可方式以及文件的類型等重要資訊.在i節點表中最重要 的內容是磁碟地址表.在磁碟地址表中有13個塊號,文件將以塊號在磁碟地址表中出現的順序依次讀取相應的塊.Linux文件系統通過把i節點和文件名進行 連接,當需要讀取該文件時,文件系統在當前目錄表中查找該文件名對應的項,由此得到該文件相對應的i節點號,通過該i節點的磁碟地址表把分散存放的文件物 理塊連接成文件的邏輯結構.2．簡述進程的啟動、終止的方式以及如何進行進程的查看.
參考答案：
在Linux中啟動一個進程有手工啟動和調度啟動兩種方式：
（1）手工啟動
用戶在輸入端發出命令,直接啟動一個進程的啟動方式.可以分為：

１前台啟動：直接在SHELL中輸入命令進行啟動.
２後台啟動：啟動一個目前並不緊急的進程,如列印進程.
（2）調度啟動
系統管理員根據系統資源和進程佔用資源的情況,事先進行調度安排,指定任務運行的時間和場合,到時候系統會自動完成該任務.
經常使用的進程調度命令為：at、batch、crontab.
3. 簡述DNS進行域名解析的過程.
參考答案：
,用戶端發出DNS請求翻譯IP地址或主機名.DNS伺服器在收到客戶機的請求後：
（1）檢查DNS伺服器的緩存,若查到請求的地址或名字,即向客戶機發出應答資訊；
（2）若沒有查到,則在資料庫中查找,若查到請求的地址或名字,即向客戶機發出應答資訊；
（3）若沒有查到,則將請求發給根域DNS伺服器,並依序從根域查找頂級域,由頂級查找二級域,二級域查找三級,直至找到要解析的地址或名字,即向客戶機所在網路的DNS伺服器發出應答資訊,DNS伺服器收到應答後現在緩存中存儲,然後,將解析結果發給客戶機.
（4）若沒有找到,則返回錯誤資訊.4．系統管理員的職責包括那些？管理的對象是什麼？
參考答案：
系統管理員的職責是進行系統資源管理、設備管理、系統性能管理、安全管理和系統性能監測.管理的對象是伺服器、用戶、伺服器的進程及系統的各種資源等.
5．簡述安裝Slackware Linux系統的過程.
參考答案： 
（1）對硬碟重新分區. （2）啟動Linux系統（用光碟、軟碟等）.
（3）建立Linux主分區和交換分區.（4）用setup命令安裝Linux系統.
（5）格式化Linux主分區和交換分區（6）安裝Linux軟體包
（7）安裝完畢,建立從硬碟啟動Linux系統的LILO啟動程式,或者製作一張啟動Linux系統的軟碟.重新啟動Linux系統.

6．什麼是靜態路由,其特點是什麼？什麼是動態路由,其特點是什麼？
參考答案：
靜態路由是由系統管理員設計與構建的路由表規定的路由.適用於網關數量有限的場合,且網路拓樸結構不經常變化的網路.其缺點是不能動態地適用網路狀況的變化,當網路狀況變化後由網路管理員修改路由表.
動態路由是由路由選擇協定而動態構建的,路由協定之間通過交換各自所擁有的路由資訊實時更新路由表的內容.動態路由可以自動學習網路的拓樸結構,並更新路由表.其缺點是路由廣播更新資訊將佔據大量的網路帶寬.
87．進程的查看和調度分別使用什麼命令？
參考答案：
進程查看的命令是ps和top.
進程調度的命令有at,crontab,batch,kill.
8．當文件系統受到破壞時,如何檢查和修復系統？
參考答案：
成功修覆文件系統的前提是要有兩個以上的主文件系統,並保證在修復之前卸載將被修復的文件系統.
使用命令fsck對受到破壞的文件系統進行修復.fsck檢查文件系統分為5步,每一步檢查系統不同部分的連接特性並對上一步進行驗證和修改.在執行 fsck命令時,檢查從超級塊開始,然後是分配的磁碟塊、路徑名、目錄的連接性、鏈接數目以及空閑塊鏈表、i-node.
9．解釋i節點在文件系統中的作用.
參考答案：
在linux文件系統中,是以塊為單位存儲資訊的,為了找到某一個文件在存儲空間中存放的位置,用i節點對一個文件進行索引.I節點包含了描述一個文件所的全部資訊.i節點是文件系統管理的一個數據結構.
10．什麼是符號鏈接,什麼是硬鏈接？符號鏈接與硬鏈接的區別是什麼？

參考答案：
鏈接分硬鏈接和符號鏈接.
符號鏈接可以建立對於文件和目錄的鏈接.符號鏈接可以跨文件系統,即可以跨磁碟分區.符號鏈接的文件類型位是l,鏈接文件具有新的i節點.
硬鏈接不可以跨文件系統.它只能建立對文件的鏈接,硬鏈接的文件類型位是－,且硬鏈接文件的i節點同被鏈接文件的i節點相同.
11．在對linux系統分區進行格式化時需要對磁碟簇（或i節點密度）的大小進行選擇,請說明選擇的原則.
參考答案：
磁碟簇（或i節點密度）是文件系統調度文件的基本單元.磁碟簇的大小,直接影響系統調度磁碟空間效率.當磁碟分區較大時,磁碟簇也應選得大些；當分區較小時,磁碟簇應選得小些.通常使用經驗值.
12．簡述網路文件系統NFS,並說明其作用.
參考答案：
網路文件系統是應用層的一種應用服務,它主要應用於Linux和Linux系統、Linux和Unix系統之間的文件或目錄的共享.對於用戶而言可以通過 NFS方便的訪問遠地的文件系統,使之成為本地文件系統的一部分.採用NFS之後省去了登錄的過程,方便了用戶訪問系統資源.13．某/etc /fstab文件中的某行如下：
/dev/had5 /mnt/dosdata msdos defaults,usrquota 1 2
請解釋其含義.
參考答案:
（1）第一列：將被載入的文件系統名；（2）第二列：該文件系統的安裝點；
（3）第三列：文件系統的類型；（4）第四列：設置參數；
（5）第五列：供備份程式確定上次備份距現在的天數；
（6）第六列：在系統引導時檢測文件系統的順序.
14．Apache伺服器的配置文件httpd.conf中有很多內容,請解釋如下配置項：
（1）MaxKeepAliveRequests 200 （2）UserDir public_html

（3）DefaultType text/plain （4）AddLanguare en.en
（5）DocumentRoot"/usr/local/httpd/htdocs"
（6）AddType application/x-httpd-php.php.php.php4
參考答案:
（1）允許每次連接的最大請求數目,此為200；（2）設定用戶放置網頁的目錄；
（3）設置伺服器對於不認識的文件類型的預設格式；
（4）設置可傳送語言的文件給瀏覽器；（5）該目錄為Apache放置網頁的地方；
（6）伺服器選擇使用php4.
15．某Linux主機的/etc/rc.d/rc.inet1文件中有如下語句,請修正錯誤,並解釋其內容.
/etc/rc.d/rc.inet1：
……
ROUTE add –net default gw 192.168.0.101 netmask 255.255.0.0 metric 1
ROUTE add –net 192.168.1.0 gw 192.168.0.250 netmask 255.255.0.0 metric 1
參考答案:
修正錯誤:
（1）ROUTE應改為小寫：route；（2）netmask 255.255.0.0應改為:netmask 255.255.255.0；
（3）預設路由的子網掩碼應改為:netmask 0.0.0.0；
（4）預設路由在設定,否則其後的路由將無效.
解釋內容:
（1）route：建立靜態路由表的命令；（2）add：增加一條新路由；
（3）-net 192.168.1.0：到達一個目標網路的網路地址；
（4）default：建立一條預設路由；（5）gw 192.168.0.101：網關地址；
（6）metric 1：到達目標網路經過的路由器數（跳數）.16．試解釋apache伺服器以下配置的含義： 
（1）port 1080 （2）UserDir userdoc
（3）DocumentRoot "/home/htdocs"
（4）〈Directory /home/htdocs/inside〉;
Options Indexes FollowSymLinks
AllowOverride None
Order deny,allow
deny from all
allow from 192.168.1.5
〈/Directory〉;
（5）Server Type Standlone
參考答案：

Apache伺服器配置行含義如下： 
（1）將apache伺服器的埠號設定為1080；
（2）設定用戶網頁目錄為userdoc；
（3）設定apache伺服器的網頁根目錄:/home/htdocs；
（4）在此apache伺服器上設定一個目錄/home/htdocs/inside,且此目錄只允許IP地址為192.168.1.5的主機訪問；
（5）定義apache伺服器以獨立進程的方式運行.
17．簡述使用ftp進行文件傳輸時的兩種登錄方式？它們的區別是什麼？常用的ftp文件傳輸命令是什麼？ 
參考答案：
（1）ftp有兩種登錄方式：匿名登錄和授權登錄.使用匿名登錄時,用戶名為：anonymous,密碼為：任何合法email地址；使用授權登錄時,用戶名為用戶在遠端系統中的用戶帳號,密碼為用戶在遠端系統中的用戶密碼.
區別：使用匿名登錄只能訪問ftp目錄下的資源,默認配置下只能下載；而授權登錄訪問的許可權大於匿名登錄,且上載、下載均可.
（2）ftp文件傳輸有兩種文件傳輸模式：ASCII模式和binary模式.ASCII模式用來傳輸文本文件,其他文件的傳輸使用binary模式.
（3）常用的ftp文件傳輸命令為：bin、asc、put、get、mput、mget、prompt、bye


/******************************************************************************/
pi@raspberrypi:~/Desktop/SpotifyConnect $ vim spotify-connect-web.sh
/******************************************************************************/
from : http://powerpi.de/spotify-connect-auf-dem-raspberry-pi-2-installieren-dein-smartphone-ist-die-fernbedienung/

pi@raspberrypi:~/Desktop/SpotifyConnect $ vim spotify-connect-web.sh
#!/bin/bash
set -e

DIR=~/spotify-connect-web-chroot

if [ "$1" == "install" ]; then
        mkdir -p $DIR
        cd $DIR
        curl http://spotify-connect-web.s3-website.eu-central-1.amazonaws.com/spotify-connect-web.tar.gz | sudo tar xz
else
        trap "sudo umount $DIR/dev $DIR/proc" EXIT
        sudo mount --bind /dev $DIR/dev
        sudo mount -t proc proc $DIR/proc/
        sudo cp /etc/resolv.conf $DIR/etc/
        sudo chroot $DIR /bin/bash -c "cd /usr/src/app && python main.py $*"
fi



/******************************************************************************/
// Mount Samba from Daiban 
/******************************************************************************/
su (make sure you do this as root)
mkdir /mnt/linky_share
mount -t cifs -o user=luke //192.168.1.104/share /mnt/linky_share
<enter>
it then prompts for your Fileshare password.
voila! now you can treat it as your file system.


/******************************************************************************/

/******************************************************************************/
This document had described the way to inform the wpa_supplicant to do the 
WiFi connection by using the wpa_cli. The wpa_supplicant had supported all 
kinds of security connections and WPS defined in the 802.11 specification. So, 
we suggest use the wpa_supplicant to do the WiFi connection rather than the 
iwconfig wireless tool. 
 
(A) WPA_SUPPLICANT + WPA_CLI User Guide 
 
1.start wpa_supplicant in the background 
wpa_supplicant –Dnl80211 -iwlan0 -c /tmp/net/wpa.conf –B 
or 
wpa_supplicant -Dwext -iwlan0 -c /tmp/net/wpa.conf -B 
 
 
2.Scaning AP and See Results 
wpa_cli -p/var/run/wpa_supplicant scan 
wpa_cli -p/var/run/wpa_supplicant scan_results 
 
3.Connect to AP 
a.OPEN 
wpa_cli -p/var/run/wpa_supplicant remove_network 0 
wpa_cli -p/var/run/wpa_supplicant ap_scan 1 
wpa_cli -p/var/run/wpa_supplicant add_network 
wpa_cli -p/var/run/wpa_supplicant set_network 0 ssid '"dlink"' 
wpa_cli -p/var/run/wpa_supplicant set_network 0 key_mgmt NONE 
wpa_cli -p/var/run/wpa_supplicant select_network 0 
 
b.WEP40 with open system 
wpa_cli -p/var/run/wpa_supplicant remove_network 0 
wpa_cli -p/var/run/wpa_supplicant ap_scan 1 
wpa_cli -p/var/run/wpa_supplicant add_network 
wpa_cli -p/var/run/wpa_supplicant set_network 0 ssid '"dlink"' 
wpa_cli -p/var/run/wpa_supplicant set_network 0 key_mgmt NONE 
wpa_cli -p/var/run/wpa_supplicant set_network 0 wep_key0 1234567890 
wpa_cli -p/var/run/wpa_supplicant set_network 0 wep_tx_keyidx 0 
wpa_cli -p/var/run/wpa_supplicant select_network 0 
 
c.WEP40 with shared key mode 
wpa_cli -p/var/run/wpa_supplicant remove_network 0 
wpa_cli -p/var/run/wpa_supplicant ap_scan 1 
wpa_cli -p/var/run/wpa_supplicant add_network 
wpa_cli -p/var/run/wpa_supplicant set_network 0 ssid '"dlink"' 
wpa_cli -p/var/run/wpa_supplicant set_network 0 key_mgmt NONE 
wpa_cli -p/var/run/wpa_supplicant set_network 0 wep_key0 1234567890 
wpa_cli -p/var/run/wpa_supplicant set_network 0 wep_tx_keyidx 0  
wpa_cli –p/var/run/wpa_supplicant set_network 0 auth_alg SHARED 
wpa_cli -p/var/run/wpa_supplicant select_network 0 
 
d.WEP104 with open system 
wpa_cli -p/var/run/wpa_supplicant remove_network 0 
wpa_cli -p/var/run/wpa_supplicant ap_scan 1 
wpa_cli -p/var/run/wpa_supplicant add_network 
wpa_cli -p/var/run/wpa_supplicant set_network 0 ssid '"dlink"' 
wpa_cli -p/var/run/wpa_supplicant set_network 0 key_mgmt NONE 
wpa_cli -p/var/run/wpa_supplicant set_network 0 wep_key0 
12345678901234567890123456 
wpa_cli -p/var/run/wpa_supplicant set_network 0 wep_tx_keyidx 0 
wpa_cli -p/var/run/wpa_supplicant select_network 0 
 
e.WEP104 with shared key mode 
wpa_cli -p/var/run/wpa_supplicant remove_network 0 
wpa_cli -p/var/run/wpa_supplicant ap_scan 1 
wpa_cli -p/var/run/wpa_supplicant add_network 
wpa_cli -p/var/run/wpa_supplicant set_network 0 ssid '"dlink"' 
wpa_cli -p/var/run/wpa_supplicant set_network 0 key_mgmt NONE 
wpa_cli -p/var/run/wpa_supplicant set_network 0 wep_key0 
12345678901234567890123456 
wpa_cli -p/var/run/wpa_supplicant set_network 0 wep_tx_keyidx 0 
wpa_cli –p/var/run/wpa_supplicant set_network 0 auth_alg SHARED 
wpa_cli -p/var/run/wpa_supplicant select_network 0 
 
#If wep key is ASCII type,use the following cmd: 
#WEP40:    wpa_cli -p/var/run/wpa_supplicant set_network 0 wep_key0 '"12345"' 
#WEP104: wpa_cli -p/var/run/wpa_supplicant set_network 0 wep_key0 
'"1234567890123"' 
 
#WEP key index is X from 0 to 3, change X for other key index and select it. 
#wpa_cli -p/var/run/wpa_supplicant set_network 0 wep_keyX 
12345678901234567890123456 
#wpa_cli -p/var/run/wpa_supplicant set_network 0 wep_tx_keyidx X 
 
 
f.TKIP and AES 
wpa_cli -p/var/run/wpa_supplicant remove_network 0 
wpa_cli -p/var/run/wpa_supplicant ap_scan 1 
wpa_cli -p/var/run/wpa_supplicant add_network 
wpa_cli -p/var/run/wpa_supplicant set_network 0 ssid '"dlink"' 
wpa_cli -p/var/run/wpa_supplicant set_network 0 key_mgmt WPA-PSK 
wpa_cli -p/var/run/wpa_supplicant set_network 0 psk '"12345678"' 
wpa_cli -p/var/run/wpa_supplicant select_network 0  
4.Ad-hoc mode 
a.OPEN 
wpa_cli -p/var/run/wpa_supplicant scan 
wpa_cli -p/var/run/wpa_supplicant scan_results 
wpa_cli -p/var/run/wpa_supplicant remove_network 0 
wpa_cli -p/var/run/wpa_supplicant ap_scan 2 
wpa_cli -p/var/run/wpa_supplicant add_network 
wpa_cli -p/var/run/wpa_supplicant set_network 0 ssid '"Adhoc_test"' 
wpa_cli -p/var/run/wpa_supplicant set_network 0 mode 1 
wpa_cli -p/var/run/wpa_supplicant set_network 0 key_mgmt NONE 
wpa_cli -p/var/run/wpa_supplicant set_network 0 frequency 2412 
wpa_cli -p/var/run/wpa_supplicant select_network 0 
 
#frequency is to set the channel frequency for Ad-hoc master. 
 
b.WEP40 
wpa_cli -p/var/run/wpa_supplicant scan 
wpa_cli -p/var/run/wpa_supplicant scan_results 
wpa_cli -p/var/run/wpa_supplicant remove_network 0 
wpa_cli -p/var/run/wpa_supplicant ap_scan 2 
wpa_cli -p/var/run/wpa_supplicant add_network 
wpa_cli -p/var/run/wpa_supplicant set_network 0 ssid '"Adhoc_test"' 
wpa_cli -p/var/run/wpa_supplicant set_network 0 mode 1 
wpa_cli -p/var/run/wpa_supplicant set_network 0 key_mgmt NONE 
wpa_cli -p/var/run/wpa_supplicant set_network 0 wep_key0 1234567890 
wpa_cli -p/var/run/wpa_supplicant set_network 0 wep_tx_keyidx 0 
wpa_cli -p/var/run/wpa_supplicant set_network 0 frequency 2412 
wpa_cli -p/var/run/wpa_supplicant select_network 0 
 
c.WEP104 
wpa_cli -p/var/run/wpa_supplicant scan 
wpa_cli -p/var/run/wpa_supplicant scan_results 
wpa_cli -p/var/run/wpa_supplicant remove_network 0 
wpa_cli -p/var/run/wpa_supplicant ap_scan 2 
wpa_cli -p/var/run/wpa_supplicant add_network 
wpa_cli -p/var/run/wpa_supplicant set_network 0 ssid '"Adhoc_test"' 
wpa_cli -p/var/run/wpa_supplicant set_network 0 mode 1 
wpa_cli -p/var/run/wpa_supplicant set_network 0 key_mgmt NONE 
wpa_cli -p/var/run/wpa_supplicant set_network 0 wep_key0 
12345678901234567890123456 
wpa_cli -p/var/run/wpa_supplicant set_network 0 wep_tx_keyidx 0 
wpa_cli -p/var/run/wpa_supplicant set_network 0 frequency 2412 
wpa_cli -p/var/run/wpa_supplicant select_network 0 
5.Save the Current Connection AP configuration file 
wpa_cli -p/var/run/wpa_supplicant save_config  
6.WPS Connection 
Push Button: 
wpa_cli -p/var/run/wpa_supplicant remove_network 0 
wpa_cli -p/var/run/wpa_supplicant wps_pbc any 
Pin Code: 
wpa_cli -p/var/run/wpa_supplicant remove_network 0 
wpa_cli -p/var/run/wpa_supplicant wps_pin any 12345670 
or 
wpa_cli -p/var/run/wpa_supplicant remove_network 0 
wpa_cli -p/var/run/wpa_supplicant wps_pin any 
 
7.Get Current Status of wpa_supplicant 
wpa_cli -p/var/run/wpa_supplicant status 
 
 
8.Disable current network connection 
wpa_cli -p/var/run/wpa_supplicant disable_network 0 
(B) WPA_SUPPLICANT + WPA_CLI - Control interface commands 
 
Following commands can be used with wpa_cli 
 
PING 
This command can be used to test whether wpa_supplicant is replying to the control interface commands. 
The expected reply is PONG if the connection is open and wpa_supplicant is processing commands. 
 
STATUS 
Request current status information. The output is a text block with each line in 
variable=value format. For example: 
bssid=02:00:01:02:03:04 
ssid=test network 
pairwise_cipher=CCMP 
group_cipher=CCMP 
key_mgmt=WPA-PSK 
wpa_state=COMPLETED 
 
LIST_NETWORKS 
List configured networks. 
network id / ssid / bssid / flags 
0 example network any [CURRENT] 
(note: fields are separated with tabs) 
 
SCAN 
Request a new BSS scan. 
 
  
SCAN_RESULTS 
Get the latest scan results. 
bssid / frequency / signal level / flags / ssid 
00:09:5b:95:e0:4e 2412 208 [WPA-PSK-CCMP] jkm private 
02:55:24:33:77:a3 2462 187 [WPA-PSK-TKIP] testing 
00:09:5b:95:e0:4f 2412 209 jkm guest 
(note: fields are separated with tabs) 
 
ADD_NETWORK 
Add a new network. This command creates a new network with empty configuration. The new network is 
disabled and once it has been configured it can be enabled with ENABLE_NETWORK command. ADD_- 
NETWORK returns the network id of the new network or FAIL on failure 
 
 
SELECT_NETWORK <network id> 
Select a network (disable others). Network id can be received from the LIST_NETWORKS command 
output. 
 
ENABLE_NETWORK <network id> 
Enable a network. Network id can be received from the LIST_NETWORKS command output.   
 
 
DISABLE_NETWORK <network id> 
Disable a network. Network id can be received from the LIST_NETWORKS command output. Special 
network id all can be used to disable all network. 
. 
REMOVE_NETWORK <network id> 
Remove a network. Network id can be received from the LIST_NETWORKS command output. Special 
network id all can be used to remove all network. 
 
 
SET_NETWORK <network id> <variable> <value> 
Set network variables. Network id can be received from the LIST_NETWORKS command output. 
This command uses the same variables and data formats as the configuration file. 
 
‧ ssid (network name, SSID) 
‧ psk (WPA passphrase or pre-shared key) 
‧ key_mgmt (key management protocol, NONE, WPA-PSK, WPA-EAP) 
‧ proto ( WPA WPA2) 
‧ pairwise ( CCMP TKIP) 
‧ group ( CCMP TKIP WEP40 WEP104) 
‧ wep_key0 ( set wep key for key index 0) 
‧ wep_tx_keyidx ( select wep key index) 
‧ frequency ( Channel frequency in megahertz (MHz) for IBSS ) 
 
GET_NETWORK <network id> <variable> 
Get network variables. Network id can be received from the LIST_NETWORKS command output. 
 
SAVE_CONFIG 
Save the current configuration. 
 
AP_SCAN <ap_scan value> 
Change ap_scan value: 0 = no scanning, 1 = wpa_supplicant requests scans and uses scan results to select 
the AP, 2 = wpa_supplicant does not use scanning and just requests driver to associate and take care of AP 
selection 


/******************************************************************************/
U-boot 啟動內容及基礎指令使用介紹
/******************************************************************************/
U-boot 啟動內容及基礎指令使用介紹
1.1 u-boot 啟動內容解譯
U-Boot 1.1.4 (Sep 23 2008 - 10:58:00) //u-boot 本版資訊及編譯時間
U-Boot code: 30700000 -> 3071B11C BSS: -> 3071F5C4//存放u-boot 資料和程式碼的位址

IRQ Stack: 306daf74
FIQ Stack: 306dbf74 //中斷Stack 位址，u-boot 可不需要使用中斷
RAM Configuration:
Bank #0: 30000000 32 MB //32MB 的SDRAM 位址起始位址為 30000000
Flash: 2 MB //2MB 的Norflash 位址，其實位址為20000000
NAND: 64 MB //64MB 的Nandflash
*** Warning - bad CRC, using default environment //由於是第一次燒寫，flash 中還沒有儲存環境變數，因此使用預設換機變數
In: serial
Out: serial
Err: serial //匯入匯出串列方式
Set the MAC successful! //成功配置網路
Hit any key to stop autoboot: 0 //延時幾秒後自動執行
# //主控台，用戶可匯入指令

1.2 print 指令——檢視u-boot環境變數
由於是第一次燒錄，此時的環境變數為預設值。

1.3 u-boot 環境參數解譯
#print
bootargs= //這個參數將會傳遞給 Linux 作業系統，現在空白，以後詳解
bootcmd=bootm 20000 f0000 //啟動指令，將在啟動延時之後執行位址的指令
bootdelay=5 //啟動延時，建議修改為1
baudrate=115200 //鮑率 115200
ethaddr=00:50:c2:1e:af:fb //網卡的 mac 位址
ipaddr=172.17.22.189 //開發板的 ip 位址
serverip=172.17.22.183 //伺服器(PC 機)的ip 位址
gatewayip=172.17.22.1 //閘道位址(直連可以不填)
netmask=255.255.255.0 //網路遮罩
bootfile="B2-rootfs/usr/B2-zImage.u-boot" //無用，可移除
stdin=serial
stdout=serial
stderr=serial
Environment size: 261/16380 bytes //環境變數容量

1.4 set 指令——設定環境變數
如果一個參數帶有多條指令，
EX:
setenv bootargs mem=224M root=/dev/ram0 rw initrd=0x01000000,32M console=ttyS0,115200n8 lpj=750000;tftpboot 01000000 ramdisk_mvl_u.gz;tftpboot 03000000 uzImage.bin;bootm 03000000
用 print 查看結果。

1.5 save 指令——儲存環境變數
設定完環境變數後需要使用 save 指令來儲存環境變數，這樣開機後就不會環境變數錯誤的查看警告了。

1.6 修改適合 S3C4510 開發板的環境變數
為了方便交流和測試，開發時希望能夠統一 ip 位址，設定如下:
主機:192.168.0.1
開發板:192.168.0.2
虛擬機:192.168.0.3
#save
Saving Environment to Flash...
Un-Protected 1 sectors
Erasing Flash...
done
Erased 1 sectors
Writing to Flash... done
Protected 1 sectors

(兩條指令用"\;"隔開)
set [參數][內容]\;[參數][內容]
--------------------
EX:
#set bootcmd tftp vmlinux.img 30007fc0\; bootm 30007fc0

set [參數] [內容]
--------------------
例如:
#set bootdelay 1
其中 bootargs 和 bootcmd 參數需要額外說明。

(1) bootargs 參數
bootargs 參數是啟動時傳遞給 Linux 作業系統的資訊，其配置敘述為:
set bootargs root=/dev/mtdblock2 console=ttyS0,115200 rootfstype=cramfs mem=32mb
root:/dev/mtdblock2 表示從nand 的第三個割區啟動檔案系統，Linux 啟動後會自動搜索 nand 分割區資訊。
console:表示 Linux 作業系統使用的主控台，我們使用第一個序列埠，因此是ttyS0，後面跟的 115200 表示序列埠使用的鮑率。
rootfstype:表示檔案系統的格式，我們燒錄在 nand 中的檔案系統使用cramfs，所以在這裡要填寫cramfs，否則 linux 會嘗試自動掛載，可能會出錯。
mem:表示 Linux 作業系統的記憶體容量，目前開發板掛載32MB記憶體，因此填32MB。

(2) bootcmd 參數
bootcmd 參數表示開發板開機之後，bootdelay 結束後執行的指令。
上面範例的含義是用 tftp 這條指令，將主機上的vmlinux.img（即Linux 核心）掛載到記憶體的 30007fc0 這個位址，
然後從 30007fc0 啟動核心。(如果將 Linux 核心燒錄到 Nandflash 上，則指令又有不同)

1.7 ping 指令——測試網路指令
功能很簡單，比 pc 上的弱很多，如下：
#ping 192.168.0.1
host 192.168.0.1 is alive



/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/

