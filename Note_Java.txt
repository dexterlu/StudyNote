
/******************************************************************************/

/******************************************************************************/
Android 淺探(一)        from: http://mmdays.com/2008/09/29/android-%E6%B7%BA%E6%8E%A2%E4%B8%80/
/******************************************************************************/
Java
Android 所採用的語言是 Java，先從這開始談起。一般所謂 Java 其實包含三個元素，其一是 Java 這個「電腦語言」，也就是像這樣的東西：

class HelloWorld
{
    public static void main(String [] argv)
    {
        System.out.println("Hello, world!");
    }
}

也就是用人比較容易看懂的語言(也許不那麼容易啦，但至少比一堆 0 跟 1 來得好)來叫電腦做事，比如上個例子是在螢幕上印一行字 Hello, world。
我們還會需要一個「編譯器」，來把這語言從人看得懂的，翻譯成電腦看得懂的。容後再論。
第二個元素是「Java 虛擬機器」(後稱JVM, Java virtual machine)。
電腦的核心 CPU 是有很多不同種類的。一般我們用的是 Intel 的產品，有些是 32 位元、有些是 64 位元。有些人用的可能是 Power，例如部分蘋果電腦的使用者。
還有一些小一點的電腦，可能就是用 ARM 架構。總之，不同的 CPU 使用方法也不同，指令是不能直接互通的。虛擬機器就是設定一些共通的指令，然後針對各種不同的架構
各寫一個程式去配合這套指令。如此一來，我們只需要把程式編譯成「虛擬機器」看得懂的就行了。Java 使用的共通指令就稱做 「Java bytecode」。
其三是 Java runtime library，也就是一個「函式庫」，裡頭存了很多編譯好的現成程式，來讓開發者使用，這樣就可省下很多重覆的工作。比如上頭這例子裡頭的 
System.out.println 就是函式庫提供的。那我們可以想像，如果在程式中我們用了很多某個函式庫裡頭的東西，但是用的人只拿到編譯好的程式，但沒有同樣的函式庫，那這
程式還是不能用。比如說，Windows, Linux提供的基本函式庫就很不一樣，所以做同樣事情的程式，寫法可能完全不同。Java 函式庫裡頭提供的工具，是有標準可循的，所以
以上的程式，不管是要在 Windows 上頭跑，或是 Linux 上頭跑，都是一樣的寫法。
二跟三兩者加起來，合稱 「Java Runtime Environment」, JRE. 它可以讓編譯好的 Java 程式「跨平台」。怎麼說呢？我們用 Java 這個語言寫程式，呼叫 Java 函式庫裡
頭的工具，最後用編譯器編成共通的指令集，交給虛擬機器去執行。如此一來，同樣的程式在各個地方都能跑了。這雖然聽起來很棒，但我們可以想像，由於隔了一層虛擬機
器跟函式庫，一定會比直接下命令來得慢，而且也要有人針對某作業系統跟某 CPU 架構去寫了這套東西，大家才能用。另外一個想法就是，那為何不直接把程式碼公開，讓大
家針對不同的情況去處理，這樣就不需要虛擬機器，速度也一樣快，不就兩全其美了嗎？自由軟體走的就是這樣的路子。
問題是，許多公司不想公佈自己的程式碼，因為必須要靠它賺錢。Java 讓他們可以不公佈程式碼，只發行編譯好的程式，就在各平台上執行。使用者只需要安裝虛擬機器跟函
式庫就行了。我們可以說，Java 是適合商業應用的。這點是很重要的一個特性。

以上的觀念大概瞭解了以後，我們看看 Android 在這部分做了什麼。
一、語言部分
Android 使用的 Java 語言並沒有不同，原本熟悉的工程師仍可以繼續使用。
二、虛擬機器
Android 使用的虛擬機器叫作 Dalvik，原本並不是針對 Java 設計的。它認識的指令集並不是 Java bytecode，而叫 Dalvik executable，簡稱 dex。Android 裡頭提供了一
個工具程式叫 dx，可以把 Java bytecode 再翻譯成 dex，這樣 Dalvik 就知道怎麼執行它了。這虛擬機器為了適合在電話這種比較小型的平台上使用，而做了許多最佳化的
處理，例如減低記憶體的使用，而且可以有效率的同時執行好幾個程式。它仰賴底層的 Linux 作業系統來幫他處理一些事情，意味著目前 Dalvik 是綁在 Linux 上的。
三、函式庫
Android 提供了大部分的標準 Java 函式庫(來自於Apache Harmony)，並把他們轉換成 dex 的格式，如此 Dalvik 才認得。除此之外，還提供了很多獨有的函式，讓使用者可
以直接呼叫來使用電話、GPS等元件，或者是一些視覺的元件來取得跟其他 Android 程式相同的外觀。

Android 虛擬機器與函式庫合稱 Android Runtime。它有幾個特性：
不能直接執行編譯好的 Java 程式。要轉換成 dex 檔案後才能執行。
若此程式使用了 Android 未提供的函式，仍不能執行。
若我們拿到了 Android 應用程式，無法在 Java Runtime 上跑起來。原因為 1. 必須把 dex 轉回 Java bytecode，這難度目前不明。2. 沒有 Android 提供的獨有函式。
仔細思考的話，會發現所謂 Android Runtime 跟 Java Runtime (尤其是 Sun所提供的套件)的不同處很多，只是「剛好」Android 提供了很多 Java 函式庫裡的功能，讓 
Java 工程師可以無痛的轉換罷了。另外就是他仍然保持了對商業應用的親和性，只要發行編譯好的 dex 檔案，而不需公佈程式碼。


/******************************************************************************/
Java關鍵字static、final使用小結
/******************************************************************************/
static
 1. static變數
    按照是否靜態的對類成員變數進行分類可分兩種：一種是被static修飾的變數，叫靜態變數或類變數；另一種是沒有被static修飾的變數，叫實例變數。
    兩者的區別是： 
　  對於靜態變數在記憶體中只有一個拷貝（節省記憶體），JVM只為靜態分配一次記憶體，在加載類的過程中完成靜態變數的記憶體分配，可用類名直接訪問（方便），
    當然也可以通過對像來訪問（但是這是不推薦的）。
    對於實例變數，沒創建一個實例，就會為實例變數分配一次記憶體，實例變數可以在記憶體中有多個拷貝，互不影響（靈活）。
2. static代碼塊
    static代碼塊是類加載時，初始化自動執行的。如果static代碼塊有多個，JVM將按照它們在類中出現的先後順序依次執行它們，每個代碼塊只會被執行一次。
3. static方法
    static方法可以直接通過類名調用，任何的實例也都可以調用，因此static方法中不能用this和super關鍵字，不能直接訪問所屬類的實例變數和實例方法(就是不帶static
    的成員變數和成員成員方法)，只能訪問所屬類的靜態成員變數和成員方法。因為static方法獨立於任何實例，因此static方法必須被實現，而不能是抽像的abstract。
    static方法只能訪問static的變數和方法，因為非static的變數和方法是需要創建一個對像才能訪問的，而static的變數/方法不需要創建任何對象。
********
static的數據或方法，屬於整個類的而不是屬於某個對象的，是不會和類的任何對像實例聯繫到一起。所以子類和父類之間可以存在同名的static方法名，這裡不涉及重載。
所以不能把任何方法體內的變數聲明為static，例如：
fun() {
   static int i=0; //非法。
}
其實理解static是只有一個存儲地方，而使用時直接使用，不需要創建對像，就能明白以上的注意事項。
另外，一般的類是沒有static的，只有內部類可以加上static來表示嵌套類。


final
     在Java中聲明屬性、方法和類時，可使用關鍵字final來修飾。
     final變數即為常量，只能賦值一次；
     final方法不能被子類重寫；
     final類不能被繼承。
1. final變數
    聲明 final 字段有助於優化器作出更好的優化決定，因為如果編譯器知道字段的值不會更改，那麼它能安全地在寄存器中高速緩存該值。final 字段還通過讓編譯器強制
    該字段為只讀來提供額外的安全級別。
    其初始化可以在兩個地方，一是其定義處，也就是說在final變數定義時直接給其賦值，二是在構造函數中。
    這兩個地方只能選其一，要麼在定義時給值，要麼在構造函數中給值，不能同時既在定義時給了值，又在構造函數中給另外的值。
    一旦被初始化便不可改變，這裡不可改變的意思對基本類型來說是其值不可變，而對於對像變數來說其引用不可再變。
    當函數參數為final類型時，你可以讀取使用該參數，但是無法改變該參數的值。
    另外方法中的內部類在用到方法中的參變數時，此參變也必須聲明為final才可使用。
    在java中，普通變數系統是自動初始化的，數值變數自動初始化為0，其餘類型變數自動初始化為空。但是final類型的變數必須顯示初始化，且初始化的方法必須是在申明時或者在構造方法中直接賦值，而不能通過調用函數賦值。
2. final方法
    如果一個類不允許其子類覆蓋某個方法，則可以把這個方法聲明為final方法。
    使用final方法的原因有二：
    第一、把方法鎖定，防止任何繼承類修改它的意義和實現。
    第二、高效。編譯器在遇到調用final方法時候會轉入內嵌inline機制，大大提高執行效率。
    注意，類中所有的private方法都被隱含是final的。由於無法取用private方法，則也無法重載之。
3. final類
    final類不能被繼承，因此final類的成員方法沒有機會被覆蓋，默認都是final的。在設計類時候，如果這個類不需要有子類，類的實現細節不允許改變，並且確信這個類不會載被擴展，那麼就設計為final類。
-----------------
特別要注意一個問題：
    對於被static和final修飾過的實例常量，實例本身不能再改變了，但對於一些容器類型（比如，ArrayList、HashMap）的實例變數，不可以改變容器變數本身，但可以修改容器中存放的對象，這一點在編程中用到很多。
看個例子:
import java.util.ArrayList;

public class TestStaticFinal {
        private static final String strStaticFinalVar = "aaa";
        private static String strStaticVar = null;
        private final String strFinalVar = null;
        private static final int intStaticFinalVar = 0;
        private static final Integer integerStaticFinalVar = new Integer(8);
        private static final ArrayList<String> alStaticFinalVar = new ArrayList<String>();

        private void test() {
                System.out.println("-------------值處理前----------");
                System.out.println("strStaticFinalVar=" + strStaticFinalVar + "");
                System.out.println("strStaticVar=" + strStaticVar + "");
                System.out.println("strFinalVar=" + strFinalVar + "");
                System.out.println("intStaticFinalVar=" + intStaticFinalVar + "");
                System.out.println("integerStaticFinalVar=" + integerStaticFinalVar + "");
                System.out.println("alStaticFinalVar=" + alStaticFinalVar + "");


                //strStaticFinalVar="哈哈哈哈";//錯誤，final表示終態,不可以改變變數本身.
                strStaticVar = "哈哈哈哈";         //正確，static表示類變數,值可以改變.
                //strFinalVar="呵呵呵呵";            //錯誤, final表示終態，在定義的時候就要初值（哪怕給個null），一旦給定後就不可再更改。
                //intStaticFinalVar=2;                 //錯誤, final表示終態，在定義的時候就要初值（哪怕給個null），一旦給定後就不可再更改。
                //integerStaticFinalVar=new Integer(8);                //錯誤, final表示終態，在定義的時候就要初值（哪怕給個null），一旦給定後就不可再更改。
                alStaticFinalVar.add("aaa");     //正確，容器變數本身沒有變化，但存放內容發生了變化。這個規則是非常常用的，有很多用途。
                alStaticFinalVar.add("bbb");     //正確，容器變數本身沒有變化，但存放內容發生了變化。這個規則是非常常用的，有很多用途。

                System.out.println("-------------值處理後----------");
                System.out.println("strStaticFinalVar=" + strStaticFinalVar + "");
                System.out.println("strStaticVar=" + strStaticVar + "");
                System.out.println("strFinalVar=" + strFinalVar + "");
                System.out.println("intStaticFinalVar=" + intStaticFinalVar + "");
                System.out.println("integerStaticFinalVar=" + integerStaticFinalVar + "");
                System.out.println("alStaticFinalVar=" + alStaticFinalVar + "");
        }

        public static void main(String args[]) {
                new TestStaticFinal().test();
        }
}
 
輸出結果
-------------值處理前----------
strStaticFinalVar=aaa
strStaticVar=null
strFinalVar=null
intStaticFinalVar=0
integerStaticFinalVar=8
alStaticFinalVar=[]
-------------值處理後----------
strStaticFinalVar=aaa
strStaticVar=哈哈哈哈
strFinalVar=null
intStaticFinalVar=0
integerStaticFinalVar=8
alStaticFinalVar=[aaa, bbb]

 
/******************************************************************************/
/******************************************************************************/
1. 導論
1.1 為甚麼要有程式碼慣例
對程式設計師來說，程式碼慣例很重要的原因有下列幾點：
  * 一套軟體的生命期 80% 都是花費在維護上。
  * 任何軟體都很難從頭到尾全由原來的作者來維護。
  * 程式碼慣例改善軟體的可讀性，讓工程師可以更快速完整的瞭解新程式碼。
  * 如果你將你的原始碼當作產品，你必須確定它跟你創造的其他產品包裝的
    一樣好，一樣乾淨。
  為了方便工作，每一個寫軟體的人都必須遵循程式碼慣例。每一個人。
1.2 致謝
  這份文件反映出在 Sun MicroSystem, Inc 的 Java Language Specification
  中的 Java 語言程式寫作標準。主要的貢獻者是 Peter King, Patrick Naughton
  , Mike DeMoney, Jonni Kanerva, Kathy Walcath 和 Scott Hommel.
  這份文件是由 Scott Hommel 維護。有建議請寄到 shommel@eng.sun.com

2 檔案名稱
  這一節列出普遍使用的檔案副檔名和名稱。
2.1 副檔名
  Java 軟體使用下列的副檔名：
  檔案型態         |   副檔名
 -----------------------------
  Java 原始碼     |   .java
  Java bytecode  |   .class

2.2 一般檔案名稱
  常用檔案名稱包括：
  檔案名稱        |   使用
  ------------------------------------------------------
  GNUmakefile  |  makefiles 最好的名稱。
               |  我們使用 gnumake 來建立我們的軟體。
  README        |  特定目錄摘要文件的最佳名稱。

3. 檔案組織
  由許多小節組成的檔案應該用 "空白行" 以及 "用來辨認每個小節的選擇性註解"  分隔。
  超過 2000 行的檔案是很累贅的，應該避免。
  Java 程式適當格式的範例請參考 11.1 的 "Java 原始碼檔案範例"。
3.1 Java 原始碼檔案
  每一個 Java 原始碼檔案都包含了一個單一的 public class/interface。
  如果 private classes/interfaces 和 public class 相關，那你應該把
  他們跟 public class 原始碼檔案放在一起。public 應該是這個檔案中的
  第一個 calss/interface。
  Java 原始碼檔案有下列順序：
  * 起始註解(參見 3.1.1 "起始註解")
  * package 和 import 敘述
  * class 和 interface 宣告(參見 3.1.3 "class 和 interface 宣告")
3.1.1 起始註解
  所有的原始碼檔案都應該以 C 語言型態的註解起始，列出類別名稱，版本資訊，日期和版權宣告。
  /*
   * 類別名稱
   * 版本資訊
   * 日期
   * 版權宣告
   */
3.1.2 package 和 import 敘述
  大多數 Java 原始碼檔案的第一行非註解行都是 package 敘述。在這之後跟著 import 敘述。例如：
  package java.awt;
  import java.awt.peer.CanvasPeer;
3.1.3 class 和 interface 宣告
  下列表格描述了一個 class/interface 的宣告部份，以他們應該出現的順序排列。
  參考 11.1 "Java 原始碼檔案範例" 來看包含註解的範例。
  
    |  class/interface
    |  宣告部份                           備註
-----------------------------------------------------------------
  1 |  class/interface 文件         參考 5.2 "文件註解" 來查看
    |  註解 (/**...*/)              這註解中應該有甚麼資訊。
    |
  2 |  class/interface 敘述
    |
  3 |  class/interface 實作註解      這註解應該包含任何不適合做為
    |  (/*...*/)，如果需要的話        class/interface 文件註解的
    |                              class/interface 廣度的資訊。
    |
  4 |  類別 (static) 變數             首先是 public 的類別變數，然後是
    |                              protected，再接著是 package 層級 (
    |                              沒有存取修正子)，最後是 private。
    |
  5 |  實體變數                         首先是 public，然後 protected，然後
    |                              package(沒有存取修正子)，最後是
    |                              private。
    |
  6 |  建構子
    |
  7 |  方法                             方法應該以功能來分群，而不是以視野
    |                              或是存取權限分。例如 private 的
    |                              類別方法可以在兩個 public 實體方
    |                              法中間。目的是為了讓程式碼更容易閱
    |                              讀和瞭解。 

4. 縮排
  應該以四個空白來當一個縮排的單位。縮排的確切構成物( 空白 vs Tab ) 並
  沒有特別指定。Tabs 必須設定成每 8 個空白(不是 4 個)。
4.1 行長度
  避免行長度超過 80 字元，因為很多終端機和工具無法將這個處理的很好。
  注意：用在文件上的範例應該有更短的行長度 -- 通常不會超過 70 個字元。　　　　　

5. 註解
  Java 程式可以有兩種註解：實作註解和文件註解。實作註解是可以在 C++ 中看的到
  ，以 /*...*/ 和 // 分隔的。文件註解(又稱為 "doc 註解")是只有 Java 有，
  而且是用 /**...*/ 分隔的。doc 註解可以被用 javadoc 工具萃取成 HTML 檔案
  。
  實作註解是用來將程式碼註解掉或是說關於特定實作。doc 註解是要描述程式碼的規格
  ，必須以要讓一個手上沒有原始碼的開發者閱讀的實作不相關的觀點來寫。
  註解應該用來給予程式碼概觀，提供閱讀程式碼本身無法獲得的額外資訊。註解
  應該只包含與閱讀和瞭解這程式有關的資訊。例如這一致的套件是如何被建立，或是
  它存在於甚麼目錄都不應該被包含在註解中。
  對不瑣碎和無法觀察到的設計決定的討論是適當的，但是避免在程式碼中出現重
  複的資訊。冗長的註解太容易過期了。通常，避免任何程式碼改進後好像會過期
  的註解。
  注意：註解的頻率有時候反映出貧乏的程式碼品質。當你覺得必須強迫加入註解
  時，請考慮重寫程式碼來讓它更清楚。
  註解不應該被用星號或其他字元畫成的大格子包起來。
  註解不能包含特殊字元，如 form-feed 和 backspace。
5.1 實作註解格式
  程式可以有四種實作註解的型態：區塊，單行，尾隨，行結尾。
5.1.1 區塊註解
  區塊註解用來提供檔案，方法，資料結構和演算法的描述。區塊註解可以用在
  每一個檔案起始處，或是在每個方法前面。它們也可以用在其他的位置，如在
  方法內部。在函式或方法內的區塊註解應該縮排到和他們描述的碼相同的層級。
  區塊註解應該在前面有一行空白行，來將它與程式碼結構分離。
   /*
    * 這是區塊註解。
     */
  區塊註解可以用 /*- 開始，這個在區塊註解起始不能重定格式時，會被當成是
  縮排(1)。例如：
    /*-
    * 這裡是含有我想要 縮排(1) 去忽略的一些非常特別的格式。
    *
    *    一
    *        二
    *            三
    */
  注意：如果你不使用縮排(1)，那你不需要在你的程式碼中使用 /*- 或是做其它
  讓步來讓某些其它人可以在你的程式碼執行縮排(1)。
  參考 5.2 "文件註解"。
5.1.2 單行註解
  簡短的註解可以以縮排到和隨後的碼同樣層級的單行模式出現。如果註解無法寫
  成單行，那他應該遵循區塊註解格式(參見 5.1.1 小節)。單行註解前面應該有
  一空白行。這是 Java 程式碼的單行註解範例：
      if (condition) {
 
          /* 處理這個狀況。 */
          ...
      }
5.1.3 尾隨註解
  非常短的註解可以在他們描述的程式碼同一行出現，但是應該離開足夠的距離
  來讓他們與敘述分隔。如果有超過一個短註解在大區塊程式碼中出現，那他們
  應該被縮排到同一個 tab 設定。
  這裡是一個 Java 程式碼中的尾隨註解範例：
    if (a == 2) {
        return TRUE;               /* 特別狀況  */
    } else {
        return isPrime(a);         /* 只在 a 為奇數時有作用 */
    }
5.1.4 行結尾註解
  這 // 的註解分隔子可以註解一整行或是行的一部分。他不能用在連貫的多行
  文字註解中；但是他可以用在連貫的多行中來註解掉一區塊的程式碼。下列是
  這三種形式的範例：
    if ( foo > 1) {
        // 做出雙空翻。
        ...
    }
    else {
         return false;  // 在這裡解釋為甚麼。
    }
    // if (bar > 1) {
    //
    //      // 做三重空翻。
    //      ...
    //}
    //else{
    //    return false;
    //}
5.2 文件註解
  注意：參考 11.1 "Java 原始碼檔案範例" 來看這邊描述的註解格式範例。
  進一步的細節請看包含 doc 註解標籤(@return, @param, @see) 資訊的
  "How to Write Doc Comments for JavaDoc"：
    http://java.sun.com/products/jdk/javadoc/writingdoccomments.html
  進一步的 doc 註解和 javadoc 細節，請看 javadoc 首頁：
    http://java.sun.com/products/jdk/javadoc/
  doc 註解描述了 Java 類別, 介面, 建構子，方法，和欄位。每一個 doc 註解
  都設定成放在 /**...*/ 分隔子中，每一個類別，介面或是成員都有一個註解。
  這些註解應該就在在宣告的前面出現。
    /**
     * 這個 Example 類別提供了 ...
     */
    public class Exampke { ...
  注意頂層的類別和介面並沒有縮排，而他們的成員有。這類別和介面的 doc 註解
  的第一行(/**)是沒有縮排的；隨後的 doc 註解行都有 1 個縮排的空格 ( 垂直
  對齊星號)。成員 (包括建構子) 的第一個 doc 註解行則有 4 個空白，以及之後的
  有五個空白。
  如果你需要給予不適合出現在文件中的關於類別，介面，變數，或是方法的資訊，
  使用馬上接在宣告之後的區塊註解(見 5.1.1 小節)或是單行註解(見 5.1.2 小節)
  來實作。例如，關於類別實作的細節應該在跟著類別敘述的區塊註解實作中，而不
  是在類別的 doc 註解中。
  doc 註解不應該被放在方法或是建構子的定義區塊中，因為 Java 會將文件註解
  和註解後的第一個宣告關聯起來。

6. 宣告
6.1 每一行的數目
  建議每一行一個宣告，因為他可以支援註解。換句話說，
    int level;  // 縮排層級
    int size;   // 表格大小
  比下列好
    int level, size;
  不要將不同的型態放在同一行，例如：
    int foo,  fooarray[];   //錯誤
  注意：上面的範例在型態和變數名稱之間使用一個空白。另一個可以接受的
  替代方法是用 Tabs，例如：
    int      level;            // 縮排層級
    int      size;             // 表格大小
    Object   currentEntry;     // 目前選擇的表格項目
6.2 初始化
  試著在區域變數宣告的地方初始化它們。唯一不在他們宣告的地方初始化它
  們的理由是初始值要先根據某些計算才能獲得。
6.3 佈置
  只將宣告放在區塊開始的地方。(區塊是被大括號 "{" 和 "}" 圍起來的任何程
  式碼。)不要等到它們第一次被使用時才宣告變數，這可能會困擾不夠小心的程
  式設計師並阻礙程式碼在這個視野中的移植性。
    void myMethod() {
      int int1 = 0;          // 方法區塊的起始位置
 
      if (條件) {
          int int2 = 0;      // "if" 區塊的起始位置
          ...
      }
    }
  這個規則的例外是 for 迴圈的索引值，Java 可以在 for 的敘述中宣告：
    for ( int i = 0; i < maxLoops; i++) { ... }
  避免將宣告藏在高層級的區域宣告。例如，不要在一個內部區塊中宣告同名
  的變數名稱：
    int count;
    ...
    myMethod() {
        if (條件) {
            int count;       // 避免
            ...
        }
        ...
    }
6.4 類別和介面宣告
  當寫 Java 類別和介面程式碼時，應該遵循下列格式規則：
  * 不要在方法名稱和它的引數起始的小括號"("之間使用空白
  * 左大括號 "{" 放在宣告敘述同一行的末端
  * 右大括號 "}" 自己放在一行，縮排到符合他的左括號敘述的位置，
    除了空敘述的 "}" 應該緊接著 "{" 之後出現之外。
  class Sample extends Object {
      int ivar1;
      int ivar2;
 
      Sample(int i, int j) {
          ivar1 = i;
          ivar2 = j;
      }
 
      int emptyMethod() {}
      ...
  }
  * 方法以一行空白行隔開



/******************************************************************************/
int跟Integer的差別??
/******************************************************************************/
int 是所謂的 premitive type, 就是所謂的原紿資料型態
而 Integer 是 Java 的內建類別型態

int a = 5; 
==> int a;
    a =5;
只是說有個變數名稱是 a ,定義為 int 的型態~有給值 5 給到a

Integer a=new Integer(5);
裡面的 Integer 是個類別名稱，而 new Integer(5) 是說建立一個 Integer 類別的實體 a 
而實體內是個 int 型態的值 5~

所以意思就是說，一個是定義變數的原紿資料型態，而另一個是建立了一個 Java 的內建類別的實體。
如果你使用了 Integer 類別的話，（）<=裡面的值就"必需"是要為 int or String 的資料型態。

各有所用                            
int   一般做為數值參數就夠了 
integer   一般做類型轉換的時候用的較多


/******************************************************************************/
int   和   Integer   有什麼區別 
/******************************************************************************/
Java   提供兩種不同的類型：
引用類型和原始類型（或內置類型）。Int是java的原始數據類型，Integer是java為int提供的封裝類。Java為每個原始類型提供了封裝類。 
原始類型        封裝類 
boolean         Boolean
char            Character
byte            Byte
short           Short
int             Integer
long            Long
float           Float
double          Double
引用類型和原始類型的行為完全不同，並且它們具有不同的語義。
引用類型和原始類型具有不同的特徵和用法，它們包括：大小和速度問題，這種類型以哪種類型的數據結構存儲，當引用類型和原始類型用作某個類的實例數據時所指定的缺
省值。對像引用實例變數的缺省值為   null，而原始類型實例變數的缺省值與它們的類型有關。


/******************************************************************************/
JAVA sample code -- 剪刀 石頭 布
/******************************************************************************/
import java.util.Scanner;//載入這個Scanner函式庫
import java.util.Random;//載入這個Random函式庫

public class happy
{
    public static void main(String args[])
    {
        Scanner keyboard = new Scanner(System.in);
        System.out.println("請輸入你的名字");
        String name = keyboard.nextLine();//打入的字串存到name;
        System.out.println("");
        System.out.println(name+",   welcome to the game");
        System.out.println("0 is 剪刀 , 1 is 石頭 , 2 is 布");
        int wager=0,wager1=0;
        System.out.println(" 剛開始 "+name+" 的賭注是 100");
        System.out.println(" 剛開始 computer 的賭注是 100");
        Random random = new Random();//創立一個新的隨機方法叫random
        int n=0,k=0,i=0,b;
        while(i==0)//設立一個迴圈
        {
            while(n<2&&k<2)
            {
                System.out.println("請開始出拳");
                int a = keyboard.nextInt();
                b=random.nextInt(3);
                System.out.println(name+" is "+a);
                System.out.println("computer is "+b);

                if(a==0)//當你出剪刀時,電腦會出拳的情況
                {
                    if(b==0)
                        System.out.println("平手");
                    else if(b==1) {
                        System.out.println("你輸了");
                        k=k+1;
                    }
                    else if(b==2) {
                        System.out.println("你贏了");
                        n=n+1;
                    }
                }
                if(a==1)//當你出石頭,電腦會出拳的情況
                {
                    if(b==0) {
                        System.out.println("你贏了");
                        n=n+1;
                    }
                    else if(b==1)
                        System.out.println("平手");
                    else if(b==2) {
                        System.out.println("你輸了");
                        k=k+1;
                    }
                }
                if(a==2) {//當你出布,電腦出拳的情況
                    if(b==0) {
                       System.out.println("你輸了");
                       k=k+1;
                    }
                    else if(b==1) {
                       System.out.println("你贏了");
                       n=n+1;
                    }
                else if(b==2)
                     System.out.println("平手");
                }
            }
            if(n==2) {//當你每贏兩場就開始計算賭注
                wager=wager+20;
                wager1=wager1-20;
                int newwager,newwager1;
                if(wager==100||wager==-100) {//當兩方其中一方籌碼為0的時候結束遊戲
                    newwager = wager+100;
                    newwager1 = wager1+100;
                    System.out.println("您現在所有的籌碼為"+newwager);
                    System.out.println("電腦現在所有的籌碼為"+newwager1);
                    System.out.println("GAME    OVER");
                    break;
                }
                System.out.println("你目前得到的賭注"+wager);
                System.out.println("電腦目前得到的賭注"+wager1);

                System.out.println("想要繼續嗎,請選擇y/n");
                System.out.println("4代表YES,5代表NO");
                int p = keyboard.nextInt();
                if(p==4) {
                    n=n-2;//當你贏的時候,判斷電腦贏的次數
                    if(k==0)
                        k=k+0;
                    if(k==1)
                        k=k-1;
                }
                else
                    break;//跳出判斷式
            }
            if(k==2) {//當你每輸兩場,開始計算籌碼
                wager=wager-20;
                wager1=wager1+20;
                System.out.println("你目前得到的賭注"+wager);
                System.out.println("電腦目前得到的賭注"+wager1);
                System.out.println("想要繼續嗎,請選擇y/n");
                System.out.println("4代表YES,5代表NO");
                int p = keyboard.nextInt();
                if(p==4) {
                    k=k-2;//當電腦贏的時候,開始計算你贏的次數
                    if(n==0)
                        n=n+0;
                    if(n==1)
                        n=n-1;
                }
                else
                    break;
            }
        }
    }
} 


/******************************************************************************/
把浮點數四捨五入為整數  from: http://programming.im.ncnu.edu.tw/J_index.html
/******************************************************************************/
Java語言規定浮點數轉整數時,小數點部分無條件捨去。如果要達到浮點數四捨五入為整數的效果,可以使用下面的小技巧

public class Example {
    public static void main(String[] argv) {
        double x = 20.6;
        System.out.println(x + " 四捨五入成為 " + (int)(x+0.5));
        System.out.println(x + " 四捨五入成為 " + round(x));
    }
    static int round(double y) {
        return (int)(y + 0.5);
    }
}


/******************************************************************************/
Hex->String與String->Hex程式(完整)      from: http://www.programmer-club.com.tw/ShowSameTitleN/java/9584.html
/******************************************************************************/
這是小妹我最近研究有關Hex轉String與String轉Hex程式

   public String getStringToHex(String strValue) {
     byte byteData[] = null;
     int intHex = 0;
     String strHex = "";
     String strReturn = "";
     try {
       byteData = strValue.getBytes("ISO8859-1");
       for (int intI=0;intI<byteData.length;intI++) {
         intHex = (int)byteData[intI];
         if (intHex<0)
           intHex += 256;
         if (intHex<16)
           strHex += "0" + Integer.toHexString(intHex).toUpperCase();
         else
           strHex += Integer.toHexString(intHex).toUpperCase();
       }
       strReturn = strHex;

     }
     catch (Exception ex) {
       ex.printStackTrace();
     }
     return strReturn;
   }

   public String getHexToString(String strValue) {
     int intCounts = strValue.length() / 2;
     String strReturn = "";
     String strHex = "";
     int intHex = 0;
     byte byteData[] = new byte[intCounts];
     try {
       for (int intI = 0; intI < intCounts; intI++) {
         strHex = strValue.substring(0, 2);
         strValue = strValue.substring(2);
         intHex = Integer.parseInt(strHex, 16);
         if (intHex > 128)
           intHex = intHex - 256;
           byteData[intI] = (byte) intHex;
       }
       strReturn = new String(byteData,"ISO8859-1");
     }
       catch (Exception ex) {
       ex.printStackTrace();
     }
     return strReturn;
   }

/******************************************************************************/
byteArrayToHexString
/******************************************************************************/
public static String byteArrayToHexString(byte[] array) {
                StringBuffer hexString = new StringBuffer();
                for (byte b : array) {
                        int intVal = b & 0xff;
                        if (intVal < 0x10)
                                hexString.append("0");
                        hexString.append(Integer.toHexString(intVal));
                }
                return hexString.toString();
        }


/******************************************************************************/
/******************************************************************************/
public class BitwiseOperators {
 public BitwiseOperators( ) {
  int a = 11; //1 0 1 1
  int b = 12; //1 1 0 0
  
  System.out.println("a & b : "+(a & b));
  System.out.println("a | b : "+(a | b));
  System.out.println("a ^ b : "+(a ^ b));
  System.out.println("~a : "+(~a));
  System.out.println("a << b : "+(a << b));
  System.out.println("a >> b : "+(a >> b));
  System.out.println("a >>> b : "+(a >>> b));
  }

 public static void main(String args[]){
 new BitwiseOperators();
 }
}

Output of the Program: 

C:\nisha>java BitwiseOperators
a & b : 8
a | b : 15
a ^ b : 7
~a : -12
a << b : 45056
a >> b : 0
a >>> b : 0


/******************************************************************************/
[Java]字串String        http://blog.yslifes.com/archives/638
/******************************************************************************/
String是一個比較特別的資料型態，它是一個物件類別（ Object ），基本型態所對應的物件類別，可直接給於相同類型的值，而不需使用new來產生物件，而String資料型態跟基本型態一樣可以直接給於值，不過String沒有相對應的基本型態。
String在使用上十分普遍，大部份的資料型能都可以變成String存放。String本身是字串是使用utf8格式存放的，所以在計算字元時，一個中文字跟一個英文字都是算1，這點是跟其它程式語言不太一樣的。

String的宣告及初始化
" " 雙引號內資料則為String資料型能
        //直接給值
        String a = "123";
        System.out.println("a:"+a);
        //new 一個String物件
        String b = new String("456");
        System.out.println("b:"+b);
        //先宣告再給值
        String c ;
        c = "789";
        System.out.println("c:"+c);
        //先宣告再new一個物件
        String d;
        d = new String("321");
        System.out.println("d:"+d);

字串的連結合併
字串的連結合併是利用 + 來使二個字串變成一個字串
        String z = a + b;//二字串變數相加,連結
        System.out.println("二字串變數相加:"+z);
        String y = "789"+"123";//二字串相加,連結
        System.out.println("二字串相加:"+y);
        String x = 456+"123" ;//數字加字串,連結
        System.out.println("數字加字串:"+x);
        以下為上面二範例的結果
        a:123
        b:456
        c:789
        d:321
        二字串變數相加:123456
        二字串相加:789123
        數字加字串:456123

String.valueOf 基本型態轉換成字串
利用靜態函數String.valueOf(型態)可以把型能轉變成字串
        int num = 123;
        String Snum = String.valueOf(num);
        System.out.println("數字變字串:"+Snum);
        //數字變字串:123
        double numf = 123.1;
        String Snumf = String.valueOf(numf);
        System.out.println("浮點變字串:"+Snumf);
        //浮點變字串:123.1

基本型態物件.parse基本型態  字串轉換成基本型態
利用基本型態物件的函數parse，可以把字轉換成基本型態，如果無法轉換時會有Exception產生
        String Sint = "123";
        int myint = Integer.parseInt(Sint);
        System.out.println("字串轉換成數字:"+myint);
        //字串轉換成數字:123

        String SFloat = "123.1";
        float myfloat= Float.parseFloat(SFloat);
        System.out.println("字串轉換成浮點數:"+myfloat);

        //字串轉換成浮點數:123.1
        String SDouble = "123.2";
        double mydouble= Double.parseDouble(SDouble);
        System.out.println("字串轉換成雙浮點數:"+mydouble);
        //字串轉換成雙浮點數:123.2
        //其它型態以此類推...

IndexOf 查詢字元位存在於字串內位置,以0為起始
IndexOf(字串)，有找到字串時會回傳第一個字元的位置，IndexOf如查詢不到，則會回傳-1
字串內的內容存放可視為一連續空間，而每一個字元均存放在順序的位置上，如下表所示：
        String smart = "Smart";
        int idx = smart.indexOf("m");
        System.out.println("m所在位置:"+idx);
        //m所在位置:1
        idx = smart.indexOf("rt");
        System.out.println("rt所在位置:"+idx);
        //rt所在位置:3
        idx = smart.indexOf("z");
        System.out.println("z所在位置:"+idx);
        //z所在位置:-1
        //中文部份
        String chinese = "中華民國";
        int cidx = chinese.indexOf("民");
        System.out.println("民所在位置:"+cidx);
        //民所在位置:2
        cidx = chinese.indexOf("中華");
        System.out.println("中華所在位置:"+cidx);
        //中華所在位置:0
        cidx = chinese.indexOf("台灣");
        System.out.println("台灣所在位置:"+cidx);
        //台灣所在位置:-1

replaceAll、replaceFirst字串取代
replaceAll (要被取代的字串，要取代的字串)   取代全部找到的」要被取代字串」
replaceFirst (要被取代的字串，要取代的字串)  取代第一個找到的」要被取代字串」
其中replaceAll函數可以使用正規表示式來做整批有規則性的取代
        String replaceString = "blog.yslifes.com,blog.yslifes.com";
        String replaced = replaceString.replaceAll("blog", "www");
        System.out.println("All取代後的字串:"+replaced);
        //All取代後的字串:www.yslifes.com,www.yslifes.com
        replaced = replaceString.replaceFirst("blog", "www");
        System.out.println("First取代後的字串:"+replaced);
        //First取代後的字串:www.yslifes.com,blog.yslifes.com

String.format字串格式化
String.format是一個靜態函數，可以直接使用，將字串依設定的位置或格式回傳出來。
如需顯示三位數的字串數字，前方補零，則可利用以下方法：
        String formatStr = "%03d";
        String formatAns = String.format(formatStr, 12);
        System.out.println("數字補零:"+formatAns);
        //數字補零:012

相關設定方法
CharAt取得指定字元
CharAt(位置)可取出指定位置的字元，中文算法與英文相同
        String charStr = "This is my Web site! blog.yslifes.com";
        char c = charStr.charAt(3);
        System.out.println("英文第4位的字元是:"+c);
        //英文第4位的字元是:s

        charStr = "這是我的網站! blog.yslifes.com";
        c = charStr.charAt(5);
        System.out.println("中文第5位的字元是:"+c);
        //中文第5位的字元是:站

equals 二字串是否相等
equals可以比較二個字串或物件是否相同，以為Object原型就有的方法，字串要全數相同回傳值才會為true
        String aStr = "String A";
        String bStr = "String B";
        boolean Equal = aStr.equals(bStr);
        System.out.println("a與b是否相同:"+Equal);
        //a與b是否相同:false

        String cStr = "String A";
        Equal = aStr.equals(cStr);
        System.out.println("a與c是否相同:"+Equal);
        //a與c是否相同:true

        String dStr = "String A ";
        Equal = aStr.equals(dStr);
        System.out.println("a與d是否相同:"+Equal);
        //a與d是否相同:false

split字串切割
split(指定符號) ，可依指定符號把字串分開成陣列
        String splitStr = "blog,yslifes,com";
        String[] array = splitStr.split(",");
        for(int i = 0 ; i < array.length ; i ++)
            System.out.println("第"+i+"個:"+array[i]);
        /*
        第0個:blog
        第1個:yslifes
        第2個:com
         */

substring取得指定字串範圍
substring(起始值 , 終始值)，可以取出起始位置，到終止位置的字串，其中包含起始值，不包含終始值
        String subStr = "blog.yslifes.com";
        String sub1 = subStr.substring(1, 4);
        System.out.println("第1到4的字串內容為:"+sub1);
        //第1到4的字串內容為:log

trim去空白
trim()可以去除左邊及右邊二則空白，不過在字串間空白並不會處理
        String HasEmptyStr = " ABC";
        System.out.println("1空白去除:"+HasEmptyStr.trim());
        //1空白去除:ABC
 
        HasEmptyStr = "ABC ";
        System.out.println("2空白去除:"+HasEmptyStr.trim());
        //2空白去除:ABC
        HasEmptyStr = " ABC ";
        System.out.println("3空白去除:"+HasEmptyStr.trim());
        //3空白去除:ABC
 
        HasEmptyStr = "ABC DEF";
        System.out.println("4空白去除:"+HasEmptyStr.trim());
        //4空白去除:ABC DEF

字串長度
length()可以取回字串的長度
        String strLength = "長度是多少呢?";
        System.out.println("字串長度:"+strLength.length());
        //字串長度:7


/******************************************************************************/
[JAVA] byte陣列合併
/******************************************************************************/
分享:       
public class ByteUtil {
    /**
    * 系統提供的陣列拷貝方法arraycopy
    * */
    public static byte[] sysCopy(List<byte[]> srcArrays) {
        int len = 0;
        for (byte[] srcArray:srcArrays) {
            len+= srcArray.length;
        }
        byte[] destArray = new byte[len];
        int destLen = 0;
        for (byte[] srcArray:srcArrays) {
            System.arraycopy(srcArray, 0, destArray, destLen, srcArray.length);
            destLen += srcArray.length;
        }
        return destArray;
    }

    /**
    * 借助位元組輸出流ByteArrayOutputStream來實現位元組陣列的合併
    * */
    public static byte[] streamCopy(List<byte[]> srcArrays) {
        byte[] destAray = null;
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        try {
            for (byte[] srcArray:srcArrays) {
                bos.write(srcArray);
            }
            bos.flush();
            destAray = bos.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                bos.close();
            } catch (IOException e) {
            }
        }
        return destAray;
    }

    public static void main(String[] args) {
        List<byte[]> bytes = new ArrayList<byte[]>();
        byte[] byte1 = new byte[3];
        byte1[0] = 1;
        byte1[1] = 2;
        byte1[2] = 3;
        bytes.add(byte1);

        byte[] byte2 = new byte[3];
        byte2[0] = 4;
        byte2[1] = 5;
        byte2[2] = 6;
        bytes.add(byte2);

        byte[] byte3 = new byte[3];
        byte3[0] = 7;
        byte3[1] = 8;
        byte3[2] = 9;
        bytes.add(byte3);

        byte[] newByte = sysCopy(bytes);
        System.out.println("方法一:");
        for (int i = 0; i < newByte.length; i++) {
        System.out.print(newByte[i]+" ");
        }
        System.out.println();
        System.out.println("方法二:");
        newByte = streamCopy(bytes);
        for (int i = 0; i < newByte.length; i++) {
        System.out.print(newByte[i]+" ");
        }
    }
}


/******************************************************************************/
【Android】AsyncTask - Thread 外的另一選擇
/******************************************************************************/
AsyncTask (API level 3，所以幾乎所有目前在市面上流通的 Android 版本皆可使用)
是除 Thread 外的另一種選擇，Android 團隊鼓勵主執行緒(UI thread) 專注於操作 & 畫面的流暢呈現，
其餘工作 (如網路資料傳輸、檔案/磁碟/資料存取) 最好都在背景執行；
Thread 通常要搭配 Handler 使用，而 AsyncTask 用意在簡化背景執行 thread 程式碼的撰寫。

如果您預期要執行的工作能在幾秒內完成，就可以選擇使用 AsyncTask，若執行的時間很長，
Android 則強烈建議採用 Executor, ThreadPoolExecutor and FutureTask。

要使用 AsyncTask，必定要建立一個繼承自 AsyncTask 的子類別，並傳入 3 項資料：
Params -- 要執行 doInBackground() 時傳入的參數，數量可以不止一個
Progress -- doInBackground() 執行過程中回傳給 UI thread 的資料，數量可以不止一個
Rsesult -- 傳回執行結果，
若您沒有參數要傳入，則填入 Void (注意 V 為大寫)。

AsyncTask 的運作有 4 個階段：

onPreExecute -- AsyncTask 執行前的準備工作，例如畫面上顯示進度表，
doInBackground -- 實際要執行的程式碼就是寫在這裡，
onProgressUpdate -- 用來顯示目前的進度，
onPostExecute -- 執行完的結果 - Result 會傳入這裡。
除了 doInBackground，其他 3 個 method 都是在 UI thread 呼叫

官方範例：
private class DownloadFilesTask extends AsyncTask<URL, Integer, Long>
{
    // 對照前面提到的 3 個傳入的參數
    // URL 就是 Params 參數的類別
    // Integer 就是 Progress 參數的類別
    // Long 就是 Result 參數的類別
    protected Long doInBackground(URL... urls)
    {
        int count = urls.length;
        long totalSize = 0;
        for (int i = 0; i < count; i++)
        {
            totalSize += Downloader.downloadFile(urls[i]);
            // 呼叫 publishProgress() 以更新 UI 畫面,
            // 可藉由此方式更新畫面上的進度表
            publishProgress((int) ((i / (float) count) * 100));
            // Escape early if cancel() is called
            if (isCancelled())
                break;
        }
        // 將 totalSize 傳給 onPostExecute()
        return totalSize;
    }
 
    protected void onProgressUpdate(Integer... progress)
    {
        // 這裡接收傳入的 progress 值, 並更新進度表畫面
        // 參數是 Integer 型態的陣列
        // 但是因為在 doInBackground() 只傳一個參數
        // 所以以 progress[0] 取得傳入參數
        setProgressPercent(progress[0]);
    }
 
    protected void onPostExecute(Long result)
    {
        showDialog("Downloaded " + result + " bytes");
    }
}


根據上面的範例，我們要建立一個名為 DownloadFilesTask 的類別，做為下載檔案用，

URL 就是將來會傳入 doInBackground 的變數型態，再看 doInBackground() 這個 method 傳入參數寫法

doInBackgound(URL... urls)

表示傳入的 url 可以不止 1 個。

一旦建立好類別，要執行的方法很簡單：

new DownloadFilesTask().execute(url1, url2, url3);

則 DownloadFilesTask 便會經由 execute() 呼叫 doInBackground()，執行下載 url1, url2, url3 這 3 個檔案，
而 doInBackground() 在處理過程中, 透過呼叫 publishProgress() 來傳送資料給
 onProgressUpdate ()，onProgressUpdate() 更新畫面上的進度表(如果您有在您的 app UI 顯示進度表的話)，
doInBackground() 執行完畢後，會將結果傳給 onPostExecute()。
關於 AsyncTask 的使用，有幾項原則必須遵守：
* AsyncTask 必須在 UI 主執行緒載入. (JELLY_BEAN 版本開始會自動執行此事).
* 必須在 UI 主執行緒建立 AsyncTask.
* 必須在 UI 主執行緒呼叫 AsyncTask.execute().
* 不要自行呼叫 onPreExecute(), onPostExecute(), doInBackground(), onProgressUpdate().
* AsyncTask 只能執行一次.


/******************************************************************************/
Java Reflection 教程(5):Methods 類方法
/******************************************************************************/
通過Class 的getMethods 可以取的類方法的定義
Class aClass = ...//obtain class object
Method[] methods = aClass.getMethods();

如果知道類方法的參數類型，則可以使用getMethod 取的對應的方法定義,如：
Class  aClass = ...//obtain class object
Method method = aClass.getMethod("doSomething", new Class[]{String.class});
上例取的方法名為doSomething 帶一個String為參數的方法定義。如果找不到對應的方法，Java Reflection 拋出NoSuchMethodException 異常。

如果需要方法的方法不帶參數，則使用null 做為getMethod的第二個參數，如下：
Class  aClass = ...//obtain class object
Method method = aClass.getMethod("doSomething", null);

1. 獲取方法的參數和返回值定義
獲取參數定義
Method method = ... // obtain method - see above
Class[] parameterTypes = method.getParameterTypes();

獲取返回值定義
Method method = ... // obtain method - see above
Class returnType = method.getReturnType();

2. 使用Method對像調用該方法
//get method that takes a String as argument
Method method = MyObject.class.getMethod("doSomething", String.class);
Object returnValue = method.invoke(null, "parameter-value1");
method.invoke 的調用個參數為該方法對應的類對像，如果方法為static 類型，則使用null,後面的參數為該方法的參數值。


/******************************************************************************/
Android學習筆記 - 背景執行服務(Service) ref: http://cooking-java.blogspot.tw/2010/04/android-service.html
/******************************************************************************/
1. 大部分使用者在手機上看到的畫面都是前端的程式(Activity)，但是還是要有很多的服務需在背景執行。
如果是要在背景執行的程式，則需要寫成Service並繼承android.app.Service，由於是在背景執行所以是
要寫成Service而不是Activity，因此需在AndroidManifest新增一個Service。以下範例是按下Start Service之後會
在背景每隔一秒Log目前的時間，按下Stop Service後會停止Log的動作。


2. MainActivity.java
01.package org.me.android_service;
02.import android.app.Activity;
03.import android.content.Intent;
04.import android.os.Bundle;
05.import android.view.View;
06.import android.widget.Button;
07. 
08.public class MainActivity extends Activity {
09.    private Button startButton;
10.    private Button stopButton;
11. 
12.    @Override
13.    public void onCreate(Bundle icicle) {
14.        super.onCreate(icicle);
15.        setContentView(R.layout.main);
16.        startButton = (Button) findViewById(R.id.startButton);
17.        stopButton = (Button) findViewById(R.id.stopButton);
18.        startButton.setOnClickListener(startClickListener);
19.        stopButton.setOnClickListener(stopClickListener);
20.    }
21. 
22.    private Button.OnClickListener startClickListener = new Button.OnClickListener() {
23.        public void onClick(View arg0) {
24.            //啟動服務
25.            Intent intent = new Intent(MainActivity.this, NickyService.class);
26.            startService(intent);
27.        }
28.    };
29. 
30.    private Button.OnClickListener stopClickListener = new Button.OnClickListener() {
31.        public void onClick(View arg0) {
32.            //停止服務
33.            Intent intent = new Intent(MainActivity.this, NickyService.class);
34.            stopService(intent);
35.        }
36.    };
37.}


3. NickyService.java
01.package org.me.android_service;
02.import android.app.Service;
03.import android.content.Intent;
04.import android.os.Handler;
05.import android.os.IBinder;
06.import android.util.Log;
07.import java.util.Date;
08. 
09.//繼承android.app.Service
10.public class NickyService extends Service {
11.    private Handler handler = new Handler();
12. 
13.    @Override
14.    public IBinder onBind(Intent intent) {
15.        return null;
16.    }
17. 
18.    @Override
19.    public void onStart(Intent intent, int startId) {
20.        handler.postDelayed(showTime, 1000);
21.        super.onStart(intent, startId);
22.    }
23. 
24.    @Override
25.    public void onDestroy() {
26.        handler.removeCallbacks(showTime);
27.        super.onDestroy();
28.    }
29.     
30.    private Runnable showTime = new Runnable() {
31.        public void run() {
32.            //log目前時間
33.            Log.i("time:", new Date().toString());
34.            handler.postDelayed(this, 1000);
35.        }
36.    };
37.}


4. main.xml(Layout)
01.<?xml version="1.0" encoding="utf-8"?>
02.<AbsoluteLayout
03.android:id="@+id/widget0"
04.android:layout_width="fill_parent"
05.android:layout_height="fill_parent"
06.xmlns:android="http://schemas.android.com/apk/res/android"
07.>
08.<Button
09.android:id="@+id/startButton"
10.android:layout_width="wrap_content"
11.android:layout_height="wrap_content"
12.android:text="Start Service"
13.android:layout_x="40px"
14.android:layout_y="67px"
15.>
16.</Button>
17.<Button
18.android:id="@+id/stopButton"
19.android:layout_width="wrap_content"
20.android:layout_height="wrap_content"
21.android:text="Stop Service"
22.android:layout_x="140px"
23.android:layout_y="67px"
24.>
25.</Button>
26.</AbsoluteLayout>


5. AndroidManifest.xml
01.<?xml version="1.0" encoding="UTF-8"?>
02.<manifest xmlns:android="http://schemas.android.com/apk/res/android"
03.     package="org.me.android_spinner">
04.    <application>
05.         <activity android:name=".MainActivity" android:label="MainActivity">
06.            <intent-filter>
07.                <action android:name="android.intent.action.MAIN"/>
08.                <category android:name="android.intent.category.LAUNCHER"/>
09.            </intent-filter>
10.        </activity>
11.        <service android:name=".NickyService"/>
12.    </application>
13.</manifest>


/******************************************************************************/
Java Socket 介紹
/******************************************************************************/
Socket簡介
在TCP/IP 底層的運作必須處理封包、標頭、格式、交握等的細節，而實作 "sockets" 的 Java Socket 類別幫你把這些事處理好。
簡單來說，Socket 是連到另一台機器作溝通的一個端點。使用 Socket 你可以專注在資料流的傳輸，其它底層的細節都不用管。

Socket 類別重要的建構式與方法介紹
建構式
Socket() : 產生一個未連線的 Socket，不會阻斷往下執行，之後請呼叫 connect 方法進行連線。
Socket(address, port) : 產生一個連線的 Socket，會阻斷往下執行，直到產生連線或是連線失敗而拋出Exception。
Socket(host, port, stream) : stream 參數填入 false，可以產生一個 datagram socket，意味著 Socket 將以 UDP 的方式傳輸資料。不過這方式已經被 Deprecated，請用 DatagramSocket 取代。
方法
connect(endpoint)       當尚未進行連線時呼叫。
getOutputStream()       回傳 OutputStream 物件，使用者透過此物件輸出資料。不過一但此物件被關閉，或是 Socket 被關閉，此物件就不再被使用了，也不能重新呼叫 getOutputStream() 來重新取得 OutputStream 物件。另外，關閉 OutputStream 物件也會關閉 Socket。
getInputStream()        回傳 InputStream 物件，使用者透過此物件讀入資料。不過一但此物件被關閉，或是 Socket 被關閉，此物件就不再被使用了，也不能重新呼叫 getInputStream() 來重新取得 getInputStream物件。另外，關閉 InputStream 物件也會關閉 Socket。
close() 關閉 Socket，輸出入流也會被關閉，若是輸出入流正在傳資料，將會拋出去 SocketException。

Socket 連線到 Server 的簡單範例
主要流程
1. 建立包裹物件 Client
2. Client 以指定的 IP 與 Port 建立 Socket。
3. 若是 Socket 建立了，代表連線成功。
4. Client 以一個新的執行緒去不斷傾聽 Server 送來的資料，資料由 Socket 取得的 InputStream 傳入
5. 使用者可於控制台輸入文字資料，Client 會透過由 Socket 取得的 OutputStream 送出資料
6. 若是使用者送出訊息，Server 會回傳相同的訊息。
7. 可輸入 "Exit" 結束程式。

package test.net.client;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.net.InetAddress;
import java.net.Socket;
import java.util.Timer;

/**
 * 此 Client 需要對方的 IP 與 Port，才能連線。連線後可以透過控制台輸入文字，傳輸到Server。<br />
 * Server 收到資料後會立即回傳 Echo，而且也會定時傳"Test"文字下來，給Client確認是否連線還在。<br />
 * 
 * 此類別主要方法 {@link test.net.client.Client#start() start()}、
 * {@link test.net.client.Client#close() close()}、
 * {@link test.net.client.Client#sendMessageToServer(String)
 * sendMessageToClient(String)}。
 * 
 * @author vincent
 * 
 */
public class Client {
 private String ip;
 private int port;
 private Socket clientSocket;
 private BufferedReader clientReader;
 private PrintStream clientWriter;
 private Timer timer = new Timer(false);
 private boolean isDead = true;

 public Client(String ip, int port) {
  this.ip = ip;
  this.port = port;
 }

 /**
  * 開始進行連線
  * 
  * @throws IOException
  */
 public void start() throws IOException {
  InetAddress address = InetAddress.getByName(ip);
  System.out.printf("開始連到Server [%s:%d]...\n", ip, port);

  // 此方法會阻擋往下執行，直到連線成功
  clientSocket = new Socket(address, port);

  System.out.printf("連線到Server [%s:%d] 成功!\n", ip, port);
  isDead = false;

  // 取出輸出入流
  clientReader = new BufferedReader(new InputStreamReader(
    clientSocket.getInputStream(), "UTF-8"));
  clientWriter = new PrintStream(clientSocket.getOutputStream(), false,
    "UTF-8");

  // 傾聽所有從 Server 送來的資料
  listenMsg();
 }

 /**
  * 以一個新的執行緒去不斷傾聽 Server 送來的資料。<br />
  * 注意，當 Server 關閉時，使用 {@link InputStream} 會拋出 {@link SocketException}。<br />
  * 之後 Client 會關閉 {@link Socket Socket}
  * 
  */
 private void listenMsg() {
  Thread t = new Thread(new Runnable() {

   @Override
   public void run() {
    String str = null;
    while (isAlive() && !isDead) {
     try {
      str = getServerMessage();
     } catch (IOException e) {
      e.printStackTrace(System.err);
      close();
     }
     if (str != null) {
      str = "Server Message: " + str;
      System.out.println(str);
     }
    }
   }
  });
  t.setDaemon(false);
  t.start();
 }

 /**
  * 
  * @return 回傳一行文字，不包含"\n"。若是null代表沒資料了。
  * @throws IOException
  */
 private String getServerMessage() throws IOException {
  return clientReader.readLine();
 }

 public void sendMessageToServer(String message) {
  clientWriter.println(message);
  clientWriter.flush();
 }

 public boolean isAlive() {
  return clientSocket.isConnected() && !clientSocket.isClosed();
 }

 public void close() {
  System.out.println("close.");
  isDead = true;
  timer.cancel();
  try {
   clientSocket.close();
  } catch (IOException e) {
   e.printStackTrace(System.err);
  }
 }

 public static void main(String[] args) {
  Client client = new Client("localhost", 12345);
  try {
   client.start();
   System.out.println("請輸入訊息並按 Enter，若要離開請打\"Exit\"");
   BufferedReader reader = new BufferedReader(new InputStreamReader(
     System.in, "UTF-8"));

   client.sendMessageToServer("我進來了!");

   String msg = null;
   while (null != (msg = reader.readLine())) {
    if (msg.equalsIgnoreCase("Exit")) {
     client.close();
     break;
    }
    String str = msg;
    System.out.println("我輸入: " + str);
    client.sendMessageToServer(str);
   }
  } catch (IOException e) {
   e.printStackTrace(System.err);
  }

 }

}

Java 串流利用
從 Socket 取來的 InputStream 與 OutputStream 是原始的 byte 串流，以我接數種資料源的經驗。
其實很多人還是選擇用 byte 串流來傳，使用者來依文件來拆解這些 byte 資料，所以在選擇包裝 Stream，頂多就是加
BufferedInputStream 跟 BufferedOutputStream ，讓使用者可以一次讀較多的資料。
以下再介紹一些常用的輸出入包裹器: 
類型            Java Class              說明
緩衝類型        BufferedInputStream     顧名思義，會將資料暫存住，讓你不用一個 byte 一個 byte 讀。
                BufferedOutputStream
                BufferedReader
                BufferedWriter
物件類型        ObjectInputStream       將資料以物件的方式傳遞，每次接到都是一個物件，不過在Socket傳輸鮮少這麼做，因為這樣就不能跨平台，只能在使用 Java 的 Client 與 Server 上用。
                ObjectOutputStream
文字類型        InputStreamReader       把 byte 串流改成文字串流，一次將讀出一個文字，這個在純粹以文字形式做溝通的連線常用。
                InputStreamWriter

附上簡單的 ServerSocket 程式碼供測試
Server.java
package test.net.server;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 用來建立 ServerSocket，並傾聽Socket的呼叫且建立連線。<br />
 * 連線對象可以很多個，連進來的 Socket 會一直存活，並且將他們傳進來的訊息傳回去。<br />
 * 
 * 
 * @author vincent
 * 
 */
public class Server {

 private int serverPort;
 private ServerSocket serverSocket;
 private Queue<Client> clients = new LinkedList<Client>();
 private boolean isDead = true;
 private SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss");
 private ExecutorService service = Executors.newFixedThreadPool(20);
 private long clientIds = 0;

 public Server(int serverPort) {
  this.serverPort = serverPort;
 }

 /**
  * 開始建立 ServerSocket 並 傾聽新的Socket連線。
  * 
  * @throws IOException
  */
 public void start() throws IOException {
  System.out.printf("開始建立 ServerSocket 於  port - %d ...\n", serverPort);
  serverSocket = new ServerSocket(serverPort);
  isDead = false;
  System.out.printf("ServerSocket 已經建立!\n");

  // acceptForClients
  service.submit(new Runnable() {

   @Override
   public void run() {
    acceptForClients();
   }
  });

  // handleClients
  service.submit(new Runnable() {

   @Override
   public void run() {
    handleEcho();
   }
  });

  // checkClientAlive
  service.submit(new Runnable() {

   @Override
   public void run() {
    checkClientAlive();
   }
  });
 }

 public boolean isDead() {
  return isDead;
 }

 /**
  * 不斷地加入 Client 到 Queue
  * 
  * @throws IOException
  */
 private void acceptForClients() {
  while (!isDead) {
   Socket clientSocket = null;
   Client client = null;
   try {
    clientSocket = serverSocket.accept();
    client = new Client(++clientIds, clientSocket);

   } catch (IOException e) {
    e.printStackTrace(System.err);
   }

   if (null == clientSocket) {
    continue;
   }
   synchronized (clients) {
    clients.add(client);
   }
   System.out.printf("位於 %s的用戶進來了!\n", client.getName());
  }

 }

 /**
  * 
  * 讀取Socket的訊息，若有則回傳。
  */
 private void handleEcho() {
  while (!isDead) {
   try {
    Thread.sleep(100);
   } catch (InterruptedException e) {
    e.printStackTrace(System.err);
   }

   synchronized (clients) {
    if (clients.isEmpty()) {
     continue;
    }
    Iterator<Client> it = clients.iterator();
    Client client = null;
    for (; it.hasNext();) {
     client = it.next();
     doEcho(client);
    }
   }

  }

 }

 /**
  * 檢查Socket是否還活著。
  */
 private void checkClientAlive() {
  while (!isDead) {
   try {
    Thread.sleep(2000);
   } catch (InterruptedException e) {
    e.printStackTrace(System.err);
   }
   synchronized (clients) {
    if (clients.isEmpty()) {
     continue;
    }
    Iterator<Client> it = clients.iterator();
    Client client = null;
    for (; it.hasNext();) {
     client = it.next();
     client.sendMessageToClient("test");
     boolean isAlive = client.isAlive();
     System.out.printf("位於 %s 的 Client 是否活著: %b\n",
       client.getName(), isAlive);
     if (!isAlive) {
      it.remove();
      System.out.printf("位於 %s 的Client已經被移除!\n",
        client.getName());
     }

    }
   }

  }
 }

 /**
  * 將Client傳來的訊息送回去
  * 
  * @param client
  */
 private void doEcho(final Client client) {
  service.submit(new Runnable() {

   @Override
   public void run() {
    try {
     String message = null;
     while (client.isAlive()
       && (null != (message = client.getClientMessage()))) {
      System.out.printf("收到訊息來自 %s，內容: %s\n",
        client.getName(), message);
      String sendMsg = String.format("我於 %s 時收到了!，內容: %s",
        sdf.format(new Date()), message);
      client.sendMessageToClient(sendMsg);
     }
    } catch (SocketException e) {
     e.printStackTrace(System.err);
     client.close();
    } catch (IOException e) {
     client.close();
     e.printStackTrace(System.err);
    }
   }
  });

 }

 public void closeConnection() {
  try {
   isDead = true;
   service.shutdown();
   serverSocket.close();
  } catch (IOException e) {
   e.printStackTrace(System.err);
  }
 }

 /**
  * @param args
  */
 public static void main(String[] args) {
  final Server server = new Server(12345);
  try {
   server.start();
  } catch (IOException e) {
   e.printStackTrace();
   server.closeConnection();
  }

 }
}

Client.java
package test.net.server;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.net.Socket;

public class Client {
 private BufferedReader clientReader;
 private PrintStream clientWriter;
 private String hostName;
 private Socket clientSocket;
 private long clientId;

 public Client(long clientId, Socket clientSocket) throws IOException {
  this.clientId = clientId;
  this.clientSocket = clientSocket;

  clientReader = new BufferedReader(new InputStreamReader(
    clientSocket.getInputStream(), "UTF-8"));
  clientWriter = new PrintStream(clientSocket.getOutputStream(), false,
    "UTF-8");

  hostName = clientSocket.getInetAddress().getHostName();
 }

 /**
  * 
  * @return 回傳一行文字，不包含"\n"。若是null代表沒資料了。
  * @throws IOException
  */
 public String getClientMessage() throws IOException {
  return clientReader.readLine();
 }

 public void sendMessageToClient(String message) {
  clientWriter.println(message);
  clientWriter.flush();
 }

 public String getHostName() {
  return hostName;
 }

 public String getName() {
  return getHostName() + " - " + clientId;
 }

 /**
  * 當對方(Client)呼叫 close 方法後，這裡的 isClosed 還是 false。<br />
  * 反而對方(Client)強制讓程式關閉，使這裡發生Exception，這裡才得知對方關閉。<br />
  * 而且發現就算對方呼叫了 close 方法，繼續傳字串到 Client 也不會出 Exception。
  * 
  * @return
  */
 public boolean isAlive() {
  return clientSocket.isConnected() && !clientSocket.isClosed();
 }

 public void close() {
  try {
   clientSocket.close();
  } catch (IOException e) {
   e.printStackTrace();
  }
 }
}


/******************************************************************************/
// Install Java JDK in LINUX 
/******************************************************************************/
from : https://www3.ntu.edu.sg/home/ehchua/programming/howto/Ubuntu_HowTo.html#jdk

How to Install JDK 8 on Ubuntu
There are several JDK implementations available for Linux, such as Oracle JDK, OpenJDK, Sun JDK, IBM JDK and GNU Java Compiler. We shall choose the Oracle JDK 8. Ubuntu chooses OpenJDK as its default JDK, which is not 100% compatible with Oracle JDK.
Step 0: Check if JDK has already been Installed
Open a Terminal and issue this command:
$ javac -version
If a JDK version number (e.g., "javac 1.x.x_xx") appears, JDK has already been installed. You can skip the installation and goto step 2.
To remove OpenJDK, issue command:
$ sudo apt-get purge openjdk-\*
Step 1: Download and Install JDK
Goto JDK (Java SE) download site @ http://www.oracle.com/technetwork/java/javase/downloads/index.html. Select "Java SE 8u{xx}" ⇒ JDK ⇒ Download ⇒ "Accept License Agreement" ⇒ Select Linux x86 (for 32-bit system) or Linux x64 (for 64-bit system) "tar.gz" package, e.g., "jdk-8u{xx}-linux-i586.tar.gz". (To check your OS version, goto "Settings" ⇒ "Details"; or issue command "file /sbin/init".) The tarball will be stored in folder "~/Downloads", by default.
We shall install JDK under "/usr/local/java" (or Ubuntu's default JDK directory /usr/lib/jvm). First, create a directory "java" under "/usr/local". Open a Terminal and issue these commands:
$ cd /usr/local
$ sudo mkdir java
Extract the downloaded package (Check your downloaded filename!)
$ cd /usr/local/java
$ sudo tar xzvf ~/Downloads/jdk-8u{xx}-linux-x64.tar.gz
       // x: extract, z: for unzipping gz, v: verbose, f: filename
JDK shall be extracted in a folder "/usr/local/java/jdk1.8.0_{xx}", where {xx} is the upgrade number.
Inform the Ubuntu to use this JDK/JRE:
// Setup the location of java, javac and javaws
$ sudo update-alternatives --install "/usr/bin/java" "java" "/usr/local/java/jdk1.8.0_{xx}/jre/bin/java" 1
      // --install symlink name path priority
$ sudo update-alternatives --install "/usr/bin/javac" "javac" "/usr/local/java/jdk1.8.0_{xx}/bin/javac" 1
$ sudo update-alternatives --install "/usr/bin/javaws" "javaws" "/usr/local/java/jdk1.8.0_{xx}/jre/bin/javaws" 1
 
// Use this Oracle JDK/JRE as the default
$ sudo update-alternatives --set java /usr/local/java/jdk1.8.0_{xx}/jre/bin/java
      // --set name path
$ sudo update-alternatives --set javac /usr/local/java/jdk1.8.0_{xx}/bin/javac
$ sudo update-alternatives --set javaws /usr/local/java/jdk1.8.0_{xx}/jre/bin/javaws
The above steps set up symlinks java, javac, javaws at /usr/bin (which is in the PATH), that link to /etc/alternatives and then to JDK bin directory.
The "alternatives" system aims to resolve the situation where several programs fulfilling the same function (e.g., different version of JDKs). It sets up symlinks thru /etc/alternatives to refer to the actual programs to be used.
$ cd /usr/bin
$ ls -ld java*
lrwxrwxrwx 1 root root 22 Mar 31 20:41 java -> /etc/alternatives/java
lrwxrwxrwx 1 root root 23 Mar 31 20:42 javac -> /etc/alternatives/javac
lrwxrwxrwx 1 root root 24 Mar 31 20:42 javaws -> /etc/alternatives/javaws
 
$ cd /etc/alternatives
$ ls -ld java*
lrwxrwxrwx 1 root root 40 Aug 29 18:18 java -> /usr/local/java/jdk1.8.0_20/jre/bin/java
lrwxrwxrwx 1 root root 37 Aug 29 18:18 javac -> /usr/local/java/jdk1.8.0_20/bin/javac
lrwxrwxrwx 1 root root 42 Aug 29 18:19 javaws -> /usr/local/java/jdk1.8.0_20/jre/bin/javaws
To verify the JDK installation, issue these commands:
// Show the Java Compiler (javac) version
$ javac -version
javac 1.8.0_20
 
// Show the Java Runtime (java) version
$ java -version
java version "1.8.0_20"
Java(TM) SE Runtime Environment (build 1.8.0_20-b26)
Java HotSpot(TM) 64-Bit Server VM (build 25.20-b23, mixed mode)
 
// Show the location of javac and java
$ which javac
/usr/bin/javac
$ which java
/usr/bin/java
To use Java under Firefox, you need to enable the so-called "Java Plugin for web browser".
$ cd /usr/lib/mozilla/plugins
// if this directory does not exist, create it
$ sudo mkdir -p /usr/lib/mozilla/plugins
Then, create a symbolic link to your Mozilla plugins folder, (check your JDK folder)
$ cd /usr/lib/mozilla/plugins
$ sudo ln -s /usr/local/java/jdk1.8.0_{xx}/jre/lib/amd64/libnpjp2.so
To verify the installation, restart your Firefox and issue URL "about:plugins".Check for Java plugins with the correct version.
Starting from JDK 1.8u??, to run unsigned applets, you need to set security level to "high" add the sites to the "Exception List" (under the Java Control Panel ⇒ Security). To start the Java Control Panel:
$ cd /usr/local/java/jdk1.8.0_{xx}/jre/bin
$ ./ControlPanel      // OR ./jcontrol
You need to restart Firefox after modifying the Exception List.
[Don't Do this step - taken care by "alternative" in Step 3. Keep here to show you how to set PATH.] Add JDK's binary directory ("bin") to the "PATH" by editing "/etc/profile":
$ cd /etc
$ gksudo gedit profile   // OR "sudo nano profile" to use the console-based nano editor
Add these lines at the end of the file "/etc/profile", replace "{xx}" with the actual number:
export JAVA_HOME=/usr/local/java/jdk1.8.0_{xx}
export PATH=$JAVA_HOME/bin:$PATH
Rerun the configuration file by:
$ source /etc/profile
 
// Check the new settings for JAVA_HOME and PATH
$ echo $JAVA_HOME
/usr/local/java/jdk1.8.0_{xx}
 
$ echo $PATH
.....:/usr/local/java/jdk1.8.0_{xx}/bin
Step 2: Compile and Run a Hello-world Java Program
Open "Folder" and create a new directory called "myProject" under your home directory to keep all your works.
Open "Text Editor" (gedit). Enter the following source code and save as "Hello.java" under the "~/myProject" directory created earlier.
public class Hello {   // To save as "Hello.java" under "~/myProject"
   public static void main(String[] args) {
      System.out.println("Hello, world from Ubuntu!");
   }
}
To compile the Hello-world Java program, launch a Terminal and issue these commands:
// Change directory to where the source code resides
$ cd ~/myProject
 
// List the contents of current directory. Check for "Hello.java"
$ ls
...... Hello.java ....
 
// Compile "Hello.java" into "Hello.class"
$ javac Hello.java
 
// Check for "Hello.class"
$ ls
...... Hello.class ....
Run the Hello-world Java program:
// Run "Hello.class"
$ java Hello
Hello, world from Ubuntu!


/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/


