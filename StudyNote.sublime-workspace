{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"BT_Process_D",
				"BT_Process_Disconnect"
			],
			[
				"bG",
				"bGEN_VolOut"
			],
			[
				"Thre",
				"Threshold"
			],
			[
				"BT_TWE",
				"BT_TWS_AutoConnect]=40"
			],
			[
				"TW",
				"TWS_Pairing"
			],
			[
				"BT",
				"BTState"
			],
			[
				"HE",
				"Hex_to_Ascii"
			],
			[
				"BT_Process_A",
				"BT_Process_AskParty"
			],
			[
				"C",
				"Connected"
			],
			[
				"delay",
				"Delay_ms"
			],
			[
				"NTP",
				"NTP8230_SoundON"
			],
			[
				"Devi",
				"DeviceOn"
			],
			[
				"TWS",
				"TWS_Connected"
			],
			[
				"sec",
				"secKeyCount"
			],
			[
				"Device",
				"DeviceOff"
			],
			[
				"fL",
				"fLED_1"
			],
			[
				"PWM",
				"PWMD2"
			],
			[
				"Is",
				"IsFirstOpen"
			],
			[
				"Hold",
				"HOLD_KEY"
			],
			[
				"Fir",
				"FirstKey"
			],
			[
				"HOLD",
				"HOLD_KEY"
			],
			[
				"NTP8230",
				"NTP8230_Mute"
			],
			[
				"0x1A",
				"0x1A"
			],
			[
				"map",
				"map_value"
			],
			[
				"Add",
				"Address"
			],
			[
				"up",
				"up"
			],
			[
				"Trig",
				"TriggerTime"
			],
			[
				"Panel",
				"PanelKey"
			],
			[
				"Ke",
				"Key"
			],
			[
				"TRA",
				"TRANS_KEY_REPEAT"
			],
			[
				"TR",
				"TRANS_KEY_REPEAT"
			],
			[
				"Tri",
				"TriggerFlag"
			],
			[
				"D",
				"DelayTimes"
			],
			[
				"Del",
				"Delay"
			],
			[
				"FIR",
				"FIRST_KEY"
			],
			[
				"K",
				"KeyFlag"
			],
			[
				"BT_T",
				"BT_TWSAudioRoutingAsk"
			],
			[
				"M",
				"M"
			],
			[
				"UI",
				"UI_TimeOutEvent"
			],
			[
				"De",
				"Delay_10ms(20"
			],
			[
				"P",
				"Pairing"
			],
			[
				"TWS_",
				"TWS_Pairing"
			],
			[
				"Dela",
				"Delay_10ms(10"
			],
			[
				"CS",
				"CS48L1x"
			],
			[
				"BM",
				"BM5481_Sub"
			],
			[
				"CS48",
				"CS48L1x_Init(1"
			],
			[
				"0x04",
				"0x04"
			],
			[
				"DSP",
				"DSP_UNMUTE"
			],
			[
				"BT_Pr",
				"BT_Process_ExitTWS"
			],
			[
				"BY",
				"BYTE"
			],
			[
				"BT_P",
				"BT_Process_Pause"
			],
			[
				"BT_Process_a",
				"BT_Process_AutoConnect"
			],
			[
				"bf",
				"bFuncMode"
			],
			[
				"BT_Process",
				"BT_Process_VolUpdate"
			],
			[
				"aux",
				"AUX_MODE"
			],
			[
				"TW_",
				"TW_Connected"
			],
			[
				"Uar",
				"UART_TransmitByte('C"
			],
			[
				"URAR",
				"UART_Printf(\"PAIRING"
			],
			[
				"uar",
				"UART_TransmitByte"
			],
			[
				"Rda",
				"Rdata1"
			],
			[
				"R",
				"Rdata1"
			],
			[
				"Low",
				"LowBATTcnt"
			],
			[
				"KEY_P",
				"KEY_PAIRING_KEY"
			],
			[
				"HOL",
				"HOLD_TRIGER"
			],
			[
				"bKe",
				"bKeyFlag"
			],
			[
				"BT_Process_",
				"BT_Process_VolUp"
			],
			[
				"BTs",
				"BTState"
			],
			[
				"pa",
				"pairing"
			],
			[
				"PL",
				"PlugDetectcnt"
			],
			[
				"Tra",
				"transmit"
			],
			[
				"UART",
				"UART_Printf"
			],
			[
				"STANDBY",
				"STANDBY_MODE"
			],
			[
				"Timeou",
				"TimeOutRutineBuf"
			],
			[
				"AUX",
				"AUX_MODE"
			],
			[
				"SYS_",
				"SYS_BT_MODE"
			],
			[
				"bfun",
				"bFuncMode"
			],
			[
				"ST",
				"STANDBY_MODE"
			],
			[
				"BT_De",
				"BT_DeviceOn]=40"
			],
			[
				"rU",
				"TimeOutRutineBuf"
			],
			[
				"AMP",
				"AMP_SPEAKERON"
			],
			[
				"de",
				"define"
			],
			[
				"TEST",
				"TEST"
			],
			[
				"RETURN",
				"return"
			],
			[
				"BYTE",
				"BYTE0\tBYTE0"
			],
			[
				"AS_VOL_M",
				"AS_VOL_MIN"
			],
			[
				"Am",
				"AMP_RESET"
			],
			[
				"BT_",
				"BT_RST=LO"
			],
			[
				"P_",
				"P_EN2"
			],
			[
				"timeout",
				"TimeOutRutineBuf"
			],
			[
				"ke",
				"keyword"
			],
			[
				"name",
				"name\tname:"
			],
			[
				"matc",
				"match\tmatch:"
			],
			[
				"ru",
				"TimeOutRutineBuf"
			],
			[
				"void",
				"void0"
			],
			[
				"By",
				"BYTE1\tBYTE"
			],
			[
				"Sub",
				"Sublime"
			],
			[
				"Co",
				"Connected"
			],
			[
				"BTS",
				"BTState"
			],
			[
				"BT_pr",
				"BT_Process_TWSMaster"
			],
			[
				"mul",
				"MultiCount"
			],
			[
				"fK",
				"fKEY_2"
			],
			[
				"HO",
				"HOLD_KEY"
			],
			[
				"s",
				"start"
			],
			[
				"pep",
				"popen\tfunction"
			],
			[
				"g",
				"GetFileName"
			],
			[
				"stK",
				"stKP_KeyInfoKeep"
			],
			[
				"EE",
				"EEPROM_Page_Read"
			],
			[
				"ADC",
				"ADC_PlugDetect"
			],
			[
				"A",
				"AUX_MODE"
			]
		]
	},
	"buffers":
	[
		{
			"file": "Note_Linux.txt",
			"settings":
			{
				"buffer_size": 588622,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"contents": "\n/***************************************************************************/\n// linux shell 腳本入門\n/***************************************************************************/\n1. Linux 腳本編寫基礎\n1.1 語法基本介紹\n1.1.1 開頭\n程式必須以下面的行開始（必須方在文件的第一行）： \n#!/bin/sh \n符號#!用來告訴系統它後面的參數是用來執行該文件的程式。在這個例子中我們使用/bin/sh來執行程式。\n當編輯好腳本時，如果要執行該腳本，還必須使其可執行。要使腳本可執行：\n編譯 chmod +x filename 這樣才能用./filename 來運行\n1.1.2 註釋 \n在進行shell編程時，以#開頭的句子表示註釋，直到這一行的結束。我們真誠地建議您在程式中使用註釋。\n如果您使用了註釋，那麼即使相當長的時間內沒有使用該腳本，您也能在很短的時間內明白該腳本的作用及工作原理。\n1.1.3 變數 \n在其他編程語言中您必須使用變數。在shell編程中，所有的變數都由字串組成，並且您不需要對變數進行聲明。\n要賦值給一個變數，您可以這樣寫： \n#!/bin/sh \n#對變數賦值： \na=\"hello world\" \n# 現在列印變數a的內容： \necho \"A is:\" \necho $a \n有時候變數名很容易與其他文字混淆，比如： \nnum=2 \necho \"this is the $numnd\" \n這並不會列印出\"this is the 2nd\"，而僅僅列印\"this is the \"，因為shell會去搜索變數numnd的值，但是這個變數時沒有值的。\n可以使用花括號來告訴shell我們要列印的是num變數： \nnum=2 \necho \"this is the ${num}nd\" \n這將列印： this is the 2nd\n1.1.4 環境變數\n由export關鍵字處理過的變數叫做環境變數。我們不對環境變數進行討論，因為通常情況下僅僅在登錄腳本中使用環境變數。\n1.1.5 Shell命令和流程序控制制\n在shell腳本中可以使用三類命令： \n1)Unix 命令: \n  雖然在shell腳本中可以使用任意的unix命令，但是還是由一些相對更常用的命令。這些命令通常是用來進行文件和文字操作的。\n  常用命令語法及功能\n  echo \"some text\": 將文字內容列印在螢幕上\n  ls: 文件列表\n  wc –l filewc -w filewc -c file: 計算文件行數計算文件中的單詞數計算文件中的字元數\n  cp sourcefile destfile: 文件拷貝\n  mv oldname newname : 重命名文件或移動文件\n  rm file: 刪除文件\n  grep 'pattern' file: 在文件內搜索字串比如：grep 'searchstring' file.txt\n  cut -b colnum file: 指定欲顯示的文件內容範圍，並將它們輸出到標準輸出設備\n          比如：輸出每行第5個到第9個字元cut -b5-9 file.txt千萬不要和cat命令混淆，這是兩個完全不同的命令\n  cat file.txt: 輸出文件內容到標準輸出設備（螢幕）上\n  file somefile: 得到文件類型\n  read var: 提示用戶輸入，並將輸入賦值給變數\n  sort file.txt: 對file.txt文件中的行進行排序\n  uniq: 刪除文本文件中出現的行列比如： sort file.txt | uniq\n  expr: 進行數學運算Example: add 2 and 3expr 2 \"+\" 3\n  find: 搜索文件比如：根據文件名搜索find . -name filename -print\n  tee: 將數據輸出到標準輸出設備(螢幕) 和文件比如：somecommand | tee outfile\n  basename file: 返回不包含路徑的文件名比如： basename /bin/tux將返回 tux\n  dirname file: 返回文件所在路徑比如：dirname /bin/tux將返回 /bin\n  head file: 列印文本文件開頭幾行\n  tail file : 列印文本文件末尾幾行\n  sed: Sed是一個基本的查找替換程式。可以從標準輸入（比如命令管道）讀入文本，並將結果輸出到標準輸出（螢幕）。\n  該命令採用正則表達式（見參考）進行搜索。不要和shell中的萬用字元相混淆。\n  比如：將linuxfocus 替換為 LinuxFocus ：cat text.file | sed 's/linuxfocus/LinuxFocus/' > newtext.file\n  awk: awk 用來從文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。\n  cat file.txt | awk -F, '{print $1 \",\" $3 }'這裡我們使用，作為字段分割符，同時列印第一個和第三個字段。\n  如果該文件內容如下： Adam Bor, 34, IndiaKerry Miller, 22, USA\n  命令輸出結果為：Adam Bor, IndiaKerry Miller, USA\n2) 概念: 管道, 重定向和 backtick 這些不是系統命令，但是他們真的很重要。\n  管道 (|) 將一個命令的輸出作為另外一個命令的輸入。\n  grep \"hello\" file.txt | wc -l\n  在file.txt中搜索包含有」hello」的行並計算其行數。在這裡grep命令的輸出作為wc命令的輸入。當然您可以使用多個命令。\n  重定向：將命令的結果輸出到文件，而不是標準輸出（螢幕）。\n  > 寫入文件並覆蓋舊文件\n  >> 加到文件的尾部，保留舊文件內容。\n  反短斜線\n  使用反短斜線可以將一個命令的輸出作為另外一個命令的一個命令行參數。\n  命令：\n  find . -mtime -1 -type f -print\n  用來查找過去24小時（-mtime –2則表示過去48小時）內修改過的文件。如果您想將所有查找到的文件打一個包，則可以使用以下腳本：\n  #!/bin/sh\n  # The ticks are backticks (`) not normal quotes ('):\n  tar -zcvf lastmod.tar.gz `find . -mtime -1 -type f -print`\n3) 流程序控制制 \n  1.if\n  \"if\" 表達式 如果條件為真則執行then後面的部分：\n  if ....; then\n  ....\n  elif ....; then\n  ....\n  else\n  ....\n  fi\n  大多數情況下，可以使用測試命令來對條件進行測試。比如可以比較字串、判斷文件是否存在及是否可讀等等…\n  通常用\" [ ] \"來表示條件測試。注意這裡的空格很重要。要確保方括號的空格。\n  [ -f \"somefile\" ] ：判斷是否是一個文件\n  [ -x \"/bin/ls\" ] ：判斷/bin/ls是否存在並有可執行權限\n  [ -n \"$var\" ] ：判斷$var變數是否有值\n  [ \"$a\" = \"$b\" ] ：判斷$a和$b是否相等\n  執行man test可以查看所有測試表達式可以比較和判斷的類型。\n  直接執行以下腳本：\n  #!/bin/sh\n  if [ \"$SHELL\" = \"/bin/bash\" ]; then\n  echo \"your login shell is the bash (bourne again shell)\"\n  else\n  echo \"your login shell is not bash but $SHELL\"\n  fi\n  變數$SHELL包含了登錄shell的名稱，我們和/bin/bash進行了比較。\n  快捷操作符\n  熟悉C語言的朋友可能會很喜歡下面的表達式：\n  [ -f \"/etc/shadow\" ] && echo \"This computer uses shadow passwors\"\n  這裡 && 就是一個快捷操作符，如果左邊的表達式為真則執行右邊的語句。您也可以認為是邏輯運算中的與操作。\n  上例中表示如果/etc/shadow文件存在則列印」 This computer uses shadow passwors」。\n  同樣或操作(||)在shell編程中也是可用的。這裡有個例子：\n  #!/bin/sh\n  mailfolder=/var/spool/mail/james\n  [ -r \"$mailfolder\" ]' '{ echo \"Can not read $mailfolder\" ; exit 1; }\n  echo \"$mailfolder has mail from:\"\n  grep \"^From \" $mailfolder\n\n  該腳本首先判斷mailfolder是否可讀。如果可讀則列印該文件中的\"From\" 一行。如果不可讀則或操作生效，列印錯誤資訊後腳本退出。\n  這裡有個問題，那就是我們必須有兩個命令：\n  -列印錯誤資訊\n  -退出程式\n  我們使用花括號以匿名函數的形式將兩個命令放到一起作為一個命令使用。一般函數將在下文提及。\n  不用與和或操作符，我們也可以用if表達式作任何事情，但是使用與或操作符會更便利很多。\n\n  2.case\n  case :表達式可以用來匹配一個給定的字串，而不是數字。\n  case ... in\n  ...) do something here ;;\n  esac\n  讓我們看一個例子。 file命令可以辨別出一個給定文件的文件類型，比如：\n  file lf.gz\n  這將返回：\n  lf.gz: gzip compressed data, deflated, original filename,\n  last modified: Mon Aug 27 23:09:18 2001, os: Unix\n  我們利用這一點寫了一個叫做smartzip的腳本，該腳本可以自動解壓bzip2, gzip 和zip 類型的壓縮文件：\n  #!/bin/sh\n  ftype=`file \"$1\"`\n  case \"$ftype\" in\n  \"$1: Zip archive\"*)\n  unzip \"$1\" ;;\n  \"$1: gzip compressed\"*)\n  gunzip \"$1\" ;;\n  \"$1: bzip2 compressed\"*)\n  bunzip2 \"$1\" ;;\n  *) echo \"File $1 can not be uncompressed with smartzip\";;\n  esac\n  您可能注意到我們在這裡使用了一個特殊的變數$1。該變數包含了傳遞給該程式的第一個參數值。\n  也就是說，當我們運行：\n  smartzip articles.zip\n  $1 就是字串 articles.zip\n\n  3. selsect\n  select 表達式是一種bash的擴展應用，尤其擅長於交互式使用。用戶可以從一組不同的值中進行選擇。\n  select var in ... ; do\n  break\n  done\n  .... now $var can be used ....\n  下面是一個例子：\n  #!/bin/sh\n  echo \"What is your favourite OS?\"\n  select var in \"Linux\" \"Gnu Hurd\" \"Free BSD\" \"Other\"; do\n  break\n  done\n  echo \"You have selected $var\"\n  下面是該腳本運行的結果：\n  What is your favourite OS?\n  1) Linux\n  2) Gnu Hurd\n  3) Free BSD\n  4) Other\n  #? 1\n  You have selected Linux\n\n  4.loop\n\n  loop表達式：\n  while ...; do\n  ....\n  done\n  while-loop 將運行直到表達式測試為真。will run while the expression that we test for is true.\n  關鍵字\"break\" 用來跳出循環。而關鍵字」continue」用來不執行餘下的部分而直接跳到下一個循環。\n\n  for-loop表達式查看一個字串列表 (字串用空格分隔) 然後將其賦給一個變數：\n  for var in ....; do\n  ....\n  done\n  在下面的例子中，將分別列印ABC到螢幕上：\n  #!/bin/sh\n  for var in A B C ; do\n  echo \"var is $var\"\n  done\n  下面是一個更為有用的腳本showrpm，其功能是列印一些RPM包的統計資訊：\n  #!/bin/sh\n  # list a content summary of a number of RPM packages\n  # USAGE: showrpm rpmfile1 rpmfile2 ...\n  # EXAMPLE: showrpm /cdrom/RedHat/RPMS/*.rpm\n  for rpmpackage in $*; do\n  if [ -r \"$rpmpackage\" ];then\n  echo \"=============== $rpmpackage ==============\"\n  rpm -qi -p $rpmpackage\n  else\n  echo \"ERROR: cannot read file $rpmpackage\"\n  fi\n  done\n  這裡出現了第二個特殊的變數$*，該變數包含了所有輸入的命令行參數值。\n  如果您運行showrpm openssh.rpm w3m.rpm webgrep.rpm\n  此時 $* 包含了 3 個字串，即openssh.rpm, w3m.rpm and webgrep.rpm.\n\n  5. 引號\n  在向程式傳遞任何參數之前，程式會擴展萬用字元和變數。這裡所謂擴展的意思是程式會把萬用字元\n  （比如*）替換成合適的文件名，它變數替換成變數值。為了防 止程式作這種替換，您可以使用\n  引號：讓我們來看一個例子，假設在當前目錄下有一些文件，兩個jpg文件， mail.jpg 和tux.jpg。\n \n1.2 編譯SHELL腳本 \n#ch#!/bin/sh mod +x filename \necho *.jpg ∪緩螅□□梢醞□□淙耄?./filename 來執行您的腳本。 \n這將列印出\"mail.jpg tux.jpg\"的結果。 \n引號 (單引號和雙引號) 將防止這種萬用字元擴展： \n#!/bin/sh \necho \"*.jpg\" \necho '*.jpg' \n這將列印\"*.jpg\" 兩次。 \n單引號更嚴格一些。它可以防止任何變數擴展。雙引號可以防止萬用字元擴展但允許變數擴展。 \n#!/bin/sh \necho $SHELL \necho \"$SHELL\" \necho '$SHELL' \n運行結果為： \n/bin/bash \n/bin/bash \n$SHELL \n最後，還有一種防止這種擴展的方法，那就是使用轉義字元——反斜桿： \necho *.jpg \necho $SHELL \n這將輸出： \n*.jpg \n$SHELL\n\n6. Here documents\n當要將幾行文字傳遞給一個命令時，here documents（譯者註：目前還沒有見到過對該詞適合的翻譯）\n一種不錯的方法。對每個腳本寫一段幫助性的文字是很有用的，此時如果我們四有那個 here documents\n就不必用echo函數一行行輸出。 一個 \"Here document\" 以 << 開頭，後面接上一個字串，這個字串\n還必須出現在here document的末尾。下面是一個例子，在該例子中，我們對多個文件進行重命名，並且\n使用here documents列印幫助： \n#!/bin/sh \n# we have less than 3 arguments. Print the help text: \nif [ $# -lt 3 ] ; then \ncat < \nren -- renames a number of files using sed regular expressions \nUSAGE: ren 'regexp' 'replacement' files... \nEXAMPLE: rename all *.HTM files in *.html: \nren 'HTM$' 'html' *.HTM \nHELP \nexit 0 \nfi \nOLD=\"$1\" \nNEW=\"$2\" \n# The shift command removes one argument from the list of \n# command line arguments. \nshift \nshift \n# $* contains now all the files: \nfor file in $*; do \nif [ -f \"$file\" ] ; then \nnewfile=`echo \"$file\" | sed \"s/${OLD}/${NEW}/g\"` \nif [ -f \"$newfile\" ]; then \necho \"ERROR: $newfile exists already\" \nelse \necho \"renaming $file to $newfile ...\" \nmv \"$file\" \"$newfile\" \nfi \nfi \ndone \n這是一個複雜一些的例子。讓我們詳細討論一下。第一個if表達式判斷輸入命令行參數是\n否小於3個 (特殊變數$# 表示包含參數的個數) 。如果輸入參數小於3個，則將幫助文字傳遞\n給cat命令，然後由cat命令將其列印在螢幕上。列印幫助文字後程式退出。 如果輸入參數等\n於或大於3個，我們就將第一個參數賦值給變數OLD，第二個參數賦值給變數NEW。下一步，我\n們使用shift命令將第一個和第二個參數從 參數列表中刪除，這樣原來的第三個參數就成為參\n數列表$*的第一個參數。然後我們開始循環，命令行參數列表被一個接一個地被賦值給變數$file。\n接著我 們判斷該文件是否存在，如果存在則通過sed命令搜索和替換來產生新的文件名。然後\n將反短斜線內命令結果賦值給newfile。這樣我們就達到了我們的目 的：得到了舊文件名和新\n文件名。然後使用mv命令進行重命名。 \n4)函數\n如果您寫了一些稍微複雜一些的程式，您就會發現在程式中可能在幾個地方使用了相同的代碼，\n並且您也會發現，如果我們使用了函數，會方便很多。一個函數是這個樣子的： \nfunctionname() \n{ \n# inside the body $1 is the first argument given to the function \n# $2 the second ... \nbody \n} \n您需要在每個程式的開始對函數進行聲明。\n\n下面是一個叫做xtitlebar的腳本，使用這個腳本您可以改變終端窗口的名稱。\n這裡使用了一個叫做help的函數。正如您可以看到的那樣，這個定義的函數被使用了兩次。 \n#!/bin/sh \n# vim: set sw=4 ts=4 et: \nhelp() \n{ \ncat < \nxtitlebar -- change the name of an xterm, gnome-terminal or kde konsole \nUSAGE: xtitlebar [-h] \"string_for_titelbar\" \nOPTIONS: -h help text \nEXAMPLE: xtitlebar \"cvs\" \nHELP \nexit 0 \n} \n# in case of error or if -h is given we call the function help: \n[ -z \"$1\" ] && help \n[ \"$1\" = \"-h\" ] && help \n# send the escape sequence to change the xterm titelbar: \necho -e \"33]0;$107\" \n#\n\n在腳本中提供幫助是一種很好的編程習慣，這樣方便其他用戶（和您）使用和理解腳本。 \n命令行參數 \n我們已經見過$* 和 $1, $2 ... $9 等特殊變數，這些特殊變數包含了用戶從命令\n行輸入的參數。迄今為止，我們僅僅瞭解了一些簡單的命令行語法（比如一些強制性的\n參數和查看幫助的-h選項）。 但是在編寫更複雜的程式時，您可能會發現您需要更多的\n自定義的選項。通常的慣例是在所有可選的參數之前加一個減號，後面再加上參數值 (\n比如文件名)。 \n有好多方法可以實現對輸入參數的分析，但是下面的使用case表達式的例子無遺是一個不錯的方法。 \n#!/bin/sh \nhelp() \n{ \ncat < \nThis is a generic command line parser demo. \nUSAGE EXAMPLE: cmdparser -l hello -f -- -somefile1 somefile2 \nHELP \nexit 0 \n} \nwhile [ -n \"$1\" ]; do \ncase $1 in \n-h) help;shift 1;; # function help is called \n-f) opt_f=1;shift 1;; # variable opt_f is set \n-l) opt_l=$2;shift 2;; # -l takes an argument -> shift by 2 \n--) shift;break;; # end of options \n-*) echo \"error: no such option $1. -h for help\";exit 1;; \n*) break;; \nesac \ndone\n\necho \"opt_f is $opt_f\" \necho \"opt_l is $opt_l\" \necho \"first arg is $1\" \necho \"2nd arg is $2\" \n您可以這樣運行該腳本： \ncmdparser -l hello -f -- -somefile1 somefile2 \n返回的結果是： \nopt_f is 1 \nopt_l is hello \nfirst arg is -somefile1 \n2nd arg is somefile2 \n這個腳本是如何工作的呢？腳本首先在所有輸入命令行參數中進行循環，將輸入參數\n與case表達式進行比較，如果匹配則設置一個變數並且移除該參數。根據unix系統的慣例，\n首先輸入的應該是包含減號的參數.\n第2部分 實例\n現在我們來討論編寫一個腳本的一般步驟。任何優秀的腳本都應該具有幫助和輸入參數。並且寫一個偽腳本（framework.sh），該腳本包含了大多數腳本都需要的框架結構，是一個非常不錯的主意。這時候，在寫一個新的腳本時我們只需要執行一下copy命令： \ncp framework.sh myscript \n然後再插入自己的函數。 \n讓我們再看兩個例子： \n二進位到十進位的轉換 \n腳本 b2d 將二進位數 (比如 1101) 轉換為相應的十進位數。這也是一個用expr命令進行數學運算的例子： \n#!/bin/sh \n# vim: set sw=4 ts=4 et: \nhelp() \n{ \ncat < \nb2h -- convert binary to decimal \nUSAGE: b2h [-h] binarynum \nOPTIONS: -h help text \nEXAMPLE: b2h 111010 \nwill return 58 \nHELP \nexit 0 \n} \nerror() \n{ \n# print an error and exit \necho \"$1\" \nexit 1 \n} \nlastchar() \n{ \n# return the last character of a string in $rval \nif [ -z \"$1\" ]; then \n# empty string \nrval=\"\" \nreturn \nfi \n# wc puts some space behind the output this is why we need sed: \nnumofchar=`echo -n \"$1\" | wc -c | sed 's/ //g' ` \n# now cut out the last char \nrval=`echo -n \"$1\" | cut -b $numofchar` \n}\n\nchop() \n{ \n# remove the last character in string and return it in $rval \nif [ -z \"$1\" ]; then \n# empty string \nrval=\"\" \nreturn \nfi \n# wc puts some space behind the output this is why we need sed: \nnumofchar=`echo -n \"$1\" | wc -c | sed 's/ //g' ` \nif [ \"$numofchar\" = \"1\" ]; then \n# only one char in string \nrval=\"\" \nreturn \nfi \nnumofcharminus1=`expr $numofchar \"-\" 1` \n# now cut all but the last char: \nrval=`echo -n \"$1\" | cut -b 0-${numofcharminus1}` \n} \nwhile [ -n \"$1\" ]; do \ncase $1 in \n-h) help;shift 1;; # function help is called \n--) shift;break;; # end of options \n-*) error \"error: no such option $1. -h for help\";; \n*) break;; \nesac \ndone \n# The main program \nsum=0 \nweight=1 \n# one arg must be given: \n[ -z \"$1\" ] && help \nbinnum=\"$1\" \nbinnumorig=\"$1\"\n\nwhile [ -n \"$binnum\" ]; do \nlastchar \"$binnum\" \nif [ \"$rval\" = \"1\" ]; then \nsum=`expr \"$weight\" \"+\" \"$sum\"` \nfi \n# remove the last position in $binnum \nchop \"$binnum\" \nbinnum=\"$rval\" \nweight=`expr \"$weight\" \"*\" 2` \ndone \necho \"binary $binnumorig is decimal $sum\" \n該腳本使用的算法是利用十進位和二進位數權值 (1,2,4,8,16,..)，比如二進位\"10\"可\n以這樣轉換成十進位： \n0 * 1 + 1 * 2 = 2 \n為了得到單個的二進位數我們是用了lastchar 函數。該函數使用wc –c計算字元個數，\n然後使用cut命令取出末尾一個字元。Chop函數的功能則是移除最後一個字元。\n\n文件循環程式 \n或許您是想將所有發出的郵件保存到一個文件中的人們中的一員，但是在過了幾個月\n以後，這個文件可能會變得很大以至於使對該文件的訪問速度變慢。下面的 腳本rotatefile\n可以解決這個問題。這個腳本可以重命名郵件保存文件（假設為outmail）為outmail.1，\n而對於outmail.1就變成了outmail.2 等等等等... \n#!/bin/sh \n# vim: set sw=4 ts=4 et: \nver=\"0.1\" \nhelp() \n{ \ncat < \nrotatefile -- rotate the file name\n\nUSAGE: rotatefile [-h] filename\n\nOPTIONS: -h help text \nEXAMPLE: rotatefile out \nThis will e.g rename out.2 to out.3, out.1 to out.2, out to out.1 \nand create an empty out-file \nThe max number is 10 \nversion $ver \nHELP \nexit 0 \n}\n\nerror() \n{ \necho \"$1\" \nexit 1 \n} \nwhile [ -n \"$1\" ]; do \ncase $1 in \n-h) help;shift 1;; \n--) break;; \n-*) echo \"error: no such option $1. -h for help\";exit 1;; \n*) break;; \nesac \ndone \n# input check: \nif [ -z \"$1\" ] ; then \nerror \"ERROR: you must specify a file, use -h for help\" \nfi \nfilen=\"$1\" \n# rename any .1 , .2 etc file: \nfor n in 9 8 7 6 5 4 3 2 1; do \nif [ -f \"$filen.$n\" ]; then \np=`expr $n + 1` \necho \"mv $filen.$n $filen.$p\" \nmv $filen.$n $filen.$p \nfi \ndone \n# rename the original file: \nif [ -f \"$filen\" ]; then \necho \"mv $filen $filen.1\" \nmv $filen $filen.1 \nfi \necho touch $filen \ntouch $filen \n這個腳本是如何工作的呢？在檢測用戶提供了一個文件名以後，我們進行一個9到1的循環。文件9被命名為10，文件8重命名為9等等。\n循環完成之後，我們將原始文件命名為文件1同時建立一個與原始文件同名的空文件。 \n調試 //---------------------------------------　\n//--------------------------------------- \n最簡單的調試命令當然是使用echo命令。您可以使用echo在任何懷疑出錯的地方列印任何變數值。\n這也是絕大多數的shell程式員要花費80%的時間來調試程式的原因。Shell程式的好處在於不需要重新編譯，插入一個echo命令也不需要多少時間。 \nshell也有一個真實的調試模式。如果在腳本\"strangescript\" 中有錯誤，您可以這樣來進行調試： \nsh -x strangescript \n這將執行該腳本並顯示所有變數的值。 \nshell還有一個不需要執行腳本只是檢查語法的模式。可以這樣使用： \nsh -n your_script \n這將返回所有語法錯誤。 \n\n\n\n/***************************************************************************/\nShell Script            ref: http://www.twbsd.org/cht/book/ch24.htm\n/***************************************************************************/\n身為 UNIX 系統管理者除了要熟悉 UNIX 指令外，我們最好學會幾種 scripts 語言，例如 shell script 或 perl。學會 script 語言後，我們就可以將日常的系統管理工作寫成一支執行檔，如此一來，在管理系統時就可以更加靈活。\nShell script 是最基本的 script 語言，它是一堆 UNIX 指令的集合。本章將介紹 Shell script 的基本功能及語法，期望讀者可以經由學習 Shell scripts 讓使用 UNIX 系統時可以更加得心應手。\n\n24.1 概論\nShell Script 是一個類似 MS Windows 中 .bat 檔的東西，簡單的說，Shell Script 就是將一堆 shell 中的指令放在一個文字檔中來執行。因此，為了能寫出一個 shell Script，你必須先對 UNIX 指令有初步的認識。身為一個 UNIX 系統的管理者，一定要會使用 shell script 來使管理工作更加容易。\n一般我們會將 Shell Script 的副檔名命名為 .sh，但並非一定要這麼做，這樣做只是為了要讓我們更容易管理這些檔案。在介紹如何 Shell Script 的內容之前，我們先來看如何寫出一個 Shell Script 並執行它。假設我們要寫一個名為 test.sh 的 Shell Script，首先用你習慣使用的文字編輯軟體來開一個檔案名為 test.sh 內容如下：\n#!/bin/sh\necho Hello world!!\n第一行是必需的，用來定義你要使用的 shell。這裡我們定義要使用的是 Bourne Shell，其所在路徑是 /bin/sh。在 UNIX 系統中有許多不同的 Shell 可以使用，而每個 Shell 的特性及用法都有些許的不同。因此，在寫 Shell Script 時，我們會針對 Bourne Shell (sh) 來寫，因為 sh 是所有 UNIX 系統中都會有的 Shell。就算你執行 Shell Script 時的環境不是使用 sh，只要加上第一行 #!/bin/sh 就可以在執行此 Shell Script 時使用 sh。而第二行的 echo 代表列出一個字串，我們常使用它來輸出資訊。將 test.sh 存檔後，我們就可以用下列其中一種方式執行它：\n1. 轉向輸入\n$ sh < test.sh\n2. 如果要輸入參數的話，第一種方式便不適用，可以改用這種方法。<arguments> 就是我們要輸入的參數，在上面的 test.sh 中並不需要輸入參數：\n$ sh test.sh <arguments>\n3.你也可以改變 test.sh 的權限，將它變成可以獨立執行的檔案，這樣就可以只打 test.sh 來執行它：\n$ chmod a+x test.sh\n$ ./test.sh\n在 Shell Script 中，你們可以使用 # 為註解，在 # 後面的字串都將被視為註解而被式忽略。而分號 ; 則代表新的一行，例如打 ls;ls -d 代表二個指令。另外，我們可以使用變數、流程序控制制、甚至是副函式來使程式更加靈活。以下的各章節我們會詳細加以說明。\n\n24.2 變數的使用\n24.2.1 變數的使用\n我們知道 Shell Script 是使用一堆指令拼湊而成，為了方便說明及練習起見，我們不使用編輯檔案的方式來執行，而改以在命令列中打我們要的指令。首先，先打 sh 來進入 Bourne Shell。\n% sh\n$\n在打了 sh 之後，會進入 Bourne Shell，其一般使用者的提示字元為 $。以下各指令開頭的 $ 表示提示字元，而 $ 之後的粗體字才是我們輸入的字串。\n在 Shell Script 中，所有的變數都視為字串，因此並不需要在定義變數前先定義變數類型。在 Shell 中定義和使用變數時有些許的差異。例如，我們定義一個變數 color 並令它的值為 red，接著使用 echo 來印出變數 color 的值：\n\n$ color=red\n$ echo $color\nred\n在這裡，以 color=red 來定義變數 color 的值為 red，並以 echo $color 來印出 color 這一個變數。\n在定義變數時，不必加 $，但是在使用它時，必須加上 $。請注意，在等號的二邊不可以有空白，否則將出現錯誤 ，系統會誤以為你要執行一個指令。\n我們再介紹一個範例：\n$ docpath=/home/td/src/doc\n$ echo $docpath\n/home/td/src/doc\n$ ls $docpath\nabc.txt abc2.txt semmt.doc\n$ ls $docpaht/*.txt\nabc.txt abc2.txt\n這裡我們定義了變數 docpath 的值為 /home/td/src/doc，並印出它。接著我們使用 ls 這個指令來印出變數 docpath 目錄中所有檔案。 再以 ls $docpath/*.txt 來印出 /home/td/src/doc/ 目錄下所有副檔名為 .txt 的檔案。\n我們再來看一個例子，說明如何使用變數來定義變數：\n$ tmppath=/tmp\n$ tmpfile=$tmppath/abc.txt\n$ echo $tmpfile\n/tmp/abc.txt\n另外，我們也可以使用指令輸出成為變數，請注意這裡使用的二個 ` 是位於鍵盤左上角的 ` ，在 shell script 中，使用 ` 包起來的代表執行該指令：\n$ now=`date`\n$ echo $now\nMon Jan 14 09:30:14 CST 2002\n如果在變數之後有其他字串時，要使用下列方式來使用變數：\n$ light=dark\n$ echo ${light}blue\ndarkblue\n$ echo \"$light\"blue\ndarkblue\n這裡雙引號中的字將會被程式解讀，如果是使用單引號將直接印出 $light 而非 dark。\n\n經由上面幾個簡單的例子，相信您對變數的使用已有初步的認識。另外有一些我們必須注意的事情：\n$ color=blue\n$ echo $color\nblue\n$ echo \"$color\"\nblue\n$ echo '$color'\n$color\n$ echo \\$color\n$color\n$ echo one two three\none two three\n$ echo \"one two three\"\none two three\n我們可以看到上面各個執行結果不大相同。在 Shell Script 中，雙引號 \" 內容中的特殊字元不會被忽略，而單引號中的所有特殊字元將被忽略。另外，\\ 之後的一個字元將被視為普通字串。\n\n如果您希望使用者能在程式執行到一半時輸入一個變數的值，您可以使用 read 這個指令。請看以下的範例：\n#!/bin/sh\nprintf \"Please input your name:\"\nread Name\necho \"Your name is $Name\"\n由於 echo 指令內定會自動換行，所以我們使用 printf 這個指令來輸出字串。我們將上述內容存成檔案 input.sh，接著使用下列指令來執行：\n\n$ sh input.sh\nPlease input your name:Alex\nYour name is Alex\n您可以看到變數 Name 已被設為您所輸入的字串了。\n\n24.2.2 程式會自動定義的變數\n在執行 Shell Script 時，程式會自動產生一些變數：\n變數名稱        說明\n$?              表示上一個指令的離開狀況，一般指令正常離開會傳回 0。不正常離開則會傳回 1、2 等數值。\n$$              這一個 shell 的 process ID number\n$!              最後一個在背景執行的程式的 process number\n$-              這個參數包含了傳遞給 shell 旗標 (flag)。\n$1              代表第一個參數，$2 則為第二個參數，依此類推。而 $0 為這個 shell script 的檔名。\n$#              執行時，給這個 Shell Script 參數的個數\n$*              包含所有輸入的參數，$@ 即代表 $1, $2,....直到所有參數結束。$* 將所有參數無間隔的連在一起，存成一個單一的參數。也就是說 $* 代表了 \"$1 $2 $3...\"。\n$@              包含所有輸入的參數，$@ 即代表 $1, $2,....直到所有參數結束。$@ 用將所有參數以空白為間隔，存在 $@ 中。也就是說 $@ 代表了 \"$1\" \"$2\" \"$3\"....。\n\n以下我們舉幾個例子來說明：\n$ ls -d /home\n/home\n$ echo $?\n0\n$ ls /home/aaa/bb/ccc\n/home/aaa/bb/cc: No such file or directory\n$ echo $?\n2\n$ echo $?\n0\n上面例子中的第一行是 ls，我們可以看到存在一個目錄 /home，接者 echo $? 時，出現 0 表示上一次的命令正常結束。接著我們 ls 一個不存在的目錄，再看 $? 這個變數變成 2，表示上一次執行離開的結果不正常。最後一個 echo $? 所得到的結果是 0，因為上一次執行 echo 正常顯示 2。\n\n如果寫一個檔案名為 abc.sh，內容如下：\n#!/bin/sh\necho $#: $1 $2 $3 $4 $5 $6 $7 $8 $9\necho $@\n接著以下列指令來執行該檔案：\n\n$ chmod a+x abc.sh\n$ ./abc.sh a \"b c d\" e f\n4:a b c d e f\na b c d e f\n上面最後二行即為執行結果。我們可以看到 $# 即為參數的個數，而 $1, $2, $3...分別代表了輸入的參數 \"a\", \"b c d\", \"e\", \"f\"，而最後的 $@ 則是所有參數。\n\n24.2.3 系統內定的標準變數\n你可以使用 set 這個指令來看目前系統中內定了哪些參數。一般而言會有 $HOME, $SHELL, $USER, $PATH 等。\n$ echo $HOME\n/home/jack\n$ echo $PATH\n/usr/bin:/usr/sbin:/bin\n\n24.2.4 空變數的處理\n如果程式執行時，有一個變數的值尚未被給定，你可以利用下列方式來設定對於這種情形提出警告：\n$ echo $number one\none\n$ set -u\n$ echo $number one\nsh: ERROR: number: Parameter not set\n在 set -u 之後，如果變數尚未設定，則會提出警告。你也可以利用下列的方式來處理一些空變數及變數的代換：\n\n運算式          說明\n${var:-word}    如果變數 var 尚未設定或是 null，則將使用 word 這個值，但不改變 var 變數的內容。\n${var:=word}    如果變數 var 尚未設定或是 null，則變數 var 的內容將等於 word 這個字串，並使用這個新的值。\n${var:?word}    如果變數 var 已經設定了，而且不是 null，則將使用變數 var。否則則印出 word 這個字串，並強制離開程式。我們可以設定一個字串 \"Parameter null or not set\" 來在變數未設定時印出，並終止程式。\n${var:+word}    如果變數 var 已經設定了，而且不是 null，則以 word 這個字串取代它，否則就不取代。\n\n我們以下面的例子來說明：\n$ echo $name Wang\nWang\n$ echo ${name:-Jack} Wang\nJack Wang\n$ echo $name Wang\nWang\n上面的例子中，變數 $name 並未被取代，而下面的例子中，$name 將被取代：\n\n$ echo $name Wang\nWang\n$ echo ${name:=Jack} Wang\nJack Wang\n$ echo $name Wang\nJack Wang\n24.3 運算符號\n\n24.3.1 四則運算\n在 shell 中的四則運算必須使用 expr 這個指令來輔助。因為這是一個指令，所以如果要將結果指定給變數，必須使用 ` 包起來。請注意，在 + - * / 的二邊都有空白，如果沒有空白將產生錯誤：\n$ expr 5 -2\n3\n$ sum=`expr 5 + 10`\n$ echo $sum\n15\n$ sum=`expr $sum / 3`\n$ echo $sum\n5\n還有一個要特別注意的是乘號 * 在用 expr 運算時，不可只寫 *。因為 * 有其他意義，所以要使用 \\* 來代表。另外，也可以用 % 來求餘數。\n\n$ count=`expr 5 \\* 3`\n$ echo $count\n$ echo `expr $count % 3`\n5\n我們再列出更多使用 expr 指令的方式，下列表中為可以放在指令 expr 之後的表達式。有的符號有特殊意義，必須以 \\ 將它的特殊意義去除，例如 \\*，否則必須用單引號將它括起來，如 '*'：\n\n類別            語法            說明\n條件判斷        expr1 \\| expr2  如果 expr1 不是零或 null 則傳回 expr1，否則傳回 expr2。\n                expr1 \\& expr2  如果 expr1 及 expr2 都不為零或 null，則傳回 expr1，否則傳回 0。\n四則運算        expr1 + expr2   傳回 expr1 加 expr2 後的值。\n                expr1 - expr2   傳回 expr1 減 expr2 後的值。\n                expr1\\* expr2   傳回 expr1 乘 expr2 後的值。\n                expr1 / expr2   傳回 expr1 除 expr2 後的值。\n                expr1 % expr2   傳回 expr1 除 expr2 的餘數。\n大小判斷        expr1 \\> expr2  如果 expr1 大於 expr2 則傳回 1，否則傳回 0。如果 expr1 及 expr2 都是數字，則是以數字大小判斷，否則是以文字判斷。以下皆同。\n                expr1 \\< expr2  如果 expr1 小於 expr2 則傳回 1，否則傳回 0。\n                expr1 = expr2   如果 expr1 等於 expr2 則傳回 1，否則傳回 0。\n                expr1 != expr2  如果 expr1 不等於 expr2 則傳回 1，否則傳回 0。\n                expr1 \\>= expr2 如果 expr1 大於或等於 expr2 則傳回 1，否則傳回 0。\n                expr1 \\<= expr2 如果 expr1 小於或等於 expr2 則傳回 1，否則傳回 0。\n文字處理        expr1 : expr2   比較一固定字串，即 regular expression。可以使用下列字元來輔助：\n                                . 匹配一個字元。\n                                $ 找字串的結尾。\n                                [list] 找符合 list 中的任何字串。\n                                * 找尋 0 個或一個以上在 * 之前的字。\n                                \\( \\) 傳回括號中所匹配的字串。\n\n我們針對比較複雜的文字處理部份再加以舉例：\n$ tty\nttyp0\n$ expr `tty` : \".*\\(..\\)\\$\"\np0\n$ expr `tty` : '.*\\(..\\)$'\np0\n上面執行 tty 的結果是 ttyp0，而在 expr 中，在 : 右側的運算式中，先找 .* 表示0個或一個以上任何字元，傳回之後在結尾 ($) 時的二個字元 \\(..\\)。在第一個 expr 的式子中，因為使用雙引號，所以在 $ 之前要用一個 \\ 來去除 $ 的特殊意義，而第二個 expr 是使用單引號，在單引號內的字都失去了特殊意義，所以在 $ 之前不必加 \\。\n除了使用 expr 外，我們還可以使用下列這種特殊語法：\n\n$ a=10\n$ b=5\n$ c=$((${a}+${b}))\n$ echo $c\n15\n$ c=$((${a}*${b}))\n$ echo $c\n50\n我們可以使用 $(()) 將運算式放在括號中，即可達到運算的功能。\n\n24.3.2 簡單的條件判斷\n最簡單的條件判斷是以 && 及 || 這二個符號來表示。\n$ ls /home && echo found\nfound\n$ ls /dev/aaaa && echo found\nls: /dev/aaaa: No such file or directory\n$ ls -d /home || echo not found\n/home\n$ ls /dev/aaaa && echo not found\nls: /dev/aaaa: No such file or directory\n條件式          說明\na && b          如果 a 是真，則執行 b。如果 a 是假，則不執行 b。\na || b          如果 a 是假，則執行 b。如果 a 是真，則不執行 b。\n\n24.3.3 以 test 來比較字串及數字\n我們說過 Shell Script 是一堆指令的組合，所以在比較字串及數字時一樣是經由系統指令來達成。這裡我們使用 test 及 [ 來做運算，運算所傳回的結果是真 (true) 或假 ( false)。我們可以將它應用在條件判斷上。test 和 [ 都是一個指令，我們可以使用 test 並在其後加上下表中的參數來判斷真假。或者也可以使用 [ 表達式 ] 來替代 test，要注意的是 [ ] 中的空白間隔。\n表達式          說明\n-n str1         如果字串 str1 的長度大於 0 則傳回 true。\n-z str1         如果字串 str1 的長度等於 0 則傳回 true。\nstr1            如果字串 str1 不是 null 則傳回 true。\nstr1 = str2     如果 str1 等於 str2 則傳回 true。等號二邊有空白。\nstr1 != str2    如果 str1 不等於 str2 則傳回 true。!= 的二邊有空白。\na -eq b         Equal，等於。a 等於 b 則傳回真 (true)。\na -ne b         Not equal，不等於。a 不等於 b 則傳回真 (true)。\na -gt b         Grwater than，大於。a 大於 b 則傳回真 (true)。\na -lt b         Less Than，小於。a 小於 b 則傳回真 (true)。\na -ge b         Greater or equal，大於或等於。a 大於或等於 b 則傳回真 (true)。\na -le b         Less or equal，小於或等於。a 小於或等於 b 則傳回真 (true)。\n我們舉例來說明：\n$ test 5 -eq 5 && echo true\ntrue\n$ test abc!=cde && echo true\nture\n$ [ 6 -lt 10 ] && echo true\nture\n\n$ pwd\n/home\n$ echo $HOME\n/home/jack\n$ [ $HOME = `pwd` ] || echo Not home now\nNot home now\n24.3.4 以 test 來處理檔案\n\n我們也可以使用 test 及 [ 來判斷一個檔案的類型。下表中為其參數：\n用法            說明\n-d file         如果 file 為目錄則傳回真(true)。\n-f file         如果 file 是一般的檔案則傳回真(true)。\n-L file         如果 file 是連結檔則傳回真(true)。\n-b file         如果 file 是區塊特別檔則傳回真(true)。\n-c file         如果 file 是字元特別檔則傳回真(true)。\n-u file         如果file 的 SUID 己設定則傳回真(true)。\n-g file         如果file 的 SGID 己設定則傳回真(true)。\n-k file         如果file 的 sticky bit 己設定則傳回真(true)。\n-s file         如果 file 的檔案長度大於 0 則傳回真(true)。\n-r file         如果 file 可以讀則傳回真(true)。\n-w file         如果 file 可以寫則傳回真(true)。\n-x file         如果 file 可以執行則傳回真(true)。\n\n我們舉例來說明：\n$ [ -d /bin ] && echo /bin is a directory\n/bin is a directory\n$ test -r /etc/motd && echo /etc/motd is readable\n/etc/motd is readable\n第一個指令測試 /bin 是否存在，而且是一個目錄，如果是則執行 echo 傳回一個字串。第二個指令是測試 /etc/motd 是否可以被讀取，如果是則執行 echo 傳回一個字串。\n\n24.4 內建指令\n在 Shell 中有一些內建的指令，這些內建的指令如流程序控制制及 cd 等指令是 Shell 中的必備元素。\n另外還有一些為了提高執行效率的指令，如 test、echo 等。有的內建指令在系統中也有同樣名稱不同版本的相同指令，\n但是如 test、echo 等在執行時會偽裝成是在 /bin 中的指令。\n在寫 shell script 時，要注意指令是否存在。下列即為常見的內建指令：\n指令                    說明\nexit                    離開程式，如果在 exit 之後有加上數字，表示傳回值，如：exit 0。在 UNIX 系統下，當程式正常結束，會傳回一個值 0，如果不正常結束則會傳回一個非 0 的數字。\n. file                  dot 指令，在 shell 中可以使用 \".\" 來呼叫一個外部檔案，例如 . /etc/rc.conf 或 . .profile。注意 . 和其後的指令中間有空白。\necho                    印出一個字串。如果要使用非 shell 內建的 echo 則打 /bin/echo 來使用。\npwd                     顯示目前所在目錄。\nread var ...            從標準輸入 (通常是鍵盤) 讀入一行，然後將第一個字指派給跟在 read 之後的第一個參數，第二個字給第二個參數，依此類推，直到最後將所有字給最後一個參數。如果只有一個參數則將整行都給第一個參數。\nreadonly [var..]        readonly 這個指令如果沒有加參數則顯示目前唯讀的變數。如果有加變數的話，則將該變數設定為唯讀。\nreturn [n]              離開所在函式，如果在其後有加數字的話，則傳回該數字。和 exit 一樣，這個指令可以傳回該函式的執行結果，0 表示正常結束。\nset                     將 $1 到 $n 設定為其參數的字。例如：\n                        $ date\n                        Mon Jan 21 11:19 CST 2002\n                        $ set `date`\n                        $ echo $4\n                        11:19\nwait [n]                等待在執行程式 (PID) 為 n 的背景程式結束，如果沒有加參數 n 則等待所有背景程式結束。\nexec command            執行一個外部程式，通常用於要改變到另一個 shell 或是執行不同的使用者者介面，如：\n                        exec /usr/local/bin/startkde\nexport [var]            設定環境變數，如果沒有參數則印出新的環境變數。\neval command            把參數當成 shell 命令來執行，如：\n                        $ a=c; b=m; c=d; cmd=date\n                        $ eval $`echo $a$b$c`\n                        Mon Jan 21 11:19 CST 2002\n\n24.5 流程序控制制\n24.5.1 if 的條件判斷\n基本語法：\nif condition-list\n      then list\nelif condition-list\n      then list\nelse list\nfi\n範例一：\n#!/bin/sh\nif test -r /etc/motd\n      then cat /etc/motd\nelse  echo \"There is not motd or file is not readable\"\nfi\n說明：上面這一個程式是檢查 /etc/motd 這個檔案是否可以讀，如果可以則印出該檔案，否則印出檔案不可讀。\n\n範例二：\n$ ee test.sh\n#!/bin/sh\nif [ $1 -gt 5 ]\n      then echo \" $1 is bigger then 5\"\nelif [ $1 -ge 0 ]\n      then echo \" $1 is between 5 and 0. \"\nelse echo \"$1 is less then 0.\"\nfi\n$ chmod a+x test.sh\n$ ./test.sh 3\n3 is between 5 and 0.\n說明：這裡我們建立一個檔名為 test.sh 的檔案，以指令 cat test.sh 來看它的內容。接著執行 ./test.sh 3，表示輸入一個參數 3。test.sh 檔案的內容表示依輸入的參數判斷參數大於 5 或介於 5 和 0 的中間，或者是小於 0。\n\n24.5.2 while 及 until 迴圈\n基本語法：\nwhile condition-list\n   do list\n   done\n\nuntil condition-list\n   do list\n   done\n範例一：\n\n#!/bin/sh\ni=1\nwhile [ $i -le 5 ]\n   do\n       echo $i\n       i=`expr $i + 1`\n   done\n說明：首先令變數 i=1，接著在迴圈中當 i 小於等於 5 時就印出 i 的值，每印一次 i 就加 1。直到 i 大於 5 才停止。\n\n範例二：\n#!/bin/sh\ni=1\nuntil [ $i -gt 5 ]\n   do\n       echo $i\n       i=`expr $i + 1`\n   done\n說明：首先令變數 i=1，接著迴圈會判斷，一直執行到 i 大於 5 才停止。每跑一次迴圈就印出 i 的值，每印一次 i 就加 1。注意 while 和 until 的判斷式中，一個是 -le ，一個是 -gt。\n\n24.5.3 for 迴圈\n基本語法：\nfor name in word1 word2 …\n   do do-list\n   done\n\nfor name\n   do do-list\n   done\n範例一：\n\n$ ee color1.sh\n#!/bin/sh\nfor color in blue red green\n    do\n       echo $color\n    done\n$ chmod a+x color1.sh\n$ ./color1.sh\nblue\nred\ngreen\n說明：這個檔案 color1.sh 中，會在每一次迴圈中將關鍵字 in 後面的字串分配給變數 color，然後印出變數 color。關鍵字 in 讓我們可以依序設定一些值並指派給變數，然而，我們也可以不使用關鍵字 in。如果沒有關鍵字 in ，程式會自動讀取輸入的參數，並依序指派給 for 之後的變數。請看範例二。\n\n範例二：\n$ ee color2.sh\n#!/bin/sh\nfor color\n    do\n       echo $color\n    done\n$ chmod a+x color2.sh\n$ ./color2.sh black green yellow\nblack\ngreen\nyellow\n說明：在 color2.sh 這個檔中，for 迴圈沒有使用 in 這個關鍵字。但我們在執行它時輸入三個參數，迴圈會自動將輸入的參數指派給 for 之後的變數 color，並印出它。\n\n24.5.4 case 判斷\n基本語法：\ncase word in\n    pattern1) list1 ;;\n    pattern2) list2 ;;\n    …\nesac\n範例：\n$ ee num.sh\nfor num\ndo\n   case $num in\n       0|1|2|3)       echo $num is between 0~3;;\n       4|5|6|7)       echo $num is between 4~7;;\n       8|9)           echo $num is 8 or 9;;\n       *)             echo $num is not on my list;;\n    esac\ndone\n$ chmod a+x num.sh\n$ ./num.sh 3 8 a\n3 is between 0~3\n8 is 8 or 9\na is not on my list\n說明：這個程式是用來判斷輸入的參數大小。for 迴圈會將每一個輸入的參數指定給變數 num，而在 case 中，判斷變數 num 的內容符合哪一個條件，同一個條件中的每個字用 | 分開。如果未符上面的條件則一定會符合最後一個條件 * 。每一個要執行的 list 是以 ;; 做結尾，如果有多行 list，只要在最後一行加上一個 ;; 即可。\n\n24.6 函式的運用\n在 Shell Script 中也可以使用函式 (function) 來使用程式模組化。\n基本語法：\nname ( )\n{\n    statement\n}\n函式有幾個要注意的地方：\n在使用函式之前一定要先定義它，也就是在一個 Shell Script 中，一定要先寫函式的內容，在檔案最後再寫會呼叫函式的程式部份。\n在 Shell Script 中的變數全部都是全域變數 (Global)，所以在函式中的變數也會影響函式外的其他部份。\n命令列輸入的參數在 Shell Script 中是以 $1, $2....來讀取，但是這些參數並不會在函式中出現。所以必須使用傳遞參數的方式來將要在函式中使用的變數傳給該函式。傳遞的方法和在命令列中使用 Shell Script 的方式一樣，例如：name arg1 arg2..。傳進函式的變數會以 $1,$2... 來儲存，這和命令列傳給 Shell Script 的參數名稱一樣但內容不同。\n範例：\n$ ee test.sh\n#! /bin/sh\nERRLOG=$1\nok ( )\n{\n      read ans\n      case $ans in\n           [yY]*) return 0;;\n           *) return 1;;\n      esac\n}\nerrexit ( )\n{\n      echo $1\n      date >> $ERRLOG\n      echo $1 >> $ERRLOG\n      exit\n}\necho -n  \"Test errexit function [y/n] \"\nok && errexit \"Testing the errexit function\"\necho Normal termination\n$ chmod a+x test.sh\n$ ./test.sh err.log\n說明：\n這個程式中有二個函式：errexit 及 ok。第一行定義要將 log 檔存在傳給這個 Shell Script 的第一個參數。接著是二個函式，之後印出一行字，echo -n 表示印出字後游標不換行。然後再執行 ok 這個函式，如果 ok 函式執行成功則再執行 errexit 函式，並傳給 errexit 函式一個字串，最後再印出一個字串。\n在 ok 函式中，使用 read 指令來讀入一個參數並指派給變數 ans。接著判斷使用者輸入的值是否為 Y 或 y，如果是則傳回 1 代表沒有成功執行，如果不是則傳回 0 代表成功執行函式 ok。\n如果 ok 函式傳回 1 便不會執行 errexit 函式。如果是 0 則在 errexit 函式中，會先印出要傳給 errexit 的參數 \" Testing the errexit function\"，並記錄在指定的檔案中。\n \n\n/***************************************************************************/\n// Linux Shell 中的 「.」和source，export\n/***************************************************************************/\n之前寫了個shell腳本，並export的環境變數，在竟然看不到。\n為什麼在shell腳本裡面用export設置環境變數之後，當shell執行完了，用set命令看不到呢？但是你如果直接在終端裡export 環境變數用set是看到的。 \n\n這裡要說一下shell的執行方法了，舉個例子來講： \n一個shell腳本test.sh的內容為： \n#!/bin/bash \necho \"-- Add PATH-------------\"\nexport PATH=/home/pathto/usr/bin:$PATH\n\n當我們執行test.sh的時候，是在當前的終端所在的shell fork出一個子shell然後執行test.sh的，執行完了再返回終端所在的shell。\n因此在test.sh設置了環境變數，它只在fork出來的這個子shell中生效，子shell只能繼承父shell的環境變數，而不能修改父shell的環境變數，所以test.sh結束後，父進程的環境就覆蓋回去。\n所以在test.sh之後完之後，我們用set命令是看不了這個環境變數的值的。 \n\n那如何讓腳本的環境變數在腳本執行之後仍然對當前終端存在呢？\n用sorcue 或者.(dot)。明確告訴shell不要fork執行腳本，而是在當前的shell執行，這樣環境變數就可以保存下來了。 \nsource命令用法： \nsource Filename （通常用「.」來代替） \nsource test.sh 與 .test.sh是相同的。 \n\n\n/******************************************************************************/\n// Linux shell的for迴圈寫法\n/******************************************************************************/\n# vim loop_sh.sh\nfor((i=0; i<5; i++))\ndo\n    echo \"loop num i is $i\"\ndone\n\n也可寫成：\nfor((i=0; i<5; i++)); do echo \"num is j $j\"; done\n\n# ./loop_sh.sh\nloop num i is 0\nloop num i is 1\nloop num i is 2\nloop num i is 3\nloop num i is 4\nloop num j is 0\nloop num j is 1\nloop num j is 2\nloop num j is 3\nloop num j is 4\n\n\n/******************************************************************************/\nLinux Shell Script\n/******************************************************************************/\n1. 條件式判斷(if..else..)\nif [條件一]; then\n     執行一\nelif [條件二]; then\n    執行二\nelse\n    執行三\nfi\n\n多個條件在 if 裡的條件式裡，同一個判斷行可以有很多的條件，可以使用邏輯運算符號來表示：\n&& 且,\n|| 或,\n== 等於\nEx:\nif [ \"$TEST1\" == \"1234\" ] && [ \"$TEST2\" == \"45678\" ]; then\n當變數 $TEST1 等於 1234 且 變數 $TEST2 等於 45678 的時候才做動作，否則跳到下一個條件式。\nif [ \"$TEST1\" == \"1234\" ] || [ \"$TEST2\" == \"45678\" ]; then\n當變數 $TEST1 等於 1234 或 變數 $TEST2 等於 45678 的時候就做動作，否則跳到下一個條件式\n\n檔案判斷\n以下是常用的檔案判斷檔案、目錄的類型判斷\n-f：檢查檔案是否存在\n-d：檢查目錄是否存在\n-e：檢查檔案或目錄是否存在\nEx:\nif [ -f /etc/fstab ]; then\nif [ -d /etc ]; then\nif [ -e /etc ]; then\n\n檔案、目錄的權限判斷\n-r：檢查該檔案、目錄是否可讀\n-w：檢查該檔案、目錄是否可寫\n-x：檢查該檔案、目錄是否可執行\nEx:\nif [ -r /etc/fstab ]; then\n    echo \"You can read this file.\"\nfi\nif [ -w /etc/fstab ]; then\n    echo \"You have the \\\"write\\\" permission for this file.\"\nfi\nif [ -x /etc/fstab ]; then\n    echo \"You have the \\\"execute\\\" permission for this file.\"\nfi\n逐一簡查 /etc/fstab 這個檔案是否可以讀取、寫入和執行，如果符合就顯示相關訊息。\n如果您是以 root 身份來執行的話，那麼結果應該會顯示\nYou can read this file.\nYou have the \"write\" permission for this file.\n\n\n2. 選擇式判斷(case)\ncase 值 in\n參考值一)\n    執行一\n    ;;\n參考值二)\n     執行二\n    ;;\n參考值三)\n    執行三\n    ;;\n*)\n執行預設動作\n    exit 1\nesac\ncase 可以讀取所給的值，然後再依序尋找相符的條件，如果符合就執行動作，若都沒有找到符合的，就執行預設動作。\n\n範列\ntest=1\ncase $test in\n1)\n    echo \"Value 1\"\n    ;;\n2)\n    echo \"Value 2\"\n    ;;\n3)\n    echo \"Value 3\"\n    ;;\n*)\n    echo \"Can not find the value.\"\n    exit 1\nesac\n首先先設定一個變數 test，然後在使用 case 讀到 test 的變數值，再依續判斷是否有符合條件的，如果有就執行動作，若沒有就執行預設動作。\n在本例中，會顯示 \nValue 1\n\n3. 迴圈式判斷(for..do..)\nfor 變數 in 已宣告的變數集值\ndo\n    要重覆的動作\ndone\nEx:\nNAME=\"Steven Tom Lisa Sandy\"\nfor i in $NAME\ndo\n    echo $i\ndone\n先設定 NAME 的字串集合，然後在 for 裡建立一個變數 i 去讀取 NAME 的變數值，再依續顯示出來。\n在本列中，會顯示\nSteven\nTom\nLisa\nSandy\n\n\n/******************************************************************************/\nshell while循環輸出\n/******************************************************************************/\n功能就是從1輸出到10：\n\n#!/bin/sh\n#while\nCOUNT=0\nwhile [ $COUNT -lt 10 ]\ndo\n    COUNT=`expr $COUNT + 1`\n    echo $COUNT\ndone\n\n\n/******************************************************************************/\nShell 利用 test 指令的測試功能\n/******************************************************************************/\n檢測系統上面某些檔案或者是相關的屬性時，利用 test 這個指令來工作，舉例來說，我要檢查 /dmtsai 是否存在時，使用：\n[root@www ~]# test -e /filename\n執行結果並不會顯示任何訊息，但最後我們可以透過 $? 或 && 及 || 來展現整個結果呢！ \n例如我們在將上面的例子改寫成這樣：\n[root@www ~]# test -e /filename && echo \"exist\" || echo \"Not exist\"\nNot exist  <==結果顯示不存在啊！\n最終的結果可以告知我們是\"exist\"還是\"Not exist\"呢！那我知道 -e 是測試一個『東西』在不在，如果還想要測試一下該檔名是啥玩意兒時，還有哪些標誌可以來判斷的呢？\n\n測試的標誌      代表意義\n1. 關於某個檔名的『檔案類型』判斷，如 test -e filename 表示存在否\n-e              該『檔名』是否存在？(常用)\n-f              該『檔名』是否存在且為檔案(file)？(常用)\n-d              該『檔名』是否存在且為目錄(directory)？(常用)\n-b              該『檔名』是否存在且為一個 block device 裝置？\n-c              該『檔名』是否存在且為一個 character device 裝置？\n-S              該『檔名』是否存在且為一個 Socket 檔案？\n-p              該『檔名』是否存在且為一個 FIFO (pipe) 檔案？\n-L              該『檔名』是否存在且為一個連結檔？\n2. 關於檔案的權限偵測，如 test -r filename 表示可讀否 (但 root 權限常有例外)\n-r             偵測該檔名是否存在且具有『可讀』的權限？\n-w             偵測該檔名是否存在且具有『可寫』的權限？\n-x             偵測該檔名是否存在且具有『可執行』的權限？\n-u             偵測該檔名是否存在且具有『SUID』的屬性？\n-g             偵測該檔名是否存在且具有『SGID』的屬性？\n-k             偵測該檔名是否存在且具有『Sticky bit』的屬性？\n-s             偵測該檔名是否存在且為『非空白檔案』？\n3. 兩個檔案之間的比較，如： test file1 -nt file2\n-nt            (newer than)判斷 file1 是否比 file2 新\n-ot            (older than)判斷 file1 是否比 file2 舊\n-ef            判斷 file1 與 file2 是否為同一檔案，可用在判斷 hard link 的判定上。 主要意義在判定，兩個檔案是否均指向同一個 inode 哩！\n4. 關於兩個整數之間的判定，例如 test n1 -eq n2\n-eq            兩數值相等 (equal)\n-ne            兩數值不等 (not equal)\n-gt            n1 大於 n2 (greater than)\n-lt            n1 小於 n2 (less than)\n-ge            n1 大於等於 n2 (greater than or equal)\n-le            n1 小於等於 n2 (less than or equal)\n5. 判定字串的資料\ntest -z string  判定字串是否為 0 ？若 string 為空字串，則為 true\ntest -n string  判定字串是否非為 0 ？若 string 為空字串，則為 false。\n註： -n 亦可省略\ntest str1 = str2        判定 str1 是否等於 str2 ，若相等，則回傳 true\ntest str1 != str2       判定 str1 是否不等於 str2 ，若相等，則回傳 false\n6. 多重條件判定，例如： test -r filename -a -x filename\n-a      (and)兩狀況同時成立！例如 test -r file -a -x file，則 file 同時具有 r 與 x 權限時，才回傳 true。\n-o      (or)兩狀況任何一個成立！例如 test -r file -o -x file，則 file 具有 r 或 x 權限時，就可回傳 true。\n!       反相狀態，如 test ! -x file ，當 file 不具有 x 時，回傳 true\n\nOK！現在我們就利用 test 來幫我們寫幾個簡單的例子。首先，判斷一下，讓使用者輸入一個檔名，我們判斷：\n這個檔案是否存在，若不存在則給予一個『Filename does not exist』的訊息，並中斷程式；\n若這個檔案存在，則判斷他是個檔案或目錄，結果輸出\"Filename is regular file\"或\"Filename is directory\"\n判斷一下，執行者的身份對這個檔案或目錄所擁有的權限，並輸出權限資料！\n你可以先自行創作看看，然後再跟底下的結果討論討論。注意利用 test 與 && 還有 || 等標誌！\n[root@www scripts]# vi sh05.sh\n#!/bin/bash\n# Program:\n#       User input a filename, program will check the flowing:\n#       1.) exist? 2.) file/directory? 3.) file permissions \n# History:\n# 2005/08/25    VBird   First release\nPATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin\nexport PATH\n\n# 1. 讓使用者輸入檔名，並且判斷使用者是否真的有輸入字串？\necho -e \"Please input a filename, I will check the filename's type and permission. \\n\\n\"\nread -p \"Input a filename : \" filename\ntest -z $filename && echo \"You MUST input a filename.\" && exit 0\n\n# 2. 判斷檔案是否存在？若不存在則顯示訊息並結束腳本\ntest ! -e $filename && echo \"The filename '$filename' DO NOT exist\" && exit 0\n# 3. 開始判斷檔案類型與屬性\ntest -f $filename && filetype=\"regulare file\"\ntest -d $filename && filetype=\"directory\"\ntest -r $filename && perm=\"readable\"\ntest -w $filename && perm=\"$perm writable\"\ntest -x $filename && perm=\"$perm executable\"\n# 4. 開始輸出資訊！\necho \"The filename: $filename is a $filetype\"\necho \"And the permissions are : $perm\"\n如果你執行這個腳本後，他會依據你輸入的檔名來進行檢查喔！先看是否存在，再看為檔案或目錄類型，最後判斷權限。 但是你必須要注意的是，由於 root 在很多權限的限制上面都是無效的，所以使用 root 執行這個腳本時， 常常會發現與 ls -l 觀察到的結果並不相同！所以，建議使用一般使用者來執行這個腳本試看看。 不過你必須要使用 root 的身份先將這個腳本搬移給使用者就是了，不然一般使用者無法進入 /root 目錄的。 很有趣的例子吧！你可以自行再以其他的案例來撰寫一下可用的功能呢！\n\n\n/***************************************************************************/\nshell 基本常識\n/***************************************************************************/\n1.建立和運行shell程式\n什麼是shell程式呢? 簡單的說shell程式就是一個包含若干行shell或者linux命令的文件.\n像編寫高級語言的程式一樣,編寫一個shell程式需要一個文本編輯器.如VI等.\n在文本編輯環境下,依據shell的語法規則,輸入一些shell/linux命令行,形成一個完整的程式文件.\n執行shell程式文件有三種方法\n(1)# chmod +x file(在/etc/profile中,加入export PATH=${PATH}:~/yourpath,就可以在命令行下直接運行,像執行普通命令一樣)\n(2)# sh file\n(3)# ./file\n(4)# source file\n在編寫shell時,第一行一定要指明系統需要那種shell解釋你的shell程式,如:#! /bin/bash,\n #! /bin/csh,/bin/tcsh,還是#! /bin/pdksh .\n\n2.shell中的變數\n(1)常用系統變數\n$ #        :保存程式命令行參數的數目\n$ ?        :保存前一個命令的返回碼\n$ 0        :保存程式名\n$ *        :以(\"$1 $2...\")的形式保存所有輸入的命令行參數\n$ @        :以(\"$1\"\"$2\"...)的形式保存所有輸入的命令行參數\n(2)定義變數\nshell語言是非類型的解釋型語言,不像用C++/JAVA語言編程時需要事先聲明變數.給一個變數賦值,實際上就是定義了變數.\n在linux支援的所有shell中,都可以用賦值符號(=)為變數賦值.\n如: \nabc=9  (bash/pdksh不能在等號兩側留下空格 )\nset abc = 9 (tcsh/csh)\n由於shell程式的變數是無類型的,所以用戶可以使用同一個變數時而存放字元時而存放整數.\n如:\nname=abc  (bash/pdksh)\nset name = abc (tcsh)\n在變數賦值之後,只需在變數前面加一個$去引用.\n如:\necho $abc\n(3)位置變數\n當運行一個支援多個命令行參數的shell程式時,這些變數的值將分別存放在位置變數裡.\n其中第一個參數存放在位置變數1,第二個參數存放在位置變數2,依次類推...,shell保留這些變數,不允許用戶以令外的方式定義他們.同別的變數,用$符號引用他們.\n\n3.shell中引號的使用方法\nshell使用引號(單引號/雙引號)和反斜線(\"\\\")用於向shell解釋器屏蔽一些特殊字元.\n反引號(\")對shell則有特殊意義.\n如:\nabc=\"how are you\"  (bash/pdksh)\nset abc = \"how are you\"  (tcsh)\n這個命令行把三個單詞組成的字串how are you作為一個整體賦值給變數abc.\n  abc1='@LOGNAME,how are you!' (bash/pdksh)\n  set abc1='$LOGNAME,how are you!' (tcsh)\n  abc2=\"$LOGNAME,how are you!\" (bash/pdksh)\n  set abc2=\"$LOGNAME,how are you!\" (tcsh)\nLOGNAME變數是保存當前用戶名的shell變數,假設他的當前值是:wang.執行完兩條命令後,abc1的內容是:$LOGNAME, how are you!.而abc2的內容是;wang, how are you!.\n象單引號一樣,反斜線也能屏蔽所有特殊字元.但是他一次只能屏蔽一個字元.而不能屏蔽一組字元.\n反引號的功能不同於以上的三種符號.他不具有屏蔽特殊字元的功能.但是可以通過他將一個命令的運行結果傳遞給另外一個命令.\n如:\n  contents=`ls` (bash/pdksh)\n  set contents = `ls` (tcsh)\n\n4.shell程式中的test命令\n在bash/pdksh中,命令test用於計算一個條件表達式的值.他們經常在條件語句和循環語句中被用來判斷某些條件是否滿足.\ntest命令的語法格式:\n  test expression\n  或者\n  [expression]\n\n在test命令中,可以使用很多shell的內部操作符.這些操作符介紹如下:\n(1)字串操作符  用於計算字串表達式\n  test命令    |    含義\n  -----------------------------------------\n  Str1 = str2 | 當str1與str2相同時,返回True\n  Str1! = str2| 當str1與str2不同時,返回True\n     Str      | 當str不是空字元時,返回True\n    -n str    | 當str的長度大於0時,返回True\n    -z str    | 當str的長度是0時,返回True\n  -----------------------------------------\n  (2)整數操作符具有和字元操作符類似的功能.只是他們的操作是針對整數\n  test表達式   |    含義\n  ---------------------------------------------\n  Int1 -eq int2|當int1等於int2時,返回True\n  Int1 -ge int2|當int1大於/等於int2時,返回True\n  Int1 -le int2|當int1小於/等於int2時,返回True\n  Int1 -gt int2|當int1大於int2時,返回True\n  Int1 -ne int2|當int1不等於int2時,返回True\n  -----------------------------------------\n  (3)用於文件操作的操作符,他們能檢查:文件是否存在,文件類型等\n  test表達式   |    含義\n  ------------------------------------------------\n  -d file      |當file是一個目錄時,返回 True\n  -f file      |當file是一個普通文件時,返回 True\n  -r file      |當file是一個刻讀文件時,返回 True\n  -s file      |當file文件長度大於0時,返回 True\n  -w file      |當file是一個可寫文件時,返回 True\n  -x file      |當file是一個可執行文件時,返回 True\n  ------------------------------------------------\n(4)shell的邏輯操作符用於修飾/連接包含整數,字串,文件操作符的表達式\n  test表達式    |    含義\n  ----------------------------------------------------------\n  ! expr        |當expr的值是False時,返回True\n  Expr1 -a expr2|當expr1,expr2值同為True時,返回True\n  Expr1 -o expr2|當expr1,expr2的值至少有一個為True時,返回True\n  -----------------------------------------------------------\n注意:\ntcsh shell 不使用test命令,但是tcsh中的表達式同樣能承擔相同的功能.tcsh\n支援的表達式於C中的表達式相同.通常使用在if和while命令中.\n  tcsh表達式    |    含義\n  -------------------------------------------------------\n  Int1 <= int2  |當int1小於/等於int2時,返回True\n  Int1 >= int2  |當int1大於/等於int2時,返回True\n  Int1 < int2   |當int1小於int2時,返回True\n  Int1 > int2   |當int1大於int2時,返回True\n  Str1 == str2  |當str1與str2相同時,返回True\n  Str1 != str2  |當str1與str2不同時,返回True\n  -r file       |當file是一個可讀文件時,返回True\n  -w file       |當file是一個可寫文件時,返回True\n  -x file       |當file是一個可執行文件時,返回True\n  -e file       |當file存在時,返回True\n  -o file       |當file文件的所有者是當前用戶時,返回True\n  -z file       |當file長度為0時,返回True\n  -f file       |當file是一個普通文件時,返回True\n  -d file       |當file是一個目錄時,返回True\n  Exp1 || exp2  |當exp1和exp2的值至少一個為True時,返回True\n  Exp1 && exp2  |當exp1和exp2的值同為True時,返回True\n  ! exp         |當exp的值為False時,返回True \n\n\n/***************************************************************************/\nlinux shell grammer check\nLinux Shell語法速查表           https://sites.google.com/site/yunluliussite/linux-shell/linux-shell-grammer-check\n/***************************************************************************/\n雖然學過Linux Shell編程，但由於編寫Shell腳本的機會實在是比較少(通常在項目初期搭建開發環境時編寫得比較多一些)，所以一些語法久而久之就會忘了，一個簡單的語\n法去翻書效率實在是慢，所以就個人整理了一個表格，由於我用的編程語言是C/C++，所以在編程的時候往往腦海裡面首先浮現的是用C語言怎麼去編寫它，所以我乾脆拿C語言\n的語法來和Shell編程的語法作個對比表，這樣查起來就方便了：\n\n要實現的功能                    C語言編程                                                       Linux Shell腳本編程\n程式/腳本的參數傳遞             int main(int argc, char** argv)                                 #!/bin/sh\n                                {                                                               if [ $# -lt 3 ]; then\n                                    if (argv != 4) {                                                echo \"Usage: `basename $0` arg1 arg2 arg3\" >&2\n                                                                                                    exit 1\n                                        printf( 「Usage: %s arg1 arg2 arg3」, argv[0] );        fi\n                                                                                                echo \"arg1: $1\"\n                                        return 1;                                               echo \"arg2: $2\"\n                                                                                                echo \"arg3: $3\"\n                                    }                                                           exit 0\n                                    printf(「arg1:%s\\n」,argv[1]);\n                                    printf(「arg2:%s\\n」,argv[2]);\n                                    printf(「arg3:%s\\n」,argv[3]);\n                                    return 0;\n                                }\n\n\n/***************************************************************************/\n[Linux] 檢查檔案目錄是否存在\n/***************************************************************************/\n#檢查檔案是否存在\nFILE=abc\nif [ -f $FILE ]\nthen\n  echo \"$FILE EXIST\"\nelse\n  echo \"$FILE NOT EXIST\"\nfi\n\n#檢查目錄是否存在\nFOLDER=abc\nif [ -x $FOLDER ]\nthen\n  echo \"$FOLDER EXIST\"\nelse\n  echo \"$FOLDER NOT EXIST\"\nfi\n\n\n/***************************************************************************/\n[Linux] Shell Script 檔案載入變數之方法\n/***************************************************************************/\nconfig.ini\n#!/bin/sh\nTEST1=y\n\n\ntest.sh\n#!/bin/sh\nsource config.ini\nif [ \"$TEST1\" == \"y\" ]; then\n    echo \"TEST1!!\"\nfi\n\n\n\n/***************************************************************************/\nshell字串操作方法，以及實例\n/***************************************************************************/\n每一種語言都有他獨自的字串操作方法，shell也一樣，下面以以例子的方式，簡單介紹常用方法。\n1，取得字串長度\n查看複製列印?\nstring=abc12342341          //等號二邊不要有空格  \necho ${#string}             //結果11  \nexpr length $string         //結果11  \nexpr \"$string\" : \".*\"       //結果11 分號二邊要有空格,這裡的:根match的用法差不多  \n2，字串所在位置\n查看複製列印?\nexpr index $string '123'    //結果4 字串對應的下標是從0開始的  \n這個方法讓我想起來了js的indexOf，各種語言對字串的操作方法大方向都差不多，如果有語言基礎的話，學習shell會很快的。\n3，從字串開頭到子串的最大長度\n查看複製列印?\nexpr match $string 'abc.*3' //結果9  \n個人覺得這個函數的用處不大，為什麼要從開頭開始呢。\n4，字串截取\n查看複製列印?\necho ${string:4}      //2342341  從第4位開始截取後面所有字串  \necho ${string:3:3}    //123      從第3位開始截取後面3位  \necho ${string:3:6}    //123423   從第3位開始截取後面6位  \necho ${string: -4}    //2341  ：右邊有空格   截取後4位  \necho ${string:(-4)}   //2341  同上  \nexpr substr $string 3 3   //123  從第3位開始截取後面3位  \n上面的方法讓我想起了，php的substr函數，後面截取的規則是一樣的。\n5，匹配顯示內容\n查看複製列印?\n//例3中也有match和這裡的match不同，上面顯示的是匹配字元的長度，而下面的是匹配的內容  \nexpr match $string '\\([a-c]*[0-9]*\\)'  //abc12342341  \nexpr $string : '\\([a-c]*[0-9]\\)'       //abc1  \nexpr $string : '.*\\([0-9][0-9][0-9]\\)' //341 顯示括號中匹配的內容  \n這裡括號的用法，是不是根其他的括號用法有相似之處呢，\n6，截取不匹配的內容\n查看複製列印?\necho ${string#a*3}     //42341  從$string左邊開始，去掉最短匹配子串  \necho ${string#c*3}     //abc12342341  這樣什麼也沒有匹配到  \necho ${string#*c1*3}   //42341  從$string左邊開始，去掉最短匹配子串  \necho ${string##a*3}    //41     從$string左邊開始，去掉最長匹配子串  \necho ${string%3*1}     //abc12342  從$string右邊開始，去掉最短匹配子串  \necho ${string%%3*1}    //abc12     從$string右邊開始，去掉最長匹配子串  \n這裡要注意，必須從字串的第一個字元開始，或者從最後一個開始，\n7，匹配並且替換\n查看複製列印?\necho ${string/23/bb}   //abc1bb42341  替換一次  \necho ${string//23/bb}  //abc1bb4bb41  雙斜槓替換所有匹配  \necho ${string/#abc/bb} //bb12342341   #以什麼開頭來匹配，根php中的^有點像  \necho ${string/%41/bb}  //abc123423bb  %以什麼結尾來匹配，根php中的$有點像  \n\n/***************************************************************************/\n/***************************************************************************/\n/***************************************************************************/\n/***************************************************************************/\n/***************************************************************************/\n/***************************************************************************/\n/***************************************************************************/\n\n\n\n\n\n\n\n\n\n\n",
			"file": "Note_LinuxShellscript.txt",
			"file_size": 57802,
			"file_write_time": 131231571427093104,
			"settings":
			{
				"buffer_size": 44474,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"file": "Note_openwrt.txt",
			"settings":
			{
				"buffer_size": 33360,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"contents": "/******************************************************************************/\nSublime Text 基礎熱鍵表\n/******************************************************************************/\nCtrl + X\t\t\t\t\t刪除行\nCtrl + Enter\t\t\t\t插入下一行\nCtrl + Shift + Enter\t\t插入前一行\nCtrl + Shift + ↑\t\t\t往上移動一行\nCtrl + Shift + ↓\t\t\t往下移動一行\nCtrl + L\t\t\t\t\t選取整行\nCtrl + D\t\t\t\t\t選取單字（可重複選取相同的）\nAlt + F3\t\t\t\t\t選取所有已選取的單字\nCtrl + M\t\t\t\t\t跳到最近的括弧\nCtrl + Shift + M\t\t\t選取括弧內的所有文字\nCtrl + K + K\t\t\t\t刪除游標後方所有文字\nCtrl + K + Backspace\t\t刪除游標前方所有文字\nCtrl + ]\t\t\t\t\t向內縮排(通常使用Tab)\nCtrl + [\t\t\t\t\t向外縮排(通常使用Shift + Tab)\nCtrl + Shift + D\t\t\t複製行\nCtrl + J\t\t\t\t\t與下一行結合為同一行\nCtrl + /\t\t\t\t\t註解與移除註解\nCtrl + Shift + /\t\t\t區域註解\nCtrl + Y\t\t\t\t\t回覆上一步，沒有上一步時重複上個動作\nCtrl + Shift + V\t\t\t貼上並符合縮排\nCtrl + U\t\t\t\t\t軟回覆(包括選取動作)\n導覽/Goto Anything\t　\nCtrl + P\t快速開啟檔案\nCtrl + R\t快速到達符號(function, class, etc…)\nCtrl + G\t快速到達某一行\nCtrl + ;\t快速到達變數\n通用\t　\nCtrl + Shift + P\t\t命令提示符(包含所有命令)\nCtrl + K + B\t\t\t切換側欄\nCtrl + Shift + Alt + P\t切換狀態列\n搜尋/取代\t　\nCtrl + F\t\t\t搜尋\nCtrl + H\t\t\t取代\nCtrl + Shift + F\t檔案間搜尋\n分頁\t　\nCtrl + Shift + T\t還原最後關閉的分頁\nCtrl + PgUp\t\t\t換到上一個分頁\nCtrl + PgDown\t\t換到下一個分頁\nCtrl + Tab\t\t\t切換上一個分頁\nAlt + [NUM]\t\t\t切換到第[NUM]個分頁\n切割視窗\t　\nAlt + Shift + (2, 3, 4)\t\t垂直分割(2, 3, 4)個視窗\nAlt + Shift + 1\t\t\t\t回覆到預設\nAlt + Shift + 5\t\t\t\t水平垂直分割\nAlt + Shift + (8, 9)\t\t水平分割(2, 3)個視窗\n書籤\t　\nCtrl + F2\t切換書籤\nF2\t\t\t\t\t到下一個書籤\nShift + F2\t\t\t到上一個書籤\nCtrl + Shift + F2\t清除書籤\n文字操作\t　\nCtrl + K + U\t\t轉換為大寫\nCtrl + K + L\t\t轉換為小寫\n\n\n/******************************************************************************/\n快捷鍵功能\n/******************************************************************************/\nctrl+shift+n    打開新Sublime    \nctrl+shift+w    關閉Sublime，關閉所有打開文件    \nctrl+shift+t    重新打開最近關閉文件    \nctrl+n    \t\t新建文件    \nctrl+s    \t\t保存    \nctrl+shift+s    另存為    \nctrl+f4    \t\t關閉文件    \nctrl+w    \t\t關閉    \nctrl+k, ctrl+b  切換側邊欄顯示狀態    \nf11    \t\t\t切換全屏狀態    \nshift+f11    \t免打擾模式狀態切換    \nbackspace    \t刪除左側    \nshift+backspace \t\t   左側刪除    \nctrl+shift+backspace    \t左側全部刪除    \ndelete    \t\t\t\t右側刪除    \nenter    \t\t插入    \nshift+enter \t插入    \nctrl+z    \t\t撤消    \nctrl+shift+z    重做    \nctrl+y   \t\t重做或重複    \nctrl+u  \t\t軟撤消    \nctrl+shift+u    軟重做    \nctrl+shift+v    粘貼並格式化    \nshift+delete    剪切    \nctrl+insert     拷貝    \nshift+insert    粘貼    \nctrl+x    \t剪切    \nctrl+c    拷貝    \nctrl+v    粘貼    \nleft    移動    \nright    移動    \nup    移動    \ndown    移動    \nshift+left    移動並選擇    \nshift+right    移動並選擇    \nshift+up    移動並選擇    \nshift+down    移動並選擇    \nctrl+left    按\\w規則移動（跳躍）    \nctrl+right    按\\w規則移動（跳躍）    \nctrl+shift+left    按\\w規則移動並選擇（跳躍）    \nctrl+shift+right    按\\w規則移動並選擇（跳躍）    \nalt+left    按單詞移動    \nalt+right    按單詞移動    \nalt+shift+left    按單詞移動並選擇    \nalt+shift+right    按單詞移動並選擇    \nctrl+alt+up    選擇多行進行編輯    \nctrl+alt+down    選擇多行進行編輯    \npageup    移動    \npagedown    移動    \nshift+pageup    移動+選擇    \nshift+pagedown    移動+選擇    \nhome    移動到行首    \nend    移動到行尾    \nshift+home    選擇到行首    \nshift+end    選擇到行尾    \nctrl+home    移動到頁首行頭    \nctrl+end    移動到頁尾行尾    \nctrl+shift+home    選擇到頁首行頭    \nctrl+shift+end    選擇到頁尾行尾    \nctrl+up    滾動行    \nctrl+down    滾動行    \nctrl+pagedown    下一視圖（視覺位置）    \nctrl+pageup    前一視圖    \nctrl+tab    棧中下一視圖（打開順序）    \nctrl+shift+tab    棧中前一視圖    \nctrl+a    全選    \nctrl+shift+l    選擇多行編輯    \nescape    單個選擇    \nescape    清除字段    \nescape    清除字段    \nescape    隱藏面板    \nctrl+]    縮進    \nctrl+[    不縮進    \nctrl+l    選擇行，重複可依次增加選擇下一行    \nctrl+d    選擇單詞，重複可增加選擇下一個相同的單詞    \nctrl+m    跳轉到對應括號    \nctrl+shift+enter    在當前行前插入新行    \nctrl+p    搜索項目中的文件    \nctrl+shift+p    打開命令面板    \nctrl+r    前往Method    \nctrl+g    跳轉到第幾行    \nctrl+f    查找    \nctrl+h    查找替換    \nctrl+shift+h    查找替換下一個    \nf3    下一個匹配項    \nshift+f3    上一個匹配項    \nctrl+f3    下一個匹配項    \nctrl+/    當前行註釋狀態切換    \nctrl+shift+/    當前位置註釋狀態切換    \nctrl+j    選擇標籤內容，將後繼行附加到行尾    \n\n\n/******************************************************************************/\nVintage模式\n/******************************************************************************/\nref: http://feliving.github.io/Sublime-Text-3-Documentation/vintage.html\n\n概述\nVintage是Sublime Text的vi模式編輯包。 可以使用組合vi命令來調用Sublime Text的功能，包括多重選擇。\nVintage模式是開放開發的，而且非常歡迎進行完善和擴展。如果你願意做點貢獻的話，可以在GitHub頁面上找到更多細節。\n\n啟用Vintage\nVintage默認是禁用的， 通過ignored_packages 配置。如果要從ignored packages列表中移除\"Vintage\"的話可以通過下面的方式編輯:\n選擇Preferences/Settings - Default功能表\n編輯ignored_packages配置, 修改:\n    \"ignored_packages\": [\"Vintage\"]\n成:\n    \"ignored_packages\": []\n然後保存文件。\nVintage模式則已啟用——你可以看到\"INSERT MODE\"顯示在狀態欄了。\n\nVintage默認是插入模式。可以添加:\n    \"vintage_start_in_command_mode\": true\n這項配置到User Settings裡。\n\n包含哪些功能\nVintage包含大部分的基本命令：d (delete), y (copy), c (change), gu (lower case), gU (upper case), g~ (swap case), g? (rot13), < (unindent), and > (indent)。\n同時也包含許多移動操作，包括l, h, j, k, W, w, e, E, b, B, alt+w (move by sub-words), alt+W (move backwards by sub-words), $, ^, %, 0, G, gg, f, F, t, T, ^f, ^b, H, M, and L.\n文本對象的支援，包括詞，引號，括號和標籤。\n重複點號('.')也是支援的， 用於重複指定次數的命令和移動。寄存器也是支援的，有宏命令和書籤。許多其它混合命令也支援，比如*, /, n, N, s, S 等等。\n\n哪些沒有\n插入模式時常規的Sublime Text編輯模式，綁定的是Sublime Text常用的快捷鍵：並沒有模仿vi 插入模式的鍵盤綁定。\n通過via命令面板執行的Ex commands沒有實現，除了:w和:e。\nUnder the Hood\nVintage模式完全是參考via鍵盤綁定和基於插件API來實現的——你可以自由的瀏覽Vintage包，看看它們是如何組合在一起的。舉個例子，如果你要把 \"jj\" 綁定為退出插入模式，你可以像下面這樣天劍鍵盤綁定：\n{ \"keys\": [\"j\", \"j\"], \"command\": \"exit_insert_mode\",\n    \"context\":\n    [\n        { \"key\": \"setting.command_mode\", \"operand\": false },\n        { \"key\": \"setting.is_widget\", \"operand\": false }\n    ]\n}\n\nOS X Lion\nLion系統下，按住某個鍵不會重複，但是會彈出一個功能表選擇字元變更。在命令模式下這樣並不是很好，如果你想禁用它，可以通過在os x的終端裡輸入下面這個語句：\ndefaults write com.sublimetext.2 ApplePressAndHoldEnabled -bool false\n\nCtrl Keys\nVintage支援下面這些ctrl key的綁定:\nCtrl+[: Escape\nCtrl+R: Redo\nCtrl+Y: Scroll down one line\nCtrl+E: Scroll up one line\nCtrl+F: Page Down\nCtrl+B: Page Up\n不過，因為這些會與Sublime Text的其它鍵盤綁定衝突，Windows和Linux下默認是禁用的。可以通過vintage_ctrl_keys來配置:\n    \"vintage_ctrl_keys\": true\n\n\n/******************************************************************************/\n/******************************************************************************/\n/******************************************************************************/\n/******************************************************************************/\n",
			"file": "Note_SublimeText.txt",
			"file_size": 7637,
			"file_write_time": 131309376060065690,
			"settings":
			{
				"buffer_size": 6029,
				"line_ending": "Windows",
				"scratch": true
			}
		},
		{
			"file": "/X/Dexter1101Bt/Docs/Travel/Japan_Kyoto/Note.md",
			"settings":
			{
				"buffer_size": 3838,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "/X/repos/c-template/README.md",
			"settings":
			{
				"buffer_size": 8780,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/X/repos/MusicPlayer/InternetRadio_mpc/test.sh",
			"settings":
			{
				"buffer_size": 645,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/X/repos/MusicPlayer/InternetRadio_mpc/streams.txt",
			"settings":
			{
				"buffer_size": 1311,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/X/repos/MusicPlayer/InternetRadio_mpc/mpcontrol.py",
			"settings":
			{
				"buffer_size": 1063,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/AAAPackageDev/Support/Convert to ....sublime-build",
					""
				],
				[
					"Packages/AAAPackageDev/Support/Convert to ....sublime-build",
					"JSON"
				],
				[
					"Packages/AAAPackageDev/Support/Convert to ....sublime-build",
					"Property List"
				],
				[
					"Packages/AAAPackageDev/Support/Convert to ....sublime-build",
					"YAML (Block Style)"
				],
				[
					"Packages/AAAPackageDev/Support/Convert to ....sublime-build",
					"YAML (Default Style)"
				]
			],
			[
				"Packages/AAAPackageDev/Support/Convert to ....sublime-build",
				"Property List"
			]
		],
		[
			[
				[
					"Packages/C++/C++ Single File.sublime-build",
					""
				],
				[
					"Packages/C++/C++ Single File.sublime-build",
					"Run"
				]
			],
			[
				"Packages/C++/C++ Single File.sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/Makefile/Make.sublime-build",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					"Clean"
				]
			],
			[
				"Packages/Makefile/Make.sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/Python/Python.sublime-build",
					""
				],
				[
					"Packages/Python/Python.sublime-build",
					"Syntax Check"
				]
			],
			[
				"Packages/Python/Python.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 354.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"Package Control: ",
				"Package Control: Install Package"
			],
			[
				"dis",
				"Package Control: Disable Package"
			],
			[
				"pcr",
				"Package Control: Remove Package"
			],
			[
				"pci",
				"Package Control: Install Package"
			],
			[
				"p",
				"Package Control: Enable Package"
			],
			[
				"Package Control: i",
				"Package Control: Disable Package"
			],
			[
				"Package Control: install",
				"Package Control: Install Package"
			],
			[
				"install package",
				"Package Control: Install Package"
			],
			[
				"remove",
				"Package Control: Remove Package"
			],
			[
				"mater",
				"Material Theme: Activate theme"
			],
			[
				"theme",
				"Material Theme: Advanced configuration"
			],
			[
				"material",
				"Material Theme: Activate theme"
			],
			[
				"br",
				"Preferences: Browse Packages"
			],
			[
				"Package Control: ins",
				"Package Control: Install Package"
			],
			[
				"pc",
				"Package Control: List Packages"
			]
		],
		"width": 510.0
	},
	"console":
	{
		"height": 198.0,
		"history":
		[
			"<script>document.write('<script src=\"http://' + (location.host || '${1:localhost}').split(':')[0] + ':${2:35729}/livereload.js?snipver=1\"></' + 'script>')</script>",
			"git",
			"import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)",
			"ls",
			"dir",
			"ls",
			"dir",
			"sublime.Selection.clear()",
			"sublime.Selection.clear(self)",
			"sublime.Selection.clear()",
			"view.substr(reg)",
			"reg",
			"sublime.Selection.add_all(reg)",
			"reg",
			"sublime.Selection.add_all(5)",
			"sublime.Selection.add_all(5,10)",
			"sublime.Selection.add(5,10)",
			"sublime.Selection.add(5)",
			"sublime.Selection.add(reg)",
			"sublime.selection.add(reg)",
			"sublime.Selection.add(reg)",
			"sublime.Selection().add(reg)",
			"sublime.Selection.add(reg)",
			"reg=sublime.Region(10150,10181)",
			"reg=sublime.Region(0,1)",
			"reg=Region(0,1)",
			"sublime.Selection.add(10150,10181)",
			"sublime.Selection.add(0)",
			"sublime.add(0)",
			"Sublime.add(0)",
			"Sublime.add()",
			"view.text_point(row, 0)",
			"view.text_point(row, col)",
			"(row,col) = view.rowcol(view.sel()[0].begin())",
			"view.text_point(row, col)",
			"(row,col) = view.rowcol(view.sel()[0].begin())",
			"view.text_point(row, col)",
			"(row,col) = view.rowcol(view.sel()[0].begin())",
			"view.text_point(row, col)",
			"(row,col) = view.rowcol(view.sel()[0].begin())",
			"view.text_point(row, col)",
			"text_point(row, col)",
			"view.line(2)",
			"view.line(1)",
			"view.line(row)",
			"region=view.line(row)",
			"view.substr(region)",
			"region",
			"view.substr(2)",
			"view.substr(2, 3 ,2)",
			"view.substr(2, 3)",
			"region",
			"view.substr(2,3)",
			"view.substr(2)",
			"view.substr(1)",
			"region",
			"region=view.line(row)",
			"view.substr(26)",
			"view.substr(25)",
			"view.substr(region)",
			"region=view.line(row)",
			"row",
			"(row,col) = view.rowcol(view.sel()[0].begin())",
			"view.substr(region)",
			"region=view.line(row+1)",
			"row",
			"(row,col) = view.rowcol(view.sel()[0].begin())",
			"view.substr(region)",
			"region=view.line(row)",
			"(row,col) = view.rowcol(view.sel()[0].begin())",
			"view.substr(region)",
			"region=view.line(row)",
			"(row,col) = view.rowcol(view.sel()[0].begin())",
			"view.substr(region)",
			"region=view.line(row)",
			"(row,col) = view.rowcol(view.sel()[0].begin())",
			"view.substr(region)",
			"region=view.line(row)",
			"(row,col) = view.rowcol(view.sel()[0].begin())",
			"view.substr(region)",
			"region=view.line(row)",
			"(row,col) = view.rowcol(view.sel()[0].begin())",
			"view.substr(region)",
			"sublime.substr(region)",
			"sublime.Region(region)",
			"Region(region)",
			"view.word(region)",
			"word(region)",
			"region=view.line(row)",
			"view.line(row)",
			"row",
			"(row,col) = view.rowcol(view.sel()[0].begin())",
			"row",
			"(row,col) = view.rowcol(view.sel()[0].begin())",
			"view.line(0)",
			"view.word(0)",
			"view.word(14)",
			"view.sel()[0].begin()",
			"col",
			"row",
			"(row,col) = view.rowcol(view.sel()[0].begin())",
			"(row,col) = view.rowcol(self.view.sel()[0].begin())",
			"(row,col) = self.view.rowcol(self.view.sel()[0].begin())",
			"view.id()",
			"view.sel()",
			"for i in view.sel():",
			"view.sel()",
			"view.line(15)",
			"view.word(15)",
			"view.word(10)",
			"view.word(1)",
			"view.word(5)",
			"view.show(5)",
			"view.show(1)",
			"view.open_file(\"log.txt\")",
			"view.substr(1)",
			"view.substr(12)",
			"view.substr(\"sdasf\")",
			"view.substr('123')",
			"self.view.substr('123')",
			"view.run_command('example')",
			"view.run_command('Example')",
			"view.run_command('example')",
			"view.run_command('Example')",
			"view.run_command('example')",
			"dir()",
			"dir",
			"k=window.extract_variables()"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/X/Dexter1101Bt/Docs/StudyNote"
	],
	"file_history":
	[
		"/X/repos/MusicPlayer/InternetRadio_mpc/playlist.m3u",
		"/X/repos/MusicPlayer/InternetRadio_mpc/Readme.md",
		"/X/repos/MusicPlayer/InternetRadio_mpc/stream.sh",
		"/X/Dexter1101Bt/Docs/StudyNote/Travel_2017_OSAKA.md",
		"/X/repos/MusicPlayer/InternetRadio_mpc/stream.txt",
		"/X/Dexter1101Bt/Docs/StudyNote/README.md",
		"/C/Users/DEXTER.LU/Desktop/test.md",
		"/X/Dexter1101Bt/Docs/StudyNote/Note_MsOffice.txt",
		"/C/SoftwareTools/Sublime Text Build/Data/Packages/LiveReload/LiveReload.sublime-settings",
		"/X/Dexter1101Bt/Docs/StudyNote/Note_Markdown.md",
		"/C/SoftwareTools/Sublime Text Build/Data/Packages/User/Package Control.sublime-settings",
		"/X/Dexter1101Bt/Docs/StudyNote/Note_Japan.md",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Frontier/Note_Frontier.txt",
		"/X/Dexter1101Bt/Docs/StudyNote/Note_SublimeText.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/Project_JS/Sam Firmware/sam-2.1.17-S-generic/sam-cdk/tools/bin/JsAir_MP/Note_Gen_Firmware.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/Project_Magnat/Sam Firmware/sam-2.3.17-S-generic/sam-cdk/files/device-tree/CS_Serial/Sample01/cus227_CS_10.dts",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/Project_Auluxe/Sam Firmware/sam-2.0.34-SA-generic/sam-cdk/files/device-tree/E3/cus227_E3.dts",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/Project_Auluxe/Sam Firmware/sam-2.3.18-S-generic/sam-cdk/tools/bin/E3_forApple3rd/Note_Gen_Firmware.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/Project_Auluxe/Sam Firmware/sam-2.0.34-SA-generic/sam-cdk/tools/bin/E3/cus227_E3.dtb",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/Project_Magnat/Sam Firmware/sam-2.3.17-S-generic/sam-cdk/tools/bin/CS_Serial/Sample01/Note_Gen_Firmware.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/Project_Magnat/Sam Firmware/sam-2.3.17-S-generic/sam-cdk/tools/bin/CS_Serial/Sample01/Gen_upgrade_test/Magnat_40-S.sam.mft",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/Project_Magnat/Sam Firmware/sam-2.3.17-S-generic/sam-cdk/tools/bin/CS_Serial/Sample01/Gen_upgrade_test/Magnat_10-S.sam.mft",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/Project_JS/Sam Firmware/sam-2.1.17-S-generic/sam-cdk/files/device-tree/JsAir_MP/cus227_JsAir_1.dts",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/Project_JS/Note_Gen_Firmware.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Libre/Project_JS/Deluxe_1/Software Customization Kit_LS9_v3.1/FENV/envitem.xml",
		"/E/Downloads/OLED_I2C/OLED_I2C.cpp",
		"/E/DEXTER/IntRadio.py",
		"/X/Dexter1101Bt/StudyProject/RaspberryPi3/Desktop/IFTTT/C_Button/piIfttt.c",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Libre/Project_ETON/EtonSample/Software Customization Kit_LS9_v3.1/FENV/envitem.xml",
		"/X/Dexter1101Bt/StudyProject/RaspberryPi3/Desktop/IFTTT/button/gpio_input.py",
		"/X/Dexter1101Bt/StudyProject/RaspberryPi3/Desktop/IFTTT/button/test.py",
		"/X/Dexter1101Bt/StudyProject/BeagleBone/CES_SmartSpeaker_Project/home/debian/cropse/touch/touch.py",
		"/E/Pi/AllJoynPhilipsHueDSB/README.md",
		"/E/DEXTER/[ssh 192.168.100.35] (2016-12-30_140311).log",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Libre/LibreSync/LS_Firmwares/LS6/v6108_15Nov16/Firmwares/MergeTool/FENV/envitem.xml",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Libre/From_Ann/BIST_Image_withTZ key/TZ key tool/Libre_SWProcessTool_V2.3_Win7_64bit/Libre_SWProcess_Tool.log",
		"/X/Dexter1101Bt/Docs/StudyNote/Note_MTK_7688.txt",
		"/X/Dexter1101Bt/Docs/StudyNote/Note_Alljoyn.txt",
		"/C/SoftwareTools/Sublime Text Build/Packages/Java.sublime-package",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Libre/From_Ann/GoogleKey_LIBRE_TEST_291/LIBRE_TEST_294/factory/client.crt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Libre/From_Ann/GoogleKey_LIBRE_TEST_291/LIBRE_TEST_294/factory/serial.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Libre/From_Ann/GoogleKey_LIBRE_TEST_291/LIBRE_TEST_294/factory/bssid.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Libre/From_Ann/GoogleKey_LIBRE_TEST_291/LIBRE_TEST_293/factory/bssid.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Libre/From_Ann/GoogleKey_LIBRE_TEST_291/LIBRE_TEST_292/factory/bssid.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Libre/From_Ann/GoogleKey_LIBRE_TEST_291/LIBRE_TEST_291/factory/bssid.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Libre/From_Ann/GoogleKey_LIBRE_TEST_291/LIBRE_TEST_291/factory/serial.txt",
		"/E/DEXTER/RunProgram_W10.bat",
		"/C/Users/DEXTER.LU/Desktop/RunProgram_W10 - 捷徑.lnk",
		"/E/DEXTER/WorkDocs/Note_WorkMisc.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/Project_Allplay/allplaySoftware/liballplaymcu_v2.0.1/st3proj.sublime-project",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Libre/From_Ann/BIST_Image_withTZ key/TZ key tool/Libre_SWProcessTool_V2.3_Win7_64bit/BTmacidused.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Libre/From_Ann/BIST_Image_withTZ key/TZ key tool/Libre_SWProcessTool_V2.3_Win7_64bit/config.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Libre/From_Ann/BIST_Image_withTZ key/TZ key tool/Libre_SWProcessTool_V2.3_Win7_64bit/MappingDetails.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Libre/From_Ann/BIST_Image_withTZ key/TZ key tool/Libre_SWProcessTool_V2.3_Win7_64bit/No_WIFImacid.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/Project_Auluxe/Sam Firmware/sam-2.0.34-SA-generic/sam-cdk/tools/bin/E3/Note_Gen_Firmware.txt",
		"/E/Downloads/README.md",
		"/X/Dexter1101Bt/Docs/StudyNote/Note_RaspberryPi.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/Project_Auluxe/Docs/CertAllplay/ForAllplayTeam/cus227_E3.dts",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/Project_Auluxe/Docs/CertAllplay/ForAllplayTeam/JsAir_T.sam.mft",
		"/X/repos/history.txt",
		"/X/repos/Readme.txt",
		"/X/Readme",
		"/E/DEXTER/Eclipse workspace/TCPClient/src/com/example/tcpclient/TCPClient.java",
		"/E/DEXTER/Eclipse workspace/TCPServer/src/TCPServer.java",
		"/C/Users/DEXTER.LU/Desktop/hs_err_pid13697.log",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Libre/Project_JS/Deluxe_1_withLibreGoogleKey/Software Customization Kit_LS9_v3.1/FENV/envitem.xml",
		"/X/repos/AmazonAlexa/alexa-avs-sample-app/samples/javaclient/pom.xml",
		"/C/Users/DEXTER.LU/Desktop/hs_err_pid27693.log",
		"/C/Users/DEXTER.LU/Desktop/log_play_icrt_err_20161128.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Libre/Project_JS/LS_Firmwares/Software Customization Kit_LS9_v3.1/FENV/envitem.xml",
		"/E/DEXTER/AirPlay/Note_Airplay.txt",
		"/E/DEXTER/[Com COM1] (2016-11-18_161817).log",
		"/E/DEXTER/[Com COM1] (2016-11-18_160514).log",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Libre/Note_Libre.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Libre/Project_JS/LS_Firmwares/LS9/LS9_V9075_TZ/ENVXML/envitem.xml",
		"/E/Downloads/mopidy.gpg",
		"/C/SoftwareTools/Sublime Text Build 3083/Data/Packages/User/Anaconda.sublime-settings",
		"/C/SoftwareTools/Sublime Text Build 3083/Data/Packages/Anaconda/Anaconda.sublime-settings",
		"/C/SoftwareTools/Sublime Text Build 3083/Data/Packages/User/Plain text.sublime-settings",
		"/C/SoftwareTools/Sublime Text Build 3083/Data/Packages/Git/Git.sublime-settings",
		"/X/Dexter1101Bt/Docs/Note/Note_Git.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/Note_Allplay.txt",
		"/X/Dexter1101Bt/Docs/Note/Note_MTK_7688.txt",
		"/C/Users/DEXTER.LU/Desktop/ALLPLAY Network Status.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/Project_Auluxe/Sam Firmware/sam-2.3.18-S-generic/sam-cdk/tools/bin/E3/Note_Gen_Firmware.txt",
		"/X/Dexter1101Bt/Docs/Note/Note_Network.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/Misc/WPS_on_sam2.3.17-s/wps_message.txt",
		"/C/SoftwareTools/Sublime Text Build 3083/Data/Installed Packages/Material Theme.sublime-package",
		"/C/SoftwareTools/Sublime Text Build 3083/Data/Cache/Material Theme/schemes/Material-Theme-Darker.tmTheme.cache",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/ALLPlay Docs/Sam Firmware/CustomVersion/Auluxe/Readme.txt",
		"/E/Downloads/dropbox.py",
		"/X/Dexter1101Bt/Docs/Note/Note_Linux.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/Project_Magnat/Sam Firmware/sam-2.3.17-S-generic/sam-cdk/tools/bin/CS_Serial/Sample01/Mcu/Magnat_test/Magnat_10-S.sam.mft",
		"/C/Users/DEXTER.LU/Desktop/ETH0 status.txt",
		"/E/DEXTER/WorkDocs/Module_WifiAudio/Qualcomm/Project_JS/Sam Firmware/sam-2.3.18-S-generic/sam-cdk/tools/bin/JsAir_MP/Note_Gen_Firmware.txt",
		"/C/Users/DEXTER.LU/Desktop/oem.config",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/Project_Auluxe/Sam Firmware/sam-2.0.34-SA-generic/sam-cdk/files/device-tree/E3/cus227_E31.dts",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/Project_Auluxe/Sam Firmware/sam-2.3.18-S-generic/sam-cdk/files/device-tree/E3/cus227.dts",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/Project_Auluxe/Sam Firmware/sam-2.3.18-S-generic/sam-cdk/tools/bin/E3/Note_Gen_Firmware.txt",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/Project_Auluxe/Sam Firmware/sam-2.3.18-S-generic/sam-cdk/files/oem.config",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/Project_JS/Sam Firmware/sam-2.3.18-S-generic/sam-cdk/files/oem.config_air5",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/Project_JS/Sam Firmware/sam-2.3.18-S-generic/sam-cdk/files/oem.config",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/Project_Auluxe/Sam Firmware/sam-2.3.18-S-generic/sam-cdk/files/device-tree/E3/cus227_E3_Telnet.dts",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/Project_Magnat/Sam Firmware/sam-2.1.17-S-generic/sam-cdk/files/oem.config",
		"/X/Dexter1101Bt/Docs/Note/Note_openwrt.txt",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/Project_Auluxe/Sam Firmware/sam-2.0.34-SA-generic/sam-cdk/files/device-tree/E3/cus227_E3.dts",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/Project_Auluxe/Sam Firmware/sam-2.3.18-S-generic/sam-cdk/files/device-tree/E3/cus227_E3.dts",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/Project_Auluxe/Sam Firmware/sam-2.0.34-SA-generic/sam-cdk/tools/bin/E3_forApple/Note_Gen_Firmware.txt",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/Project_Auluxe/Sam Firmware/sam-2.0.34-SA-generic/sam-cdk/tools/bin/E3/Note_Gen_Firmware.txt",
		"/E/log.txt",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/Project_Auluxe/Sam Firmware/sam-2.0.34-SA-generic/sam-cdk/tools/bin/E3/McuOnly/E3.sam.mft",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/Project_JS/Sam Firmware/sam-2.0.34-S-generic/sam-cdk/tools/bin/JsAir_MP_forApple/Note_Gen_Firmware_forAirplayAudit.txt",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Libre/Project_JS/LS_Firmwares/Software Customization Kit_LS9_v3.1/FENV/envitem.xml",
		"/C/SoftwareTools/Sublime Text Build 3083/Data/Packages/User/Preferences.sublime-settings",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Libre/LibreSync/LS_Firmwares/LS9/LS9_Release_NonTZ_v9055_16Aug2016/FENV/envitem.xml",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Libre/Project_JS/Deluxe_1/Software Customization Kit_LS9_v3.1/FENV/envitem.xml",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Module_WifiAudio.sublime-project",
		"/E/Downloads/python-wifi-0.6.1/api-2011.txt",
		"/E/Downloads/python-wifi-0.6.1/README",
		"/E/Downloads/7688 speaker (1).cdr",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/ALLPlay Docs/Sam Firmware/FromTao_EU_EN_300328_1.9.1_testing_firmware/cus227.dtb",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/Project_Magnat/Sam Firmware/sam-2.3.17-S-generic/sam-cdk/tools/bin/CS_Serial/Sample01/Note_Gen_Firmware.txt",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/Project_JS/Sam Firmware/sam-2.0.34-S-generic/sam-cdk/tools/bin/JsAir_MP/Note_Gen_Firmware_forAirplayAudit.txt",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/Project_Magnat/Sam Firmware/sam-2.1.17-S-generic/sam-cdk/tools/bin/CS_Serial/Sample01/Note_Gen_Firmware.txt",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/Project_JS/Sam Firmware/sam-2.0.34-S-generic/sam-cdk/tools/bin/JsAir_MP/Note_Gen_Firmware.txt",
		"/E/Downloads/7688 speaker.cdr",
		"/E/DEXTER/Work Docs/Module_WifiAudio/Qualcomm/Project_Magnat/Sam Firmware/Request_ThunderSoft/oem.config",
		"/X/Dexter1101Bt/Docs/Note/Note_Linux1.txt"
	],
	"find":
	{
		"height": 70.0
	},
	"find_in_files":
	{
		"height": 90.0,
		"where_history":
		[
			"<current file>,<open folders>,C:\\Users\\CROPSE.MA\\Desktop\\KeyObject_Normal_withGENKey\\mbed\\TARGET_NUCLEO_F091RC,C:\\Users\\CROPSE.MA\\Desktop\\DigitalOut_HelloWorld\\mbed\\TARGET_NUCLEO_F072RB",
			"<current file>,<open folders>,C:\\Users\\CROPSE.MA\\Desktop\\KeyObject_Normal_withGENKey\\mbed\\TARGET_NUCLEO_F091RC",
			"<current file>,<open folders>",
			"<current file>",
			"C:\\Users\\CROPSE.MA\\Desktop\\Bamster Outdoor\\Bamster Outdoor\\Source Code",
			"C:\\Users\\CROPSE.MA\\Desktop\\Bamster Outdoor\\Bamster Outdoor"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"stream",
			"  .",
			"Ctrl",
			"helloworld",
			"staging",
			"staging_dir",
			"target-mipsel",
			"fuse",
			"mpc",
			"Install Kernel",
			"Dealing with",
			"backup",
			"LUCI command",
			"LUCI",
			"bluetooth",
			"setenv",
			"mpc",
			"setup",
			"shairport",
			"usb",
			"shairport",
			"config",
			"airplayj",
			"airplay",
			"vlc",
			"i2s",
			"package",
			"model",
			"support",
			"usb",
			"root",
			"13.14",
			"TW",
			"ssh",
			"open",
			"apt-get install",
			"tcp",
			"7777",
			"port",
			"LUCI_local",
			"message box",
			"mac",
			"Libre",
			"version",
			"Deluxe",
			"allow",
			"can not",
			"LUCI_local",
			"version",
			"ia32-lib",
			"dd",
			"DDMS",
			"fw",
			"url",
			"firmware",
			"usb",
			"telnet",
			"netif",
			"auto",
			"hostpresent",
			"version",
			"deluxe",
			"ethernet",
			"device id",
			"hostpresent",
			"gpio",
			"luci_local",
			"LUCI",
			"run",
			"putty",
			"root",
			"nand",
			"run",
			"mkfs",
			"fstab",
			"fdisk",
			"update",
			"uboot",
			"dexter.lu@jazzhipster.com.tw",
			"raspberry",
			"uboot",
			"142",
			"mac",
			"new",
			"telnet",
			"linein",
			"java",
			"12.12",
			"E3/",
			"hostpresent",
			"version",
			"WAC",
			"LUCI_local",
			"hostpresent",
			"142",
			"124",
			"wac",
			"root",
			"uboot",
			"type a",
			"uart",
			"BIST",
			"type a",
			"block0",
			"button",
			"usb",
			"tty",
			"root",
			"error",
			"11.11",
			"rd353",
			"bear",
			"token",
			"6c",
			"LUCI_local",
			"SAC/WAC you can use LUCI_local 142 1 ",
			"LUCI_local",
			"factory",
			"LS",
			"airplay",
			"LSConfig",
			"name",
			"Model",
			"device",
			"libre",
			"Librei",
			"Libre",
			"Deluxe"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
			"14.16",
			"ETON_a1",
			"13.14",
			"E3_forApple3rd/",
			"12.12E3_forApple3rd/",
			"12.12",
			"11.11",
			"E3_forApple3rd",
			"0.10.10",
			"--out \"E3_forApple3rd",
			"FromTao_sam-2.3.18-SA_AppleAudit3rd",
			"DDDD",
			"sam-2.3.18-SA-jazzhipster-theme-auluxe-new",
			"007",
			"006",
			"002",
			"2.3.18",
			"FromTao_sam-2.2.18-SA_withCA",
			"E3_forApple/",
			"E3_forApple",
			"openwrt_ar71xx_generic_cus227_firmware",
			"FromTao_sam-2.2.18-SA",
			"2.2.18",
			"0.9.09",
			"Deluxe_01",
			"0.8.08",
			"sam-2.3.17-S-jazzhipster-theme-magnet-new",
			"2.3.17",
			"05",
			"2.2.18",
			"openwrt_ar71xx_generic_cus227_firmware",
			"_ar71xx",
			"/",
			"JsAir_MP_forApple",
			"../../../../FromTao_sam-2.2.18-SA/",
			"04",
			"03",
			"45",
			"31",
			"45",
			"31",
			"2.1.17",
			"\"sam\" \"2.1.17",
			"45",
			"1.2a",
			"SA",
			"50W",
			"30W",
			"SoundAround_MP01",
			"SOUNDAROUND_Wi-Fi_system/SW30W",
			"SoundAround_MP01",
			"a",
			"BTSend('G')",
			" \"Source Code/"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": false,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 4,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "Note_Linux.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 588622,
						"regions":
						{
						},
						"selection":
						[
							[
								5481,
								5481
							]
						],
						"settings":
						{
							"is_init_dirty_state": false,
							"origin_encoding": "UTF-8",
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 304.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "Note_LinuxShellscript.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 44474,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"in_converting": true,
							"is_init_dirty_state": false,
							"origin_encoding": "BIG5",
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "Note_openwrt.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 33360,
						"regions":
						{
						},
						"selection":
						[
							[
								21729,
								21729
							]
						],
						"settings":
						{
							"is_init_dirty_state": false,
							"origin_encoding": "UTF-8",
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 351.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "Note_SublimeText.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6029,
						"regions":
						{
						},
						"selection":
						[
							[
								1237,
								1237
							]
						],
						"settings":
						{
							"in_converting": true,
							"is_init_dirty_state": false,
							"origin_encoding": "BIG5",
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 293.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "/X/Dexter1101Bt/Docs/Travel/Japan_Kyoto/Note.md",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3838,
						"regions":
						{
						},
						"selection":
						[
							[
								1758,
								1758
							]
						],
						"settings":
						{
							"is_init_dirty_state": false,
							"origin_encoding": "UTF-8",
							"parser": "markdown",
							"syntax": "Packages/Markdown/Markdown.sublime-syntax",
							"target": "disk"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "/X/repos/c-template/README.md",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8780,
						"regions":
						{
						},
						"selection":
						[
							[
								3407,
								3407
							]
						],
						"settings":
						{
							"parser": "markdown",
							"syntax": "Packages/Markdown/Markdown.sublime-syntax",
							"target": "browser"
						},
						"translation.x": 0.0,
						"translation.y": 1311.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "/X/repos/MusicPlayer/InternetRadio_mpc/test.sh",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 645,
						"regions":
						{
						},
						"selection":
						[
							[
								54,
								54
							]
						],
						"settings":
						{
							"is_init_dirty_state": false,
							"origin_encoding": "ASCII",
							"syntax": "Packages/ShellScript/Shell-Unix-Generic.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "/X/repos/MusicPlayer/InternetRadio_mpc/streams.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1311,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								52
							]
						],
						"settings":
						{
							"is_init_dirty_state": false,
							"origin_encoding": "ASCII",
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "/X/repos/MusicPlayer/InternetRadio_mpc/mpcontrol.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1063,
						"regions":
						{
						},
						"selection":
						[
							[
								123,
								123
							]
						],
						"settings":
						{
							"is_init_dirty_state": false,
							"origin_encoding": "ASCII",
							"syntax": "Packages/Python/Python.sublime-syntax",
							"word_wrap": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 29.0
	},
	"input":
	{
		"height": 34.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 153.0
	},
	"output.figlet_preview":
	{
		"height": 118.0
	},
	"output.find_results":
	{
		"height": 264.0
	},
	"output.git":
	{
		"height": 124.0
	},
	"output.package_dev":
	{
		"height": 29.0
	},
	"output.unsaved_changes":
	{
		"height": 124.0
	},
	"pinned_build_system": "Packages/Python/Python.sublime-build",
	"project": "StudyNote.sublime-project",
	"replace":
	{
		"height": 54.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"note",
				"Note_Allplay.txt"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"C:\\Users\\CROPSE.MA\\Desktop\\BT sound base\\T30 N20_no48l11_RCA_AUX_ARC\\SoundBase.sublime-project"
			]
		],
		"width": 594.0
	},
	"select_symbol":
	{
		"height": 392.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 392.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 314.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
